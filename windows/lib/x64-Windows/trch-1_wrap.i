
/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */








/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */












/* inline attribute */








/* attribute recognised by some compilers to avoid 'unused' warnings */
















#pragma warning(disable : 4505) 











/* internal SWIG method */




/* internal inline SWIG method */




/* exporting methods */
























/* calling conventions for Windows */








/* Deal with Microsoft's attempt at deprecating C standard runtime functions */




/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */




/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */




/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */



















/* Since this is a "meta-include" file, no #ifdef __cplusplus / extern "C" { */

/* Include nearly all Python header files */



/* Python version identification scheme.

   When the major or minor version changes, the VERSION variable in
   configure.ac must also be changed.

   There is also (independent) API version information in modsupport.h.
*/

/* Values for PY_RELEASE_LEVEL */




                                        /* Higher for patch releases */

/* Version parsed out into numeric values */
/*--start constants--*/






/* Version as a string */

/*--end constants--*/

/* Version as a single 4-byte hex number, e.g. 0x010502B2 == 1.5.2b2.
   Use this for numeric comparisons, e.g. #if PY_VERSION_HEX >= ... */










/* pyconfig.h.  NOT Generated automatically by configure.

This is a manually maintained version used for the Watcom,
Borland and Microsoft Visual C++ compilers.  It is a
standard part of the Python distribution.

WINDOWS DEFINES:
The code specific to Windows should be wrapped around one of
the following #defines

MS_WIN64 - Code specific to the MS Win64 API
MS_WIN32 - Code specific to the MS Win32 (and Win64) API (obsolete, this covers all supported APIs)
MS_WINDOWS - Code specific to Windows, but all versions.
Py_ENABLE_SHARED - Code if the Python core is built as a DLL.

Also note that neither "_M_IX86" or "_MSC_VER" should be used for
any purpose other than "Windows Intel x86 specific" and "Microsoft
compiler specific".  Therefore, these should be very rare.


NOTE: The following symbols are deprecated:
NT, USE_DL_EXPORT, USE_DL_IMPORT, DL_EXPORT, DL_IMPORT
MS_CORE_DLL.

WIN32 is still required for the locale module.

*/

/* Deprecated USE_DL_EXPORT macro - please use Py_BUILD_CORE */




/* Visual Studio 2005 introduces deprecation warnings for
   "insecure" and POSIX functions. The insecure functions should
   be replaced by *_s versions (according to Microsoft); the
   POSIX functions by _* versions (which, according to Microsoft,
   would be ISO C conforming). Neither renaming is feasible, so
   we just silence the warnings. */

















//
// io.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the low-level I/O and file handling functionality.
//
#pragma once




//
// corecrt_io.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the low-level I/O and file handling functionality.  These
// declarations are split out to support the Windows build.
//
#pragma once


//
// corecrt_share.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Defines the file sharing modes for the sopen() family of functions.  These
// declarations are split out to support the Windows build.
//
#pragma once












    
    
    
    



//
// corecrt_wio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <io.h> and <wchar.h>.
//
#pragma once


//
// corecrt.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the CoreCRT library.
//
#pragma once


//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
#pragma once
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//




// Many VCRuntime headers avoid exposing their contents to non-compilers like
// the Windows resource compiler and Qt's meta-object compiler (moc).








    


// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.

    
    


        


            
        
    



/***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/
#pragma once

/*==========================================================================

   The comments in this file are intended to give basic understanding of
   the usage of SAL, the Microsoft Source Code Annotation Language.
   For more details, please see https://go.microsoft.com/fwlink/?LinkID=242134

   The macros are defined in 3 layers, plus the structural set:

   _In_/_Out_/_Ret_ Layer:
   ----------------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. These macros typically start with:
      _In_     : input parameter to a function, unmodified by called function
      _Out_    : output parameter, written to by called function, pointed-to
                 location not expected to be initialized prior to call
      _Outptr_ : like _Out_ when returned variable is a pointer type
                 (so param is pointer-to-pointer type). Called function
                 provides/allocated space.
      _Outref_ : like _Outptr_, except param is reference-to-pointer type.
      _Inout_  : inout parameter, read from and potentially modified by
                 called function.
      _Ret_    : for return values
      _Field_  : class/struct field invariants
   For common usage, this class of SAL provides the most concise annotations.
   Note that _In_/_Out_/_Inout_/_Outptr_ annotations are designed to be used
   with a parameter target. Using them with _At_ to specify non-parameter
   targets may yield unexpected results.

   This layer also includes a number of other properties that can be specified
   to extend the ability of code analysis, most notably:
      -- Designating parameters as format strings for printf/scanf/scanf_s
      -- Requesting stricter type checking for C enum parameters

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_ or _Post_.
   This layer provides the most flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.

   Structural Layer:
   ----------------
   These annotations, like _At_ and _When_, are used with annotations from
   any of the other layers as modifiers, indicating exactly when and where
   the annotations apply.


   Common syntactic conventions:
   ----------------------------

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, are for formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the parameter can be NULL as a precondition to the function, the
   annotation contains _opt. If the macro does not contain '_opt' the
   parameter cannot be NULL.

   If an out/inout parameter returns a null pointer as a postcondition, this is
   indicated by _Ret_maybenull_ or _result_maybenull_. If the macro is not
   of this form, then the result will not be NULL as a postcondition.
     _Outptr_ - output value is not NULL
     _Outptr_result_maybenull_ - output value might be NULL

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   -------------
   Buffer sizes are expressed as element counts, unless the macro explicitly
   contains _byte_ or _bytes_. Some annotations specify two buffer sizes, in
   which case the second is used to indicate how much of the buffer is valid
   as a postcondition. This table outlines the precondition buffer allocation
   size, precondition number of valid elements, postcondition allocation size,
   and postcondition number of valid elements for representative buffer size
   annotations:
                                     Pre    |  Pre    |  Post   |  Post
                                     alloc  |  valid  |  alloc  |  valid
      Annotation                     elems  |  elems  |  elems  |  elems
      ----------                     ------------------------------------
      _In_reads_(s)                    s    |   s     |   s     |   s
      _Inout_updates_(s)               s    |   s     |   s     |   s
      _Inout_updates_to_(s,c)          s    |   s     |   s     |   c
      _Out_writes_(s)                  s    |   0     |   s     |   s
      _Out_writes_to_(s,c)             s    |   0     |   s     |   c
      _Outptr_result_buffer_(s)        ?    |   ?     |   s     |   s
      _Outptr_result_buffer_to_(s,c)   ?    |   ?     |   s     |   c

   For the _Outptr_ annotations, the buffer in question is at one level of
   dereference. The called function is responsible for supplying the buffer.

   Success and failure:
   -------------------
   The SAL concept of success allows functions to define expressions that can
   be tested by the caller, which if it evaluates to non-zero, indicates the
   function succeeded, which means that its postconditions are guaranteed to
   hold.  Otherwise, if the expression evaluates to zero, the function is
   considered to have failed, and the postconditions are not guaranteed.

   The success criteria can be specified with the _Success_(expr) annotation:
     _Success_(return != FALSE) BOOL
     PathCanonicalizeA(_Out_writes_(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
        pszBuf is only guaranteed to be NULL-terminated when TRUE is returned,
        and FALSE indiates failure. In common practice, callers check for zero
        vs. non-zero returns, so it is preferable to express the success
        criteria in terms of zero/non-zero, not checked for exactly TRUE.

   Functions can specify that some postconditions will still hold, even when
   the function fails, using _On_failure_(anno-list), or postconditions that
   hold regardless of success or failure using _Always_(anno-list).

   The annotation _Return_type_success_(expr) may be used with a typedef to
   give a default _Success_ criteria to all functions returning that type.
   This is the case for common Windows API status types, including
   HRESULT and NTSTATUS.  This may be overridden on a per-function basis by
   specifying a _Success_ annotation locally.

============================================================================*/



































// Disable expansion of SAL macros in non-Prefast mode to
// improve compiler throughput.









// safeguard for MIDL and RC builds

































// Some annotations aren't officially SAL2 yet.





//============================================================================
//   Structural SAL:
//     These annotations modify the use of other annotations.  They may
//     express the annotation target (i.e. what parameter/field the annotation
//     applies to) or the condition under which the annotation is applicable.
//============================================================================

// _At_(target, annos) specifies that the annotations listed in 'annos' is to
// be applied to 'target' rather than to the identifier which is the current
// lexical target.


// _At_buffer_(target, iter, bound, annos) is similar to _At_, except that
// target names a buffer, and each annotation in annos is applied to each
// element of target up to bound, with the variable named in iter usable
// by the annotations to refer to relevant offsets within target.


// _When_(expr, annos) specifies that the annotations listed in 'annos' only
// apply when 'expr' evaluates to non-zero.




// <expr> indicates whether normal post conditions apply to a function


// <expr> indicates whether post conditions apply to a function returning
// the type that this annotation is applied to


// Establish postconditions that apply only if the function does not succeed


// Establish postconditions that apply in both success and failure cases.
// Only applicable with functions that have  _Success_ or _Return_type_succss_.


// Usable on a function defintion. Asserts that a function declaration is
// in scope, and its annotations are to be used. There are no other annotations
// allowed on the function definition.


// _Notref_ may precede a _Deref_ or "real" annotation, and removes one
// level of dereference if the parameter is a C++ reference (&).  If the
// net deref on a "real" annotation is negative, it is simply discarded.


// Annotations for defensive programming styles.







//============================================================================
//   _In_/_Out_ Layer:
//============================================================================

// Reserved pointer parameters, must always be NULL.


// _Const_ allows specification that any namable memory location is considered
// readonly for a given call.



// Input parameters --------------------------

//   _In_ - Annotations for parameters where data is passed into the function, but not modified.
//          _In_ by itself can be used with non-pointer types (although it is redundant).

// e.g. void SetPoint( _In_ const POINT* pPT );



// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );




// 'input' buffers with given size











// 'input' buffers valid to the given end pointer








// Output parameters --------------------------

//   _Out_ - Annotations for pointer or reference parameters where data passed back to the caller.
//           These are mostly used where the pointer/reference is to a non-pointer type.
//           _Outptr_/_Outref) (see below) are typically used to return pointers via parameters.

// e.g. void GetPoint( _Out_ POINT* pPT );


























// Inout parameters ----------------------------

//   _Inout_ - Annotations for pointer or reference parameters where data is passed in and
//        potentially modified.
//          void ModifyPoint( _Inout_ POINT* pPT );
//          void ModifyPointByRef( _Inout_ POINT& pPT );




// For modifying string buffers
//   void toupper( _Inout_z_ char* sz );



// For modifying buffers with explicit element size











// For modifying buffers with explicit byte size










// Pointer to pointer parameters -------------------------

//   _Outptr_ - Annotations for output params returning pointers
//      These describe parameters where the called function provides the buffer:
//        HRESULT SHStrDupW(_In_ LPCWSTR psz, _Outptr_ LPWSTR *ppwsz);
//      The caller passes the address of an LPWSTR variable as ppwsz, and SHStrDupW allocates
//      and initializes memory and returns the pointer to the new LPWSTR in *ppwsz.
//
//    _Outptr_opt_ - describes parameters that are allowed to be NULL.
//    _Outptr_*_result_maybenull_ - describes parameters where the called function might return NULL to the caller.
//
//    Example:
//       void MyFunc(_Outptr_opt_ int **ppData1, _Outptr_result_maybenull_ int **ppData2);
//    Callers:
//       MyFunc(NULL, NULL);           // error: parameter 2, ppData2, should not be NULL
//       MyFunc(&pData1, &pData2);     // ok: both non-NULL
//       if (*pData1 == *pData2) ...   // error: pData2 might be NULL after call






// Annotations for _Outptr_ parameters returning pointers to null terminated strings.






// Annotations for _Outptr_ parameters where the output pointer is set to NULL if the function fails.




// Annotations for _Outptr_ parameters which return a pointer to a ref-counted COM object,
// following the COM convention of setting the output to NULL on failure.
// The current implementation is identical to _Outptr_result_nullonfailure_.
// For pointers to types that are not COM objects, _Outptr_result_nullonfailure_ is preferred.






// Annotations for _Outptr_ parameters returning a pointer to buffer with a specified number of elements/bytes

































// Annotations for output reference to pointer parameters.


















// Annotations for output reference to pointer parameters that guarantee
// that the pointer is set to NULL on failure.


// Generic annotations to set output value of a by-pointer or by-reference parameter to null/zero on failure.




// return values -------------------------------

//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const noexcept;



// used with allocated but not yet initialized objects




// used with allocated and initialized objects
//    returns single valid object


//    returns pointer to initialized buffer of specified size







//    returns pointer to partially initialized buffer, with total size 'size' and initialized size 'count'






// Annotations for strict type checking




// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();



// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );









// annotations to express value of integral or pointer parameter









// annotation to express that a value (usually a field of a mutable class)
// is not changed by a function call


// Annotations to allow expressing generalized pre and post conditions.
// 'cond' may be any valid SAL expression that is considered to be true as a precondition
// or postcondition (respsectively).



// Annotations to express struct, class and field invariants




















//============================================================================
//   _Pre_/_Post_ Layer:
//============================================================================

//
// Raw Pre/Post for declaring custom pre/post conditions
//




//
// Validity property
//





//
// Buffer size properties
//

// Expressing buffer sizes without specifying pre or post condition








// Expressing buffer size as pre or post condition










//
// Pointer null-ness properties
//




//
// _Pre_ annotations ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string


// valid size unknown or indicated by type (e.g.:LPSTR)





// Overrides recursive valid when some field is not yet initialized when using _Inout_


// used with allocated but not yet initialized objects




//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call


// e.g. HRESULT InitStruct( _Post_valid_ Struct* pobj );



// e.g. void free( _Post_ptr_invalid_ void* pv );


// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );


// e.g. HRESULT GetObject(_Outptr_ _On_failure_(_At_(*p, _Post_null_)) T **p);







#pragma region Input Buffer SAL 1 compatibility macros

/*==========================================================================

   This section contains definitions for macros defined for VS2010 and earlier.
   Usage of these macros is still supported, but the SAL 2 macros defined above
   are recommended instead.  This comment block is retained to assist in
   understanding SAL that still uses the older syntax.

   The macros are defined in 3 layers:

   _In_/_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ/Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.

   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2

   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter





// valid buffer extent described by a constant extression





// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter





// nullterminated valid buffer extent described by a constant extression





// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );






// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by another parameter multiplied by a constant expression





// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );





// only use with dereferenced arguments e.g. '*pcch'










// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );






// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );










// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );


















// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );















// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
















// returning pointers to valid objects



// annotations to express 'boundedness' of integral value parameter








// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );





// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );





//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );



// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex condition





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent















// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n );
// valid buffer extent is described by another parameter





// valid buffer extent is described by a constant expression





// valid buffer extent is described by a complex expression





// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );








// restrict access rights



//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );



// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent















// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );







//
// _Deref_ret_ ---
//




//
// special _Deref_ ---
//


//
// _Ret_ ---
//

// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );



// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter





// Buffer capacity is described by a constant expression





// Buffer capacity is described by a complex condition





// return value is nullterminated and capacity is given by another parameter





// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter





// Valid Buffer extent is described by a constant expression





// Valid Buffer extent is described by a complex expression





// return value is nullterminated and length is given by another parameter






// _Pre_ annotations ---


// restrict access rights



// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_ptr_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter





// buffer capacity described by a constant expression







// buffer capacity is described by another parameter multiplied by a constant expression



// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);



// buffer capacity described by a complex condition





// buffer capacity described by the difference to another pointer parameter



// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );















// known capacity and valid but unknown readable extent















// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter





// Valid buffer extent described by a constant expression





// Valid buffer extent described by a complex expression





// Valid buffer extent described by the difference to another pointer parameter




// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call


// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );



// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );







// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );







//
// _Prepost_ ---
//
// describing conditions that hold before and after the function call



















//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call










































//
// _Deref_<miscellaneous>
//
// used with references to arrays







#pragma endregion Input Buffer SAL 1 compatibility macros


//============================================================================
//   Implementation Layer:
//============================================================================


// Naming conventions:
// A symbol the begins with _SA_ is for the machinery of creating any
// annotations; many of those come from sourceannotations.h in the case
// of attributes.

// A symbol that ends with _impl is the very lowest level macro.  It is
// not required to be a legal standalone annotation, and in the case
// of attribute annotations, usually is not.  (In the case of some declspec
// annotations, it might be, but it should not be assumed so.)  Those
// symols will be used in the _PreN..., _PostN... and _RetN... annotations
// to build up more complete annotations.

// A symbol ending in _impl_ is reserved to the implementation as well,
// but it does form a complete annotation; usually they are used to build
// up even higher level annotations.





















































































































// Using "nothing" for sal



















































































































































































































































































































































































































































































































































// Obsolete -- may be needed for transition to attributes.





// This section contains the deprecated annotations

/*
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz     : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     __in LPCSTR pszString,
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     __in LPCSTR pszSrc,
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return != FALSE) LWSTDAPI_(BOOL)
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/















/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/

/*
    The helper annotations are only understood by the compiler version used by
    various defect detection tools. When the regular compiler is running, they
    are defined into nothing, and do not affect the compiled code.
*/




















































































































































































































    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    



/*
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/
































































































































































































/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/



































    
    






























//
// Set the analysis mode (global flags to analysis).
// They take effect at the point of declaration; use at global scope
// as a declaration.
//

// Synthesize a unique symbol.








//
// Floating point warnings are only meaningful in kernel-mode on x86
// so avoid reporting them on other platforms.
//















// The following are predefined:
//  _Analysis_operator_new_throw_   (operator new throws)
//  _Analysis_operator_new_null_        (operator new returns null)
//  _Analysis_operator_new_never_fails_ (operator new never fails)
//

// Function class annotations.


















/***
*concurrencysal.h - markers for documenting the concurrent semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains macros for Concurrency SAL annotations. Definitions
*       starting with _Internal are low level macros that are subject to change.
*       Users should not use those low level macros directly.
*       [ANSI]
*
*       [Public]
*
****/




#pragma once











































































































































































































































































































































/*
 * Old spelling: will be deprecated
 */













































//
// vadefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Definitions of macro helpers used by <stdarg.h>.  This is the topmost header
// in the CRT header lattice, and is always the first CRT header to be included,
// explicitly or implicitly.  Therefore, this header also has several definitions
// that are used throughout the CRT.
//
#pragma once



#pragma pack(push, 8)










    
    
        typedef unsigned __int64  uintptr_t;
    





    
    


        typedef char* va_list;
    





    











    
    




















































    void __cdecl __va_start(va_list* , ...);

    
    



    








































    



#pragma pack(pop)


// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.






















    


    




__pragma(pack(push, 8))




    


        
    

















    




        
    



    


        
    


// Definitions of calling conventions used code sometimes compiled as managed




    
    





    




// Definitions of common __declspecs




    







    





    



    



      
    


// For backwards compatibility


// Definitions of common types

    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;













    typedef _Bool __vcrt_bool;


// Indicate that these common types are defined

    



    



    


// Provide a typedef for wchar_t for use under /Zc:wchar_t-

    
    typedef unsigned short wchar_t;



    


        
    



    













    







    


        
    

    






        
        
    

    






// [[nodiscard]] attributes on STL functions

    
        
    









    


// See note on use of "deprecate" at the top of this file



    



    
        
    













    
        
    






    void __cdecl __security_init_cookie(void);

    



        void __cdecl __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(  uintptr_t _StackCookie);
    


extern uintptr_t __security_cookie;


    
    
    


__pragma(pack(pop))




__pragma(pack(push, 8))



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Annotation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    




        
    


// If you need the ability to remove __declspec(import) from an API, to support static replacement,
// declare the API using _ACRTIMP_ALT instead of _ACRTIMP.

    



    




        
    





    



    









    


// __declspec(guard(overflow)) enabled by /sdl compiler switch for CRT allocators



    





    


// The CLR requires code calling other SecurityCritical code or using SecurityCritical types
// to be marked as SecurityCritical.
// _CRT_SECURITYCRITICAL_ATTRIBUTE covers this for internal function definitions.
// _CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE is for inline pure functions defined in the header.
// This is clr:pure-only because for mixed mode we compile inline functions as native.



    














    


        
    





    





    





    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Miscellaneous Stuff
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+





















    typedef _Bool __crt_bool;











    










// CRT headers are included into some kinds of source files where only data type
// definitions and macro definitions are required but function declarations and
// inline function definitions are not.  These files include assembly files, IDL
// files, and resource files.  The tools that process these files often have a
// limited ability to process C and C++ code.  The _CRT_FUNCTIONS_REQUIRED macro
// is defined to 1 when we are compiling a file that actually needs functions to
// be declared (and defined, where applicable), and to 0 when we are compiling a
// file that does not.  This allows us to suppress declarations and definitions
// that are not compilable with the aforementioned tools.

    


        
    







    



 






  


   
  
 


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Windows API Partitioning and ARM Desktop Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    











        
    



    



    
        
    




// Verify that the ARM Desktop SDK is available when building an ARM Desktop app








//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Invalid Parameter Handler
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+










 void __cdecl _invalid_parameter_noinfo(void);
 __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
 void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    



        // By default, _CRT_SECURE_INVALID_PARAMETER in retail invokes
        // _invalid_parameter_noinfo_noreturn(), which is marked
        // __declspec(noreturn) and does not return control to the application.
        // Even if _set_invalid_parameter_handler() is used to set a new invalid
        // parameter handler which does return control to the application,
        // _invalid_parameter_noinfo_noreturn() will terminate the application
        // and invoke Watson. You can overwrite the definition of
        // _CRT_SECURE_INVALID_PARAMETER if you need.
        //
        // _CRT_SECURE_INVALID_PARAMETER is used in the Standard C++ Libraries
        // and the SafeInt library.
        

    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Deprecation and Warnings
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




    





    



    
        
    








//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Managed CRT Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    






        
    



    


        
    








//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// SecureCRT Configuration
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



























    







    





    


        


            
        
    













    


        



    



    
        
    





    
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0
        
    





    
        
              
        


    





    
        
    





    
        
    







    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Basic Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ // state of a multibyte translation
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;










    


        typedef __time64_t time_t;
    


// Indicate that these common types are defined

    



    typedef size_t rsize_t;





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Secure Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    























































































































































        
        
        
        
        
        
        
        
        
        
        
        

    







































































//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Standard Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        












































    




__pragma(pack(pop))



__pragma(pack(push, 8))


#pragma warning(push)
#pragma warning(disable:4820) 


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




    
    


typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+






    
    
    
    


 
 int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


 errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
 int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  
 int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
 intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
 int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

 int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
 int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

 errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );




 
  wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);


 
 
 intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
 intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
 intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
 int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
 int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
 int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


 errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

 errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );




































      
     int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OpenFlag,
        ...);

      
     int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OpenFlag,
            int            _ShareFlag,
        ...);




#pragma warning(pop)


__pragma(pack(pop))


__pragma(pack(push, 8))



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




    
    


struct _finddata32_t
{
    unsigned    attrib;
    __time32_t  time_create;    // -1 for FAT file systems
    __time32_t  time_access;    // -1 for FAT file systems
    __time32_t  time_write;
    _fsize_t    size;
    char        name[260];
};

struct _finddata32i64_t
{
    unsigned    attrib;
    __time32_t  time_create;    // -1 for FAT file systems
    __time32_t  time_access;    // -1 for FAT file systems
    __time32_t  time_write;
    __int64     size;
    char        name[260];
};

struct _finddata64i32_t
{
    unsigned    attrib;
    __time64_t  time_create;    // -1 for FAT file systems
    __time64_t  time_access;    // -1 for FAT file systems
    __time64_t  time_write;
    _fsize_t    size;
    char        name[260];
};

struct __finddata64_t
{
    unsigned    attrib;
    __time64_t  time_create;    // -1 for FAT file systems
    __time64_t  time_access;    // -1 for FAT file systems
    __time64_t  time_write;
    __int64     size;
    char        name[260];
};



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// File attribute constants for the _findfirst() family of functions









//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+






    
    
    
    




     
     int __cdecl _access(
          char const* _FileName,
            int         _AccessMode
        );

    
     errno_t __cdecl _access_s(
          char const* _FileName,
            int         _AccessMode
        );

     
     int __cdecl _chmod(
          char const* _FileName,
            int         _Mode
        );

     
     int __cdecl _chsize(
          int  _FileHandle,
          long _Size
        );

    
     errno_t __cdecl _chsize_s(
          int     _FileHandle,
          __int64 _Size
        );

    
     int __cdecl _close(
          int _FileHandle
        );

    
     int __cdecl _commit(
          int _FileHandle
        );

      
     int __cdecl _creat(
          char const* _FileName,
            int         _PermissionMode
        );

     
     int __cdecl _dup(
          int _FileHandle
        );

     
     int __cdecl _dup2(
          int _FileHandleSrc,
          int _FileHandleDst
        );

     
     int __cdecl _eof(
          int _FileHandle
        );

     
     long __cdecl _filelength(
          int _FileHandle
        );

     
     
     intptr_t __cdecl _findfirst32(
          char const*           _FileName,
           struct _finddata32_t* _FindData
        );

     
     
     int __cdecl _findnext32(
           intptr_t              _FindHandle,
          struct _finddata32_t* _FindData
        );

    
     int __cdecl _findclose(
          intptr_t _FindHandle
        );

     intptr_t __cdecl _get_osfhandle(
              int _FileHandle
            );

     
     int __cdecl _isatty(
          int _FileHandle
        );

     int __cdecl _locking(
              int  _FileHandle,
              int  _LockMode,
              long _NumOfBytes
            );

    
     long __cdecl _lseek(
          int  _FileHandle,
          long _Offset,
          int  _Origin
        );

     
    
     errno_t __cdecl _mktemp_s(
          char*  _TemplateName,
                              size_t _Size
        );

    


     
        char * __cdecl _mktemp( char *_TemplateName);


     int __cdecl _open_osfhandle(
          intptr_t _OSFileHandle,
          int      _Flags
        );

    
         
         
         int __cdecl _pipe(
                 int*         _PtHandles,
                            unsigned int _PipeSize,
                            int          _TextMode
            );
    

     
     
     int __cdecl _read(
                                       int          _FileHandle,
          void*        _DstBuf,
                                       unsigned int _MaxCharCount
        );

     int __cdecl remove(
          char const* _FileName
        );

     
     int __cdecl rename(
          char const* _OldFilename,
          char const* _NewFilename
        );

     int __cdecl _unlink(
          char const* _FileName
        );

     
     int __cdecl _setmode(
          int _FileHandle,
          int _Mode
        );

     
     long __cdecl _tell(
          int _FileHandle
        );

    
     int __cdecl _umask(
          int _Mode
        );

    
     errno_t __cdecl _umask_s(
           int  _NewMode,
          int* _OldMode
        );

     int __cdecl _write(
                                     int          _FileHandle,
          void const*  _Buf,
                                     unsigned int _MaxCharCount
        );

     
     __int64 __cdecl _filelengthi64(
          int _FileHandle
        );

     
     
     intptr_t __cdecl _findfirst32i64(
          char const*              _FileName,
           struct _finddata32i64_t* _FindData
        );

     
     
     intptr_t __cdecl _findfirst64i32(
          char const*              _FileName,
           struct _finddata64i32_t* _FindData
        );

     
     
     intptr_t __cdecl _findfirst64(
          char const*            _FileName,
           struct __finddata64_t* _FindData
        );

     
     
     int __cdecl _findnext32i64(
           intptr_t                 _FindHandle,
          struct _finddata32i64_t* _FindData
        );

     
     
     int __cdecl _findnext64i32(
           intptr_t                 _FindHandle,
          struct _finddata64i32_t* _FindData
        );

     
     
     int __cdecl _findnext64(
           intptr_t               _FindHandle,
          struct __finddata64_t* _FindData
        );

    
     __int64 __cdecl _lseeki64(
          int     _FileHandle,
          __int64 _Offset,
          int     _Origin
        );

     
     __int64 __cdecl _telli64(
          int _FileHandle
        );

    
     errno_t __cdecl _sopen_s(
           int*        _FileHandle,
          char const* _FileName,
            int         _OpenFlag,
            int         _ShareFlag,
            int         _PermissionMode
        );

     
     errno_t __cdecl _sopen_s_nolock(
           int*        _FileHandle,
          char const* _FileName,
            int         _OpenFlag,
            int         _ShareFlag,
            int         _PermissionMode
        );

     errno_t __cdecl _sopen_dispatch(
          char const* _FileName,
            int         _OFlag,
            int         _ShFlag,
            int         _PMode,
           int*        _PFileHandle,
            int         _BSecure
        );



    































          
         int __cdecl _open(
              char const* _FileName,
                int         _OpenFlag,
            ...);

          
         int __cdecl _sopen(
              char const* _FileName,
                int         _OpenFlag,
                int         _ShareFlag,
            ...);

    



    
        // Suppress warnings about double deprecation
        #pragma warning(push)
        #pragma warning(disable: 4141)

          
         int __cdecl access(
              char const* _FileName,
                int         _AccessMode
            );

          
         int __cdecl chmod(
              char const* _FileName,
                int         _AccessMode
            );

          
         int __cdecl chsize(
              int  _FileHandle,
              long _Size
            );

         
         int __cdecl close(
              int _FileHandle
        );

           
         int __cdecl creat(
              char const* _FileName,
                int         _PermissionMode
            );

          
         int __cdecl dup(
              int _FileHandle
            );

          
         int __cdecl dup2(
              int _FileHandleSrc,
              int _FileHandleDst
            );

          
         int __cdecl eof(
              int _FileHandle
            );

          
         long __cdecl filelength(
              int _FileHandle
            );

          
         int __cdecl isatty(
              int _FileHandle
            );

          
         int __cdecl locking(
              int  _FileHandle,
              int  _LockMode,
              long _NumOfBytes
            );

         
         long __cdecl lseek(
              int  _FileHandle,
              long _Offset,
              int  _Origin
            );

         
         
         char * __cdecl mktemp(
              char* _TemplateName
            );

           
         int __cdecl open(
              char const* _FileName,
                int         _OpenFlag,
            ...);

         
        
         int __cdecl read(
                                           int          _FileHandle,
              void*        _DstBuf,
                                           unsigned int _MaxCharCount
            );

          
         int __cdecl setmode(
              int _FileHandle,
              int _Mode
            );

         
         int __cdecl sopen(
              char const* _FileName,
              int         _OpenFlag,
              int         _ShareFlag,
            ...);

          
         long __cdecl tell(
              int _FileHandle
            );

         
         int __cdecl umask(
              int _Mode
            );

        
         int __cdecl unlink(
              char const* _FileName
            );

          
         int __cdecl write(
                                         int          _FileHandle,
              void const*  _Buf,
                                         unsigned int _MaxCharCount
            );

        #pragma warning(pop)
    


__pragma(pack(pop))























/* Compiler specific defines */

/* ------------------------------------------------------------------------*/
/* Microsoft C defines _MSC_VER */


/* We want COMPILER to expand to a string containing _MSC_VER's *value*.
 * This is horridly tricky, because the stringization operator only works
 * on macro arguments, and doesn't evaluate macros passed *as* arguments.
 * Attempts simpler than the following appear doomed to produce "_MSC_VER"
 * literally in the string.
 */


/* e.g., this produces, after compile-time string catenation,
 *      ("[MSC v.1200 32 bit (Intel)]")
 *
 * _Py_STRINGIZE(_MSC_VER) expands to
 * _Py_STRINGIZE1((_MSC_VER)) expands to
 * _Py_STRINGIZE2(_MSC_VER) but as this call is the result of token-pasting
 *      it's scanned again for macros and so further expands to (under MSVC 6)
 * _Py_STRINGIZE2(1200) which then expands to
 * "1200"
 */




/* MSVC defines _WINxx to differentiate the windows platform types

   Note that for compatibility reasons _WIN32 is defined on Win32
   *and* on Win64. For the same reasons, in Python, MS_WIN32 is
   defined on Win32 *and* Win64. Win32 only code must therefore be
   guarded as follows:
        #if defined(MS_WIN32) && !defined(MS_WIN64)
*/




/* set the COMPILER */













/* set the version macros for the windows headers */
/* Python 3.5+ requires Windows Vista or greater */



/* We only set these values when building Python - we don't want to force
   these values on extensions, as that will affect the prototypes and
   structures exposed in the Windows headers. Even when building Python, we
   allow a single source file to override this - they may need access to
   structures etc so it can optionally use new Windows features if it
   determines at runtime they are available.
*/












/* _W64 is not defined for VC6 or eVC4 */




/* Define like size_t, omitting the "unsigned" */

typedef __int64 ssize_t;





















typedef int pid_t;


//
// float.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Implementation-defined values commonly used by sophisticated numerical
// (floating point) programs.
//
#pragma once





__pragma(pack(push, 8))




    


        


            
        
    



// Define the floating point precision used.
//
// For x86, results are in double precision (unless /arch:sse2 is used, in which
// case results are in source precision.
//
// For x64 and ARM, results are in source precision.
//
// If the compiler is invoked with /fp:fast, the compiler is allowed to use the
// fastest precision and even mix within a single function, so precision is
// indeterminable.
//
// Note that manipulating the floating point behavior using the float_control/
// fenv_access/fp_contract #pragmas may alter the actual floating point evaluation
// method, which may in turn invalidate the value of FLT_EVAL_METHOD.



    






        
    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Constants
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+















































//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Flags
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+







// New Control Bit that specifies the ambiguity in control word.



// Abstract User Control Word Mask and bit definitions














// i386 specific definitions









// RISC specific definitions








// Invalid subconditions (_SW_INVALID also set)







// Floating point error signals and return codes














// On x86 with arch:SSE2, the OS returns these exceptions


















// Initial Control Word value






    





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// State Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Note that reading or writing the floating point control or status words is
// not supported in managed code.

 unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 
 unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


 void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


 errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


 unsigned int __cdecl _statusfp(void);


 void __cdecl _fpreset(void);















 unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );











// Global variable holding floating point error code
 
 int* __cdecl __fpecode(void);



 
 int __cdecl __fpe_flt_rounds(void);







//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// IEEE Recommended Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   double __cdecl _copysign(  double _Number,   double _Sign);
   double __cdecl _chgsign(  double _X);
   double __cdecl _scalb(  double _X,   long _Y);
   double __cdecl _logb(  double _X);
   double __cdecl _nextafter(  double _X,   double _Y);
   int    __cdecl _finite(  double _X);
   int    __cdecl _isnan(  double _X);
   int    __cdecl _fpclass(  double _X);


       float __cdecl _scalbf(  float _X,   long _Y);




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Nonstandard Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    
    
    

    
     void __cdecl fpreset(void);

    
    

    
    

    // For backwards compatibility with the old spelling
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    





__pragma(pack(pop))







/* VS 2010 and above already defines hypot as _hypot */




/* VS 2015 defines these names with a leading underscore */






/* Side by Side assemblies supported in VS 2005 and VS 2008 but not 2010*/




/* define some ANSI types that are not defined in earlier Win headers */

/* This file only exists in VC 6.0 or higher */

/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    basetsd.h

Abstract:

    Type definitions for the basic sized types.

Author:

Revision History:

--*/





#pragma warning(push)
#pragma warning(disable:4668) 



 
 typedef unsigned __int64 POINTER_64_INT;
 
  
 



































#pragma once






typedef signed char         INT8, *PINT8;
typedef signed short        INT16, *PINT16;
typedef signed int          INT32, *PINT32;
typedef signed __int64      INT64, *PINT64;
typedef unsigned char       UINT8, *PUINT8;
typedef unsigned short      UINT16, *PUINT16;
typedef unsigned int        UINT32, *PUINT32;
typedef unsigned __int64    UINT64, *PUINT64;

//
// The following types are guaranteed to be signed and 32 bits wide.
//

typedef signed int LONG32, *PLONG32;

//
// The following types are guaranteed to be unsigned and 32 bits wide.
//

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;









//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//









// old midl and C++ compiler


    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

    













//
// HALF_PTR is half the size of a pointer it intended for use with
// within structures which contain a pointer and two small fields.
// UHALF_PTR is the unsigned variation.
//





typedef __int64 SHANDLE_PTR;
typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;


__inline
unsigned long
HandleToULong(
    const void *h
    )
{
    return((unsigned long) (ULONG_PTR) h );
}

__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) (LONG_PTR) h );
}

__inline
void *
ULongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}


__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}


__inline
unsigned long
PtrToUlong(
    const void  *p
    )
{
    return((unsigned long) (ULONG_PTR) p );
}

__inline
unsigned int
PtrToUint(
    const void  *p
    )
{
    return((unsigned int) (UINT_PTR) p );
}

__inline
unsigned short
PtrToUshort(
    const void  *p
    )
{
    return((unsigned short) (unsigned long) (ULONG_PTR) p );
}

__inline
long
PtrToLong(
    const void  *p
    )
{
    return((long) (LONG_PTR) p );
}

__inline
int
PtrToInt(
    const void  *p
    )
{
    return((int) (INT_PTR) p );
}

__inline
short
PtrToShort(
    const void  *p
    )
{
    return((short) (long) (LONG_PTR) p );
}

__inline
void *
IntToPtr(
    const int i
    )
// Caution: IntToPtr() sign-extends the int value.
{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}

__inline
void *
LongToPtr(
    const long l
    )
// Caution: LongToPtr() sign-extends the long value.
{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
ULongToPtr(
    const unsigned long ul
    )
// Caution: ULongToPtr() zero-extends the unsigned long value.
{
    return( (void *)(ULONG_PTR)ul );
}






__inline
void *
Ptr32ToPtr(
    const void * __ptr32 p
    )
{
    return((void *) (ULONG_PTR) (unsigned long) p);
}

__inline
void *
Handle32ToHandle(
    const void * __ptr32 h
    )
{
    return((void *) (LONG_PTR) (long) h);
}

__inline
void * __ptr32
PtrToPtr32(
    const void *p
    )
{
    return((void * __ptr32) (unsigned long) (ULONG_PTR) p);
}



























































































//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//

typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;











































//
// Add Windows flavor DWORD_PTR types
//

typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

//
// The following types are guaranteed to be signed and 64 bits wide.
//

typedef __int64 LONG64, *PLONG64;


//
// The following types are guaranteed to be unsigned and 64 bits wide.
//

typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;

// begin_wudfpwdm

//
// Legacy thread affinity.
//

typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;

// end_wudfpwdm






#pragma warning(pop)








/* ------------------------------------------------------------------------*/
/* egcs/gnu-win32 defines __GNUC__ and _WIN32 */



















/* ------------------------------------------------------------------------*/
/* lcc-win32 defines __LCC__ */










/* ------------------------------------------------------------------------*/
/* End of compilers - finish up */



//
// stdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdio.h> header.
//
#pragma once





//
// corecrt_wstdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <stdio.h> and <wchar.h>.  It also defines several core I/O types, which are
// also shared by those two headers.
//
#pragma once



//
// corecrt_stdio_config.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Per-module <stdio.h> configuration.
//
#pragma once



__pragma(pack(push, 8))









    



    


        
    






// Predefine _CRT_STDIO_ISO_WIDE_SPECIFIERS to use ISO-conforming behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_LEGACY_WIDE_SPECIFIERS to use VC++ 2013 and earlier behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS when building code that does
// not use these format specifiers without a length modifier and thus can be
// used with either the legacy (default) or the conforming mode.  (This option
// is intended for use by static libraries).

    















    








// If we're compiling mixed managed code, make sure these inline functions are
// compiled as native to ensure that there is only one instance of each of the
// function-local static variables.





    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
























__pragma(pack(pop))


__pragma(pack(push, 8))


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Stream I/O Declarations Required by this Header
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;


 FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
     wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
     wint_t __cdecl _fgetwchar(void);

    
     wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
     wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
     wint_t __cdecl getwc(
          FILE* _Stream
        );

     
     wint_t __cdecl getwchar(void);


    
     
     wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
     int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
     wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    


    
     wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
     wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
     int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
     wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
     FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      
     FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
     errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    
     FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
     errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
     FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

     void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
         FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    

     int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
     __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
     errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    


       wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);




    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
     wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
     wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
     wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
     wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
     wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    







    // Variadic functions are not supported in managed code under /clr
    





    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
     int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwprintf_l(_Stream, _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vfwprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }
    

    

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        }
    

    

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfwprintf_l(_Stream, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vfwprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfwprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
     int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwscanf_l(_Stream, _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vfwscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }
    

    

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        }
    

    

     
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfwscanf_l(_Stream, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vfwscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

     
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
        



    



     
    
     int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
     int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
     int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
     int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

    #pragma warning(push)
    #pragma warning(disable: 4793)

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    


    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
    }
    

     __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...);  __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);


    #pragma warning(pop)

     
     
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        #pragma warning(pop)
    }
    

    


     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    


    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }
    

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    


    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, ((void *)0), _ArgList);
    }
    

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    


    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }
    

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    


        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        }
    

    

    


     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    


    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }
    

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vscwprintf_l(_Format, ((void *)0), _ArgList);
    }
    

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vscwprintf_p_l(_Format, ((void *)0), _ArgList);
    }
    

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = __vswprintf_l(_Buffer, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    #pragma warning(push)
    // Warning 4793: The compiler cannot compile function into managed code, even though the /clr compiler option is specified.
    // Warning 4996: 'function': was declared deprecated
    #pragma warning(disable:4793 4996)

     __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...);  __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);


     __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...);  __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);


    #pragma warning(pop)

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    


     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    


     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vscwprintf_l(_Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vscwprintf_p_l(_Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    


    
        #pragma warning(push)
        #pragma warning(disable: 4141 4412 4793 4996 6054)

        























































        #pragma warning(pop)
    

    







    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     
     int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    


    {
        return _vswscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
    }
    

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vswscanf_s_l(_Buffer, _Format, ((void *)0), _ArgList);
        }
    

    

    


     
     
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    


    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    


    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    

     
     
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
      
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vswscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vswscanf_s_l(_Buffer, _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

     
     
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    






__pragma(pack(pop))


__pragma(pack(push, 8))

/* Buffered I/O macros */





/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */




/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */












    




/* Seek method constants */











    
    



typedef __int64 fpos_t;





    
     errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    

        
         errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
         errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode
            );

        
         
         size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
         errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
         char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
         errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
         errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    

     void __cdecl clearerr(
          FILE* _Stream
        );

     
    
     int __cdecl fclose(
          FILE* _Stream
        );

    
     int __cdecl _fcloseall(void);

     
     FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
     int __cdecl feof(
          FILE* _Stream
        );

     
     int __cdecl ferror(
          FILE* _Stream
        );

    
     int __cdecl fflush(
          FILE* _Stream
        );

     
    
     int __cdecl fgetc(
          FILE* _Stream
        );

    
     int __cdecl _fgetchar(void);

     
    
     int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
     char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
     int __cdecl _fileno(
          FILE* _Stream
        );

    
     int __cdecl _flushall(void);

      
     FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
     int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
     int __cdecl _fputchar(
          int _Character
        );

     
    
     int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
     size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      
     FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
     FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
     int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
     int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
     int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
     long __cdecl ftell(
          FILE* _Stream
        );

     
     
     __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
     size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
     int __cdecl getc(
          FILE* _Stream
        );

     
     int __cdecl getchar(void);

     
     int __cdecl _getmaxstdio(void);

    


     
     int __cdecl _getw(
          FILE* _Stream
        );

     void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
         int __cdecl _pclose(
              FILE* _Stream
            );

         
         FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    

     
    
     int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
     int __cdecl putchar(
          int _Character
        );

    
     int __cdecl puts(
          char const* _Buffer
        );

     
    
     int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

     int __cdecl remove(
          char const* _FileName
        );

     
     int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

     int __cdecl _unlink(
          char const* _FileName
        );

    

        
         int __cdecl unlink(
              char const* _FileName
            );

    

     void __cdecl rewind(
          FILE* _Stream
        );

    
     int __cdecl _rmtmp(void);

    
     void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
     int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
     int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    




     
     __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    



      
     FILE* __cdecl tmpfile(void);

    


#pragma warning(push)
#pragma warning(disable: 28726) 
   char* __cdecl tmpnam(  char *_Buffer);

#pragma warning(pop)

     
    
     int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     void __cdecl _lock_file(
          FILE* _Stream
        );

     void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
     int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
     int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
     int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
     int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
     size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
     size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
     int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
     int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
     __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
     size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
     int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
     int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
     int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    


















     int* __cdecl __p__commode(void);

    


        
    



    // Variadic functions are not supported in managed code under /clr
    



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    


    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfprintf_l(_Stream, _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    


    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vfprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }
    

    

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    


    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        }
    

    

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfprintf_l(_Stream, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     int __cdecl _set_printf_count_output(
          int _Value
        );

     int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vfprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfscanf_l(_Stream, _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vfscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }
    

    

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        }
    

    

     
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfscanf_l(_Stream, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vfscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

     
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     
     int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        #pragma warning(pop)
    }
    

    










     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, ((void *)0), _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
     
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    

     
     
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, ((void *)0), _ArgList);
        #pragma warning(pop)
    }
    

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    


        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        }
    

        


    

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    


    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }
    

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    


    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
    }
    

    


    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    


        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
        }
    

        


    

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vscprintf_l(_Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vscprintf_p_l(_Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    


    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }
    

     
     
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, ((void *)0), _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    #pragma warning(push)
    #pragma warning(disable: 4996)
    #pragma warning(disable: 28719) 
    #pragma warning(disable: 28726) 
       int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...);    int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);

    #pragma warning(pop)

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    


     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    










     
    
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
    #pragma warning(suppress:28719)    
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
    #pragma warning(suppress:28719)    
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

        int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...);     int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);


     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    


    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vscprintf_l(_Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vsscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
    }
    

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

    

        #pragma warning(push)
        #pragma warning(disable:6530)

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vsscanf_s_l(_Buffer, _Format, ((void *)0), _ArgList);
        }
    

        


        #pragma warning(pop)

    

     
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vsscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__va_start(&_ArgList, _Format)));

            #pragma warning(push)
            #pragma warning(disable: 4996) 
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
            #pragma warning(pop)

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    #pragma warning(push)
    #pragma warning(disable:6530)

     
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, ((void *)0), _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, ((void *)0), _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    #pragma warning(pop)

    





    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Non-ANSI Names for Compatibility
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    

        

        




        
         char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        



           int   __cdecl fcloseall(void);
                   FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
            int   __cdecl fgetchar(void);
                   int   __cdecl fileno(  FILE* _Stream);
            int   __cdecl flushall(void);
            int   __cdecl fputchar(  int _Ch);
                     int   __cdecl getw(  FILE* _Stream);
                int   __cdecl putw(  int _Ch,   FILE* _Stream);
                    int   __cdecl rmtmp(void);

    




__pragma(pack(pop))




/* 64 bit ints are usually spelt __int64 unless compiler has overridden */







/* For Windows the Python core is in a DLL by default.  Test
Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */





/*  All windows compilers that use this header support __declspec */


/* For an MSVC DLL, we can nominate the .lib files used by extensions */


                /* not building the core - must be an ext */

                        /* So MSVC users need not specify the .lib
                        file in their Makefile (other compilers are
                        generally taken care of by distutils.) */





#pragma comment(lib,"python37.lib")






/* maintain "win32" sys.platform for backward compatibility of Python code,
   the Win64 API should be close enough to the Win32 API to make this
   preferable */







/* configure.ac defines HAVE_LARGEFILE_SUPPORT iff HAVE_LONG_LONG,
   sizeof(off_t) > sizeof(long), and sizeof(PY_LONG_LONG) >= sizeof(off_t).
   On Win64 the second condition is not true, but if fpos_t replaces off_t
   then this is true. The uses of HAVE_LARGEFILE_SUPPORT imply that Win64
   should define this. */































/* VC 7.1 has them and VC 6.0 does not.  VC 6.0 has a version number of 1200.
   Microsoft eMbedded Visual C++ 4.0 has a version number of 1201 and doesn't
   define these.
   If some compiler does not provide them, modify the #if appropriately. */












/* define signed and unsigned exact-width 32-bit and 64-bit types, used in the
   implementation of Python integers. */





/* Fairly standard from here! */

/* Define to 1 if you have the `copysign' function. */


/* Define to 1 if you have the `round' function. */




/* Define to 1 if you have the `isinf' macro. */


/* Define to 1 if you have the `isnan' function. */


/* Define if on AIX 3.
   System headers sometimes define this.
   We just want to avoid a redefinition error message.  */

/* #undef _ALL_SOURCE */


/* Define to empty if the keyword does not work.  */
/* #define const  */

/* Define to 1 if you have the <conio.h> header file. */


/* Define to 1 if you have the <direct.h> header file. */


/* Define if you have dirent.h.  */
/* #define DIRENT 1 */

/* Define to the type of elements in the array set by `getgroups'.
   Usually this is either `int' or `gid_t'.  */
/* #undef GETGROUPS_T */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef gid_t */

/* Define if your struct tm has tm_zone.  */
/* #undef HAVE_TM_ZONE */

/* Define if you don't have tm_zone but do have the external array
   tzname.  */


/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef mode_t */

/* Define if you don't have dirent.h, but have ndir.h.  */
/* #undef NDIR */

/* Define to `long' if <sys/types.h> doesn't define.  */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef pid_t */

/* Define if the system does not provide POSIX.1 features except
   with this defined.  */
/* #undef _POSIX_1_SOURCE */

/* Define if you need to in order for stat and other things to work.  */
/* #undef _POSIX_SOURCE */

/* Define as the return type of signal handlers (int or void).  */


/* Define to `unsigned' if <sys/types.h> doesn't define.  */
/* #undef size_t */

/* Define if you have the ANSI C header files.  */


/* Define if you don't have dirent.h, but have sys/dir.h.  */
/* #undef SYSDIR */

/* Define if you don't have dirent.h, but have sys/ndir.h.  */
/* #undef SYSNDIR */

/* Define if you can safely include both <sys/time.h> and <time.h>.  */
/* #undef TIME_WITH_SYS_TIME */

/* Define if your <sys/time.h> declares struct tm.  */
/* #define TM_IN_SYS_TIME 1 */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef uid_t */

/* Define if the closedir function returns void instead of int.  */
/* #undef VOID_CLOSEDIR */

/* Define if getpgrp() must be called as getpgrp(0)
   and (consequently) setpgrp() as setpgrp(0, 0). */
/* #undef GETPGRP_HAVE_ARGS */

/* Define this if your time.h defines altzone */
/* #define HAVE_ALTZONE */

/* Define if you have the putenv function.  */


/* Define if your compiler supports function prototypes */


/* Define if  you can safely include both <sys/select.h> and <sys/time.h>
   (which you can't on SCO ODT 3.0). */
/* #undef SYS_SELECT_WITH_SYS_TIME */

/* Define if you want documentation strings in extension modules */


/* Define if you want to compile in rudimentary thread support */
/* #undef WITH_THREAD */

/* Define if you want to use the GNU readline library */
/* #define WITH_READLINE 1 */

/* Use Python's own small-block memory-allocator. */


/* Define if you have clock.  */
/* #define HAVE_CLOCK */

/* Define when any dynamic module loading is enabled */


/* Define if you have ftime.  */


/* Define if you have getpeername.  */


/* Define if you have getpgrp.  */
/* #undef HAVE_GETPGRP */

/* Define if you have getpid.  */


/* Define if you have gettimeofday.  */
/* #undef HAVE_GETTIMEOFDAY */

/* Define if you have getwd.  */
/* #undef HAVE_GETWD */

/* Define if you have lstat.  */
/* #undef HAVE_LSTAT */

/* Define if you have the mktime function.  */


/* Define if you have nice.  */
/* #undef HAVE_NICE */

/* Define if you have readlink.  */
/* #undef HAVE_READLINK */

/* Define if you have setpgid.  */
/* #undef HAVE_SETPGID */

/* Define if you have setpgrp.  */
/* #undef HAVE_SETPGRP */

/* Define if you have setsid.  */
/* #undef HAVE_SETSID */

/* Define if you have setvbuf.  */


/* Define if you have siginterrupt.  */
/* #undef HAVE_SIGINTERRUPT */

/* Define if you have symlink.  */
/* #undef HAVE_SYMLINK */

/* Define if you have tcgetpgrp.  */
/* #undef HAVE_TCGETPGRP */

/* Define if you have tcsetpgrp.  */
/* #undef HAVE_TCSETPGRP */

/* Define if you have times.  */
/* #undef HAVE_TIMES */

/* Define if you have uname.  */
/* #undef HAVE_UNAME */

/* Define if you have waitpid.  */
/* #undef HAVE_WAITPID */

/* Define to 1 if you have the `wcsftime' function. */




/* Define to 1 if you have the `wcscoll' function. */


/* Define to 1 if you have the `wcsxfrm' function. */


/* Define if the zlib library has inflateCopy */


/* Define if you have the <dlfcn.h> header file.  */
/* #undef HAVE_DLFCN_H */

/* Define to 1 if you have the <errno.h> header file. */


/* Define if you have the <fcntl.h> header file.  */


/* Define to 1 if you have the <process.h> header file. */


/* Define to 1 if you have the <signal.h> header file. */


/* Define if you have the <stdarg.h> prototypes.  */


/* Define if you have the <stddef.h> header file.  */


/* Define if you have the <sys/audioio.h> header file.  */
/* #undef HAVE_SYS_AUDIOIO_H */

/* Define if you have the <sys/param.h> header file.  */
/* #define HAVE_SYS_PARAM_H 1 */

/* Define if you have the <sys/select.h> header file.  */
/* #define HAVE_SYS_SELECT_H 1 */

/* Define to 1 if you have the <sys/stat.h> header file.  */


/* Define if you have the <sys/time.h> header file.  */
/* #define HAVE_SYS_TIME_H 1 */

/* Define if you have the <sys/times.h> header file.  */
/* #define HAVE_SYS_TIMES_H 1 */

/* Define to 1 if you have the <sys/types.h> header file.  */


/* Define if you have the <sys/un.h> header file.  */
/* #define HAVE_SYS_UN_H 1 */

/* Define if you have the <sys/utime.h> header file.  */
/* #define HAVE_SYS_UTIME_H 1 */

/* Define if you have the <sys/utsname.h> header file.  */
/* #define HAVE_SYS_UTSNAME_H 1 */

/* Define if you have the <unistd.h> header file.  */
/* #define HAVE_UNISTD_H 1 */

/* Define if you have the <utime.h> header file.  */
/* #define HAVE_UTIME_H 1 */

/* Define if the compiler provides a wchar.h header file. */


/* The size of `wchar_t', as computed by sizeof. */


/* The size of `_Bool', as computed by sizeof. */


/* The size of `pid_t', as computed by sizeof. */


/* Define if you have the dl library (-ldl).  */
/* #undef HAVE_LIBDL */

/* Define if you have the mpc library (-lmpc).  */
/* #undef HAVE_LIBMPC */

/* Define if you have the nsl library (-lnsl).  */


/* Define if you have the seq library (-lseq).  */
/* #undef HAVE_LIBSEQ */

/* Define if you have the socket library (-lsocket).  */


/* Define if you have the sun library (-lsun).  */
/* #undef HAVE_LIBSUN */

/* Define if you have the termcap library (-ltermcap).  */
/* #undef HAVE_LIBTERMCAP */

/* Define if you have the termlib library (-ltermlib).  */
/* #undef HAVE_LIBTERMLIB */

/* Define if you have the thread library (-lthread).  */
/* #undef HAVE_LIBTHREAD */

/* WinSock does not use a bitmask in select, and uses
   socket handles greater than FD_SETSIZE */


/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the
   least significant byte first */


/* Define to 1 if you have the `erf' function. */


/* Define to 1 if you have the `erfc' function. */


/* Define if you have the 'inet_pton' function. */


/* framework name */


/* Define if libssl has X509_VERIFY_PARAM_set1_host and related function */







     /*
      * This file moves some of the autoconf magic to compile-time
      * when building on MacOSX. This is needed for building 4-way
      * universal binaries and for 64-bit universal binaries because
      * the values redefined below aren't configure-time constant but
      * only compile-time constant in these scenarios.
      */
































































































//
// limits.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <limits.h> header.
//
#pragma once




__pragma(pack(push, 8))







    
    




































    
        
    





    
        
    


__pragma(pack(pop))




















//
// string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <string.h> header.
//
#pragma once





//
// corecrt_memory.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The buffer (memory) manipulation library.  These declarations are split out
// so that they may be included by both <string.h> and <memory.h>.  <string.h>
// does not include <memory.h> to avoid introducing conflicts with other user
// headers named <memory.h>.
//
#pragma once



//
// corecrt_memcpy_s.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Inline definitions of memcpy_s and memmove_s
//
#pragma once



//
// errno.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// System error numbers for use with errno and errno_t.
//
#pragma once





__pragma(pack(push, 8))




     int* __cdecl _errno(void);
    

     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);

     unsigned long* __cdecl __doserrno(void);
    

     errno_t __cdecl _set_doserrno(  unsigned long _Value);
     errno_t __cdecl _get_doserrno(  unsigned long * _Value);




// Error codes




































// Error codes used in the Secure CRT functions

    
    
    
    
    


// Support EDEADLOCK for compatibility with older Microsoft C versions


// POSIX Supplement

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    




__pragma(pack(pop))



//
// vcruntime_string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <string.h> functionality that is implemented in the VCRuntime.
//
#pragma once





__pragma(pack(push, 8))



  
 void * __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

  
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 


void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 


void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

  
 char * __cdecl strchr(
      char const* _Str,
        int         _Val
    );

  
 char * __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

    
 char * __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

  

 wchar_t * __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

  
 wchar_t * __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

    

 wchar_t * __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



__pragma(pack(pop))




__pragma(pack(push, 8))


    















     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == ((void *)0) || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            // Unreachable, but required to suppress /analyze warnings:
            return 22;
        }
#pragma warning(suppress:4996) 
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

#pragma warning(suppress:4996) 
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }





__pragma(pack(pop))





__pragma(pack(push, 8))



 
 int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
 int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    














    




















    
     void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      
     int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );






















__pragma(pack(pop))




//
// corecrt_wstring.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) string functionality, shared
// by <string.h> and <wchar.h>.
//
#pragma once






__pragma(pack(push, 8))



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Secure Alternatives
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    
     errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
     errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
     errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
     errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
     wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide-Character <string.h> Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+





 
 __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );












#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
      wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);

#pragma warning(pop)


 
 int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );




#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
  wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);

#pragma warning(pop)

 
 size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
 size_t __cdecl wcslen(
      wchar_t const* _String
    );

 




 size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    

    

    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }






  wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);


 
 int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );




  wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);


 
 wchar_t * __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
 size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  
 wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    


        



    

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 
    #pragma warning(disable: 28719 28726 28727) 
      
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    



    










    #pragma warning(pop)





 
  
 wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


 errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );




 
 
  
 wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

  errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );




   int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

   int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

   int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

   int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

  errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );




  wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);


 wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

  errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );




  wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);


  errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );




  wchar_t* __cdecl _wcslwr( wchar_t *_String);



 errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );




  wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);



 errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );




  wchar_t* __cdecl _wcsupr( wchar_t *_String);



 errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );




  wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);


 

 size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

 size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
 int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
 int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
 int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
 int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
 int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
 int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
 int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
 int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline C++ Overloads
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


































//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-Standard Names
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    




      
     wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    



    // Declarations of functions defined in oldnames.lib:
    

      
     int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      
     int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    
     
     wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    
     
     wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    
     
     wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    
     
     wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    
     
     wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      
     int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );





__pragma(pack(pop))







__pragma(pack(push, 8))







    
     errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
     errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
     errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
     errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
     errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
     char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );



 void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );






#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
      char* __cdecl strcat( char *_Destination,  char const* _Source);

#pragma warning(pop)



 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
 int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );




#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
  char* __cdecl strcpy( char *_Destination,  char const* _Source);

#pragma warning(pop)

 
 size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );






 
 __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );





 
 
  
 char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


 errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );




 
  
 char* __cdecl strerror(
      int _ErrorMessage
    );




 
 int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
 int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


 errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );




  char* __cdecl _strlwr( char *_String);



 errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );




  char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);





  char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);


 
 int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
 int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
 int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );




  char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);


 




 size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    

    

    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }




 errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );




  char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);


 
 char * __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

 char* __cdecl _strrev(
      char* _Str
    );


 errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );




  char* __cdecl _strset( char *_Destination,  int _Value);


 
 size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  
 char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


 errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );




  char* __cdecl _strupr( char *_String);



 errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );




  char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);


 

 size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

 size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




































    
    
      
     char* __cdecl strdup(
          char const* _String
        );
    

    // Declarations of functions defined in oldnames.lib:
      
     int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      
     int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    
     char* __cdecl strlwr(
          char* _String
        );

      
     int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    
     char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    
     char* __cdecl strrev(
          char* _String
        );

    
    char* __cdecl strset(
          char* _String,
               int   _Value);

    
     char* __cdecl strupr(
          char* _String
        );





__pragma(pack(pop))








//
// stdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdlib.h> header.
//
#pragma once





//
// corecrt_malloc.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The memory allocation library.  These pieces of the allocation library are
// shared by both <stdlib.h> and <malloc.h>.
//
#pragma once



__pragma(pack(push, 8))







































     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
       size_t _Count,
       size_t _Size
    );

 
 int __cdecl _callnewh(
      size_t _Size
    );

     
 __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
       size_t _Size
    );


void __cdecl _free_base(
        void* _Block
    );

 
void __cdecl free(
        void* _Block
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
 __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
       size_t _Size
    );

 

size_t __cdecl _msize_base(
      void* _Block
    );

 
 
size_t __cdecl _msize(
      void* _Block
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
              size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size
    );


void __cdecl _aligned_free(
        void* _Block
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
       size_t _Size,
                         size_t _Alignment
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
       size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 

size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment
    );






















__pragma(pack(pop))


//
// corecrt_search.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations of functions for sorting and searching.  These declarations are
// split out so that they may be included by both <stdlib.h> and <search.h>.
// <stdlib.h> does not include <search.h> to avoid introducing conflicts with
// other user headers named <search.h>.
//
#pragma once



//
// stddef.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C <stddef.h> Standard Library header.
//
#pragma once





__pragma(pack(push, 8))
















     int* __cdecl _errno(void);
    

     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);






    


        
    




 extern unsigned long  __cdecl __threadid(void);

 extern uintptr_t __cdecl __threadhandle(void);



__pragma(pack(pop))



__pragma(pack(push, 8))


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
     void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

     void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );





 
 void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
 void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
 void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
 void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );

 
 void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );



// Managed search routines






















































































      
     void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      
     void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );





__pragma(pack(pop))


//
// corecrt_wstdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) C Standard Library functions
// that are declared by both <stdlib.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8))



// Maximum number of elements, including null terminator (and negative sign
// where appropriate), needed for integer-to-string conversions for several
// bases and integer types.




























     
    
     errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    


      wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);


     
    
     errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    


      wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);


    
     errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    


      wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);


     
     double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
     double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
     long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
     long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
     float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
     float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
     double __cdecl _wtof(
          wchar_t const* _String
        );

     
     double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     int __cdecl _wtoi(
          wchar_t const* _String
        );

     
     int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     long __cdecl _wtol(
          wchar_t const* _String
        );

     
     long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
     long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
     errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    
     wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
     errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    
     wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
     __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
     __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
     __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
     errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    


#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
  void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);

#pragma warning(pop)

     void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    
     void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

     errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    


        
        

        
         errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          
         wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
         errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        


         
         int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
         errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

         errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        


          void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);


         int __cdecl _wsystem(
              wchar_t const* _Command
            );





__pragma(pack(pop))



__pragma(pack(push, 8))




    




// Minimum and maximum macros





 void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Exit and Abort
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Argument values for exit()




     __declspec(noreturn) void __cdecl exit(  int _Code);
     __declspec(noreturn) void __cdecl _exit(  int _Code);
     __declspec(noreturn) void __cdecl _Exit(  int _Code);
     __declspec(noreturn) void __cdecl quick_exit(  int _Code);
     __declspec(noreturn) void __cdecl abort(void);


// Argument values for _set_abort_behavior().



 unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    





    // Non-ANSI name for compatibility
    


























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);


int __cdecl at_quick_exit(void (__cdecl*)(void));



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Global State (errno, global handlers, etc.)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    // a purecall handler procedure. Never returns normally
    typedef void (__cdecl* _purecall_handler)(void);

    // Invalid parameter handler function pointer type
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    // Establishes a purecall handler
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    // Establishes an invalid parameter handler
     _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

     _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);

















// Argument values for _set_error_mode().





  int __cdecl _set_error_mode(  int _Mode);




     int* __cdecl _errno(void);
    

     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);

     unsigned long* __cdecl __doserrno(void);
    

     errno_t __cdecl _set_doserrno(  unsigned long _Value);
     errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    // This is non-const for backwards compatibility; do not modify it.
      char** __cdecl __sys_errlist(void);
    

      int * __cdecl __sys_nerr(void);
    

     void __cdecl perror(  char const* _ErrMsg);




// These point to the executable module name.
  char**    __cdecl __p__pgmptr (void);
  wchar_t** __cdecl __p__wpgmptr(void);
  int*      __cdecl __p__fmode  (void);








    
    
    


 
 errno_t __cdecl _get_pgmptr (  char**    _Value);

 
 errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

 errno_t __cdecl _set_fmode  (               int       _Mode );

 errno_t __cdecl _get_fmode  (              int*      _PMode);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Math
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

   div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
   ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
   lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);

// These functions have declspecs in their declarations in the Windows headers,
// which cause PREfast to fire 6540.
#pragma warning (push)
#pragma warning (disable:6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning (pop)



// Maximum value that can be returned by the rand function:


 void __cdecl srand(  unsigned int _Seed);

   int __cdecl rand(void);



































// Structs used to fool the compiler into not generating floating point
// instructions when copying and pushing [long] double values




    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    













typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;

// push and pop long, which is #defined as __int64 by a spec2k test



typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow String to Number Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                      double    __cdecl atof   (  char const* _String);
    int       __cdecl atoi   (  char const* _String);
                      long      __cdecl atol   (  char const* _String);
                      long long __cdecl atoll  (  char const* _String);
                      __int64   __cdecl _atoi64(  char const* _String);

   double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
   int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
   long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
   long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
   __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

   int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
   int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
   int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
 int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
 int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
 int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
 float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
 float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
 double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
 long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Number to Narrow String Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 

 errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );




#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
  char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);

#pragma warning(pop)

 

 errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );




  char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);


 

 errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );




#pragma warning(push)
#pragma warning(disable: 28726) 
  char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);

#pragma warning(pop)

 

 errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 

 char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

 errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );


 char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );



// _CVTBUFSIZE is the maximum size for the per-thread conversion buffer.  It
// should be at least as long as the number of digits in the largest double
// precision value (?.?e308 in IEEE arithmetic).  We will use the same size
// buffer as is used in the printf support routines.
//
// (This value actually allows 40 additional decimal places; even though there
// are only 16 digits of accuracy in a double precision IEEE number, the user may
// ask for more to effect zero padding.)


 

 errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );




  
 char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

 errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );




 
  
 char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
 errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );





 char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Multibyte String Operations and Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Maximum number of bytes in multi-byte character in the current locale
// (also defined in ctype.h).

    


        
    

    


        
    

     
     int __cdecl ___mb_cur_max_func(void);

     
     int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);




 
 int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
 int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
 size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
 size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
 size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
 size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
 int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
 int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


 errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );




  size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);



 errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );




  size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);






 int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );


 int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
     errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );




 errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


 errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );




  size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);



 errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );




  size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Path Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Sizes for buffers used by the _makepath() and _splitpath() functions.
// note that the sizes include space for 0-terminator










 
 
 __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




 errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );




#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
  void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);

#pragma warning(pop)


 void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


 errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );






 
 errno_t __cdecl getenv_s(
                                 size_t*     _RequiredCount,
      char*       _Buffer,
                                  rsize_t     _BufferCount,
                                char const* _VarName
    );






 int*       __cdecl __p___argc (void);
 char***    __cdecl __p___argv (void);
 wchar_t*** __cdecl __p___wargv(void);






    
    
    


 char***    __cdecl __p__environ (void);
 wchar_t*** __cdecl __p__wenviron(void);


    








    
    




// Sizes for buffers used by the getenv/putenv family of functions.





      
     char* __cdecl getenv(
          char const* _VarName
        );

    


    




    
     errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    



     int __cdecl system(
          char const* _Command
        );

    // The functions below have declspecs in their declarations in the Windows
    // headers, causing PREfast to fire 6540 here
    #pragma warning (push)
    #pragma warning (disable:6540)

     
     int __cdecl _putenv(
          char const* _EnvString
        );

    
     errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning (pop)

     errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    


      void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);


    // The Win32 API SetErrorMode, Beep and Sleep should be used instead.
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
     void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
     void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
     void __cdecl _sleep(
          unsigned long _Duration
        );




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-ANSI Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    
        
        
    

    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

       
     char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

       
     char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

     
     char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

     
     char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

     
     char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    
     void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

     
     char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

      
     int __cdecl putenv(
          char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);





__pragma(pack(pop))









/* For size_t? */




/* CAUTION:  Build setups should ensure that NDEBUG is defined on the
 * compiler command line when building Python in release mode; else
 * assert() calls won't be removed.
 */

//
// assert.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Defines the assert macro and related functionality.
//






__pragma(pack(push, 8))











     void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    








__pragma(pack(pop))









//
// inttypes.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Various integer format specifier macros for use with the stdio library, and
// various integer conversion and manipulation functions.
//
#pragma once





//
// stdint.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdint.h> header.
//
#pragma once





typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;

// These macros must exactly match those in the Windows SDK's intsafe.h.








































    
    
    










































__pragma(pack(push, 8))



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef struct
{
    intmax_t quot;
    intmax_t rem;
} _Lldiv_t;

typedef _Lldiv_t imaxdiv_t;



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
 intmax_t __cdecl imaxabs(
      intmax_t _Number
    );

 
 imaxdiv_t __cdecl imaxdiv(
      intmax_t _Numerator,
      intmax_t _Denominator
    );

 intmax_t __cdecl strtoimax(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 intmax_t __cdecl _strtoimax_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 uintmax_t __cdecl strtoumax(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 uintmax_t __cdecl _strtoumax_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 intmax_t __cdecl wcstoimax(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 intmax_t __cdecl _wcstoimax_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 uintmax_t __cdecl wcstoumax(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 uintmax_t __cdecl _wcstoumax_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Output Format Specifier Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+














    


















    


















    


















    


















    


















    






//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Input Format Specifier Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+














    


















    


















    


















    


















    






__pragma(pack(pop))

/*
 * Copyright (c) 1992-2010 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.30:0009 */




/**************************************************************************
Symbols and macros to supply platform-independent interfaces to basic
C language & library operations whose spellings vary across platforms.

Please try to make documentation here as clear as possible:  by definition,
the stuff here is trying to illuminate C's darkest corners.

Config #defines referenced here:

SIGNED_RIGHT_SHIFT_ZERO_FILLS
Meaning:  To be defined iff i>>j does not extend the sign bit when i is a
          signed integral type and i < 0.
Used in:  Py_ARITHMETIC_RIGHT_SHIFT

Py_DEBUG
Meaning:  Extra checks compiled in for debug mode.
Used in:  Py_SAFE_DOWNCAST

**************************************************************************/

/* typedefs for some C9X-defined synonyms for integral types.
 *
 * The names in Python are exactly the same as the C9X names, except with a
 * Py_ prefix.  Until C9X is universally implemented, this is the only way
 * to ensure that Python gets reliable names that don't conflict with names
 * in non-Python code that are playing their own tricks to define the C9X
 * names.
 *
 * NOTE: don't go nuts here!  Python has no use for *most* of the C9X
 * integral synonyms.  Only define the ones we actually need.
 */

/* long long is required. Ensure HAVE_LONG_LONG is defined for compatibility. */














/* Signed variants of the above */



/* If PYLONG_BITS_IN_DIGIT is not defined then we'll use 30-bit digits if all
   the necessary integer types are available, and we're on a 64-bit platform
   (as determined by SIZEOF_VOID_P); otherwise we use 15-bit digits. */









/* uintptr_t is the C9X name for an unsigned integral type such that a
 * legitimate void* can be cast to uintptr_t and then back to void* again
 * without loss of information.  Similarly for intptr_t, wrt a signed
 * integral type.
 */
typedef uintptr_t       Py_uintptr_t;
typedef intptr_t        Py_intptr_t;

/* Py_ssize_t is a signed integral type such that sizeof(Py_ssize_t) ==
 * sizeof(size_t).  C99 doesn't define such a thing directly (size_t is an
 * unsigned integral type).  See PEP 353 for details.
 */

typedef ssize_t         Py_ssize_t;






/* Py_hash_t is the same size as a pointer. */

typedef Py_ssize_t Py_hash_t;
/* Py_uhash_t is the unsigned equivalent needed to calculate numeric hash. */

typedef size_t Py_uhash_t;

/* Only used for compatibility with code that may not be PY_SSIZE_T_CLEAN. */



typedef int Py_ssize_clean_t;


/* Largest possible value of size_t. */


/* Largest positive value of type Py_ssize_t. */

/* Smallest negative value of type Py_ssize_t. */


/* PY_FORMAT_SIZE_T is a platform-specific modifier for use in a printf
 * format to convert an argument with the width of a size_t or Py_ssize_t.
 * C99 introduced "z" for this purpose, but not all platforms support that;
 * e.g., MS compilers use "I" instead.
 *
 * These "high level" Python format functions interpret "z" correctly on
 * all platforms (Python interprets the format string itself, and does whatever
 * the platform C requires to convert a size_t/Py_ssize_t argument):
 *
 *     PyBytes_FromFormat
 *     PyErr_Format
 *     PyBytes_FromFormatV
 *     PyUnicode_FromFormatV
 *
 * Lower-level uses require that you interpolate the correct format modifier
 * yourself (e.g., calling printf, fprintf, sprintf, PyOS_snprintf); for
 * example,
 *
 *     Py_ssize_t index;
 *     fprintf(stderr, "index %" PY_FORMAT_SIZE_T "d sucks\n", index);
 *
 * That will expand to %ld, or %Id, or to something else correct for a
 * Py_ssize_t on the platform.
 */












/* Py_LOCAL can be used instead of static to get the fastest possible calling
 * convention for functions that are local to a given module.
 *
 * Py_LOCAL_INLINE does the same thing, and also explicitly requests inlining,
 * for platforms that support that.
 *
 * If PY_LOCAL_AGGRESSIVE is defined before python.h is included, more
 * "aggressive" inlining/optimization is enabled for the entire module.  This
 * may lead to code bloat, and may slow things down for those reasons.  It may
 * also lead to errors, if the code relies on pointer aliasing.  Use with
 * care.
 *
 * NOTE: You can only use this for functions that are entirely local to a
 * module; functions that are exported via method tables, callbacks, etc,
 * should keep using static.
 */






/* ignore warnings if the compiler decides not to inline a function */
#pragma warning(disable: 4710)
/* fastest possible local call under MSVC */







/* Py_MEMCPY is kept for backwards compatibility,
 * see https://bugs.python.org/issue28126 */









//
// math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <math.h> header.  This header consists of two parts:
// <corecrt_math.h> contains the math library; <corecrt_math_defines.h> contains
// the nonstandard but useful constant definitions.  The headers are divided in
// this way for modularity (to support the C++ modules feature).
//

//
// corecrt_math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The majority of the C Standard Library <math.h> functionality.
//
#pragma once





__pragma(pack(push, 8))

#pragma warning(push)
#pragma warning(disable:4738) 
#pragma warning(disable:4820) 




    // Definition of the _exception struct, which is passed to the matherr function
    // when a floating point exception is detected:
    struct _exception
    {
        int    type;   // exception type - see below
        char*  name;   // name of function where error occurred
        double arg1;   // first argument to function
        double arg2;   // second argument (if any) to function
        double retval; // value to be returned by function
    };

    // Definition of the _complex struct to be used by those who use the complex
    // functions and want type checking.
    
        

        struct _complex
        {
            double x, y; // real and imaginary parts
        };

        
            // Non-ANSI name for compatibility
            
        
    




// On x86, when not using /arch:SSE2 or greater, floating point operations
// are performed using the x87 instruction set and FLT_EVAL_METHOD is 2.
// (When /fp:fast is used, floating point operations may be consistent, so
// we use the default types.)




    typedef float  float_t;
    typedef double double_t;




// Constant definitions for the exception type passed in the _exception struct







// Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
// for a value returned in case of error by a number of the floating point
// math routines.

    
        extern double const _HUGE;
    





    



























// Values for use as arguments to the _fperrraise function





























// IEEE 754 double properties





// IEEE 754 float properties





// IEEE 754 long double properties













void __cdecl _fperrraise(  int _Except);

   short __cdecl _dclass(  double _X);
   short __cdecl _ldclass(  long double _X);
   short __cdecl _fdclass(  float _X);

   int __cdecl _dsign(  double _X);
   int __cdecl _ldsign(  long double _X);
   int __cdecl _fdsign(  float _X);

   int __cdecl _dpcomp(  double _X,   double _Y);
   int __cdecl _ldpcomp(  long double _X,   long double _Y);
   int __cdecl _fdpcomp(  float _X,   float _Y);

   short __cdecl _dtest(  double* _Px);
   short __cdecl _ldtest(  long double* _Px);
   short __cdecl _fdtest(  float* _Px);

 short __cdecl _d_int(  double* _Px,   short _Xexp);
 short __cdecl _ld_int(  long double* _Px,   short _Xexp);
 short __cdecl _fd_int(  float* _Px,   short _Xexp);

 short __cdecl _dscale(  double* _Px,   long _Lexp);
 short __cdecl _ldscale(  long double* _Px,   long _Lexp);
 short __cdecl _fdscale(  float* _Px,   long _Lexp);

 short __cdecl _dunscale(  short* _Pex,   double* _Px);
 short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
 short __cdecl _fdunscale(  short* _Pex,   float* _Px);

   short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
   short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
   short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

   short __cdecl _dnorm(  unsigned short* _Ps);
   short __cdecl _fdnorm(  unsigned short* _Ps);

   double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
   long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
   float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

   double __cdecl _dlog(  double _X,   int _Baseflag);
   long double __cdecl _ldlog(  long double _X,   int _Baseflag);
   float __cdecl _fdlog(  float _X,   int _Baseflag);

   double __cdecl _dsin(  double _X,   unsigned int _Qoff);
   long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
   float __cdecl _fdsin(  float _X,   unsigned int _Qoff);

// double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    double _Val;
} _double_val;

// float declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[2];
    float _Val;
} _float_val;

// long double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   // pun float types as integer array
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;







    
    
    

    
    

    
    
    
    
    

    
    
    
    
    
    




















































































































































































      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

       double    __cdecl acosh(  double _X);
       double    __cdecl asinh(  double _X);
       double    __cdecl atanh(  double _X);
        double    __cdecl atof(  char const* _String);
        double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
       double    __cdecl _cabs(  struct _complex _Complex_value);
       double    __cdecl cbrt(  double _X);
       double    __cdecl ceil(  double _X);
       double    __cdecl _chgsign(  double _X);
       double    __cdecl _copysign(  double _Number,   double _Sign);
       double    __cdecl _copysign(  double _Number,   double _Sign);
       double    __cdecl erf(  double _X);
       double    __cdecl erfc(  double _X);
       double    __cdecl exp2(  double _X);
       double    __cdecl expm1(  double _X);
       double    __cdecl fdim(  double _X,   double _Y);
       double    __cdecl floor(  double _X);
       double    __cdecl fma(  double _X,   double _Y,   double _Z);
       double    __cdecl fmax(  double _X,   double _Y);
       double    __cdecl fmin(  double _X,   double _Y);
       double    __cdecl frexp(  double _X,   int* _Y);
       double    __cdecl hypot(  double _X,   double _Y);
       double    __cdecl _hypot(  double _X,   double _Y);
       int       __cdecl ilogb(  double _X);
       double    __cdecl ldexp(  double _X,   int _Y);
       double    __cdecl lgamma(  double _X);
       long long __cdecl llrint(  double _X);
       long long __cdecl llround(  double _X);
       double    __cdecl log1p(  double _X);
       double    __cdecl log2(  double _X);
       double    __cdecl logb(  double _X);
       long      __cdecl lrint(  double _X);
       long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

       double __cdecl modf(  double _X,   double* _Y);
       double __cdecl nan(  char const* _X);
       double __cdecl nearbyint(  double _X);
       double __cdecl nextafter(  double _X,   double _Y);
       double __cdecl nexttoward(  double _X,   long double _Y);
       double __cdecl remainder(  double _X,   double _Y);
       double __cdecl remquo(  double _X,   double _Y,   int* _Z);
       double __cdecl rint(  double _X);
       double __cdecl round(  double _X);
       double __cdecl scalbln(  double _X,   long _Y);
       double __cdecl scalbn(  double _X,   int _Y);
       double __cdecl tgamma(  double _X);
       double __cdecl trunc(  double _X);
       double __cdecl _j0(  double _X );
       double __cdecl _j1(  double _X );
       double __cdecl _jn(int _X,   double _Y);
       double __cdecl _y0(  double _X);
       double __cdecl _y1(  double _X);
       double __cdecl _yn(  int _X,   double _Y);

       float     __cdecl acoshf(  float _X);
       float     __cdecl asinhf(  float _X);
       float     __cdecl atanhf(  float _X);
       float     __cdecl cbrtf(  float _X);
       float     __cdecl _chgsignf(  float _X);
       float     __cdecl copysignf(  float _Number,   float _Sign);
       float     __cdecl _copysignf(  float _Number,   float _Sign);
       float     __cdecl erff(  float _X);
       float     __cdecl erfcf(  float _X);
       float     __cdecl expm1f(  float _X);
       float     __cdecl exp2f(  float _X);
       float     __cdecl fdimf(  float _X,   float _Y);
       float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
       float     __cdecl fmaxf(  float _X,   float _Y);
       float     __cdecl fminf(  float _X,   float _Y);
       float     __cdecl _hypotf(  float _X,   float _Y);
       int       __cdecl ilogbf(  float _X);
       float     __cdecl lgammaf(  float _X);
       long long __cdecl llrintf(  float _X);
       long long __cdecl llroundf(  float _X);
       float     __cdecl log1pf(  float _X);
       float     __cdecl log2f(  float _X);
       float     __cdecl logbf(  float _X);
       long      __cdecl lrintf(  float _X);
       long      __cdecl lroundf(  float _X);
       float     __cdecl nanf(  char const* _X);
       float     __cdecl nearbyintf(  float _X);
       float     __cdecl nextafterf(  float _X,   float _Y);
       float     __cdecl nexttowardf(  float _X,   long double _Y);
       float     __cdecl remainderf(  float _X,   float _Y);
       float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
       float     __cdecl rintf(  float _X);
       float     __cdecl roundf(  float _X);
       float     __cdecl scalblnf(  float _X,   long _Y);
       float     __cdecl scalbnf(  float _X,   int _Y);
       float     __cdecl tgammaf(  float _X);
       float     __cdecl truncf(  float _X);

    





    

           float __cdecl _logbf(  float _X);
           float __cdecl _nextafterf(  float _X,   float _Y);
           int   __cdecl _finitef(  float _X);
           int   __cdecl _isnanf(  float _X);
           int   __cdecl _fpclassf(  float _X);

           int   __cdecl _set_FMA3_enable(  int _Flag);
           int   __cdecl _get_FMA3_enable(void);

    








    

           float __cdecl acosf(  float _X);
           float __cdecl asinf(  float _X);
           float __cdecl atan2f(  float _Y,   float _X);
           float __cdecl atanf(  float _X);
           float __cdecl ceilf(  float _X);
           float __cdecl cosf(  float _X);
           float __cdecl coshf(  float _X);
           float __cdecl expf(  float _X);

    











































    





          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    

    

           float __cdecl floorf(  float _X);
           float __cdecl fmodf(  float _X,   float _Y);

    













      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

           float  __cdecl log10f(  float _X);
           float  __cdecl logf(  float _X);
           float  __cdecl modff(  float _X,   float *_Y);
           float  __cdecl powf(  float _X,   float _Y);
           float  __cdecl sinf(  float _X);
           float  __cdecl sinhf(  float _X);
           float  __cdecl sqrtf(  float _X);
           float  __cdecl tanf(  float _X);
           float  __cdecl tanhf(  float _X);

    



















































       long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

       long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

       long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

       long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

       long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

       long double __cdecl erfl(  long double _X);
       long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

       long double __cdecl exp2l(  long double _X);
       long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

       long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

       long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
       long double __cdecl fmaxl(  long double _X,   long double _Y);
       long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

       int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

       long double __cdecl lgammal(  long double _X);
       long long __cdecl llrintl(  long double _X);
       long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

       long double __cdecl log1pl(  long double _X);
       long double __cdecl log2l(  long double _X);
       long double __cdecl logbl(  long double _X);
       long __cdecl lrintl(  long double _X);
       long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

       long double __cdecl nanl(  char const* _X);
       long double __cdecl nearbyintl(  long double _X);
       long double __cdecl nextafterl(  long double _X,   long double _Y);
       long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

       long double __cdecl remainderl(  long double _X,   long double _Y);
       long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
       long double __cdecl rintl(  long double _X);
       long double __cdecl roundl(  long double _X);
       long double __cdecl scalblnl(  long double _X,   long _Y);
       long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

       long double __cdecl tgammal(  long double _X);
       long double __cdecl truncl(  long double _X);

    
        
    





    
    
    
    
    
    

    

    
        
            extern double HUGE;
        



            double __cdecl j0(  double _X);
            double __cdecl j1(  double _X);
            double __cdecl jn(  int _X,   double _Y);
            double __cdecl y0(  double _X);
            double __cdecl y1(  double _X);
            double __cdecl yn(  int _X,   double _Y);
    




#pragma warning(pop)

__pragma(pack(pop))








/********************************************
 * WRAPPER FOR <time.h> and/or <sys/time.h> *
 ********************************************/









//
// time.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <time.h> header.
//
#pragma once





//
// corecrt_wtime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) time functionality, shared
// by <time.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8))



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct tm
{
    int tm_sec;   // seconds after the minute - [0, 60] including leap second
    int tm_min;   // minutes after the hour - [0, 59]
    int tm_hour;  // hours since midnight - [0, 23]
    int tm_mday;  // day of the month - [1, 31]
    int tm_mon;   // months since January - [0, 11]
    int tm_year;  // years since 1900
    int tm_wday;  // days since Sunday - [0, 6]
    int tm_yday;  // days since January 1 - [0, 365]
    int tm_isdst; // daylight savings time flag
};


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide String Time Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  
 
 
 wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

 errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );




 

 size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

 size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  
 wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );




 
 
  
 wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);





 errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );




   wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);



 errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );




   wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    #pragma warning(push)
    #pragma warning(disable: 4996)

    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    

    #pragma warning(pop)




__pragma(pack(pop))


__pragma(pack(push, 8))



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  // Seconds - >= 0
        long   tv_nsec; // Nanoseconds - [0, 999999999]
    };




// The number of clock ticks per second






//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Time Zone and Daylight Savings Time Data and Accessors
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Nonzero if Daylight Savings Time is used
  
 int* __cdecl __daylight(void);



// Offset for Daylight Savings Time
  
 long* __cdecl __dstbias(void);



// Difference in seconds between GMT and local time
  
 long* __cdecl __timezone(void);



// Standard and Daylight Savings Time time zone names
    
 char** __cdecl __tzname(void);



  
 errno_t __cdecl _get_daylight(
      int* _Daylight
    );

 
 errno_t __cdecl _get_dstbias(
      long* _DaylightSavingsBias
    );

  
 errno_t __cdecl _get_timezone(
      long* _TimeZone
    );

 
 errno_t __cdecl _get_tzname(
                             size_t* _ReturnValue,
      char*   _Buffer,
                              size_t  _SizeInBytes,
                              int     _Index
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// AppCRT Time Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
 
  
 char* __cdecl asctime(
      struct tm const* _Tm
    );


     
    
     errno_t __cdecl asctime_s(
            char*            _Buffer,
                                            size_t           _SizeInBytes,
                                                         struct tm const* _Tm
        );





 
 clock_t __cdecl clock(void);

 
 
  
 char* __cdecl _ctime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _ctime32_s(
        char*             _Buffer,
                                        size_t            _SizeInBytes,
                                                     __time32_t const* _Time
    );




 
 
  
 char* __cdecl _ctime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _ctime64_s(
        char*             _Buffer,
                                          size_t            _SizeInBytes,
                                                       __time64_t const* _Time
    );




 
 double __cdecl _difftime32(
      __time32_t _Time1,
      __time32_t _Time2
    );

 
 double __cdecl _difftime64(
      __time64_t _Time1,
      __time64_t _Time2
    );

 
  
 struct tm* __cdecl _gmtime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _gmtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  
 struct tm* __cdecl _gmtime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _gmtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
  
 struct tm* __cdecl _localtime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _localtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  
 struct tm* __cdecl _localtime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _localtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
 __time32_t __cdecl _mkgmtime32(
      struct tm* _Tm
    );

 
 __time64_t __cdecl _mkgmtime64(
      struct tm* _Tm
    );


 __time32_t __cdecl _mktime32(
      struct tm* _Tm
    );


 __time64_t __cdecl _mktime64(
      struct tm* _Tm
    );

 

 size_t __cdecl strftime(
       char*            _Buffer,
                               size_t           _SizeInBytes,
        char const*      _Format,
                               struct tm const* _Tm
    );

 

 size_t __cdecl _strftime_l(
           char*            _Buffer,
                               size_t           _MaxSize,
        char const*      _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );


 errno_t __cdecl _strdate_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );




   char* __cdecl _strdate( char *_Buffer);



 errno_t __cdecl _strtime_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );




  char* __cdecl _strtime( char *_Buffer);


 __time32_t __cdecl _time32(
      __time32_t* _Time
    );

 __time64_t __cdecl _time64(
      __time64_t* _Time
    );

 
 
 int __cdecl _timespec32_get(
      struct _timespec32* _Ts,
       int                 _Base
    );

 
 
 int __cdecl _timespec64_get(
      struct _timespec64* _Ts,
       int                 _Base
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// DesktopCRT Time Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


     void __cdecl _tzset(void);

    // The Win32 API GetLocalTime and SetLocalTime should be used instead.
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
     unsigned __cdecl _getsystime(
          struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
     unsigned __cdecl _setsystime(
          struct tm* _Tm,
          unsigned   _Milliseconds
        );





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline Function Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    











































































































          
        static __inline char* __cdecl ctime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _ctime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline double __cdecl difftime(
              time_t const _Time1,
              time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

          
        static __inline struct tm* __cdecl gmtime(
              time_t const* const _Time)
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _gmtime64(_Time);
            #pragma warning(pop)
        }

        
        static __inline struct tm* __cdecl localtime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _localtime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline time_t __cdecl _mkgmtime(
              struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
              struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
              time_t* const _Time
            )
        {
            return _time64(_Time);
        }

         
        static __inline int __cdecl timespec_get(
              struct timespec* const _Ts,
               int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                    char*         const _Buffer,
                                                    size_t        const _SizeInBytes,
                                                                 time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        

    





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-ANSI Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    

    
          void __cdecl tzset(void);
    





__pragma(pack(pop))






/******************************
 * WRAPPER FOR <sys/select.h> *
 ******************************/

/* NB caller must include <sys/types.h> */





/*******************************
 * stat() and fstat() fiddling *
 *******************************/



//
// sys/stat.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The _stat() and _fstat() families of functions.
//
#pragma once



//
// sys/types.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Types used for returning file status and time information.
//
#pragma once




    

    typedef unsigned short _ino_t; // inode number (unused on Windows)

    
        typedef _ino_t ino_t;
    





    

    typedef unsigned int _dev_t; // device code

    
        typedef _dev_t dev_t;
    





    

    typedef long _off_t; // file offset value

    
        typedef _off_t off_t;
    



__pragma(pack(push, 8))


#pragma warning(push)
#pragma warning(disable: 4820) 


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Flags
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+










    
    
    
    
    
    
    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+








    
    
    
    
    
    




 int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

 int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

 int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

 int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

 int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

 int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

 int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

 int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

 int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

 int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

 int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

 int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    



#pragma warning(pop)


__pragma(pack(pop))











/* Windows doesn't define S_IFLNK but posixmodule.c maps
 * IO_REPARSE_TAG_SYMLINK to S_IFLNK */






















/* Py_ARITHMETIC_RIGHT_SHIFT
 * C doesn't define whether a right-shift of a signed integer sign-extends
 * or zero-fills.  Here a macro to force sign extension:
 * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
 *    Return I >> J, forcing sign extension.  Arithmetically, return the
 *    floor of I/2**J.
 * Requirements:
 *    I should have signed integer type.  In the terminology of C99, this can
 *    be either one of the five standard signed integer types (signed char,
 *    short, int, long, long long) or an extended signed integer type.
 *    J is an integer >= 0 and strictly less than the number of bits in the
 *    type of I (because C doesn't define what happens for J outside that
 *    range either).
 *    TYPE used to specify the type of I, but is now ignored.  It's been left
 *    in for backwards compatibility with versions <= 2.6 or 3.0.
 * Caution:
 *    I may be evaluated more than once.
 */







/* Py_FORCE_EXPANSION(X)
 * "Simply" returns its argument.  However, macro expansions within the
 * argument are evaluated.  This unfortunate trickery is needed to get
 * token-pasting to work as desired in some cases.
 */


/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
 * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this
 * assert-fails if any information is lost.
 * Caution:
 *    VALUE may be evaluated more than once.
 */







/* Py_SET_ERRNO_ON_MATH_ERROR(x)
 * If a libm function did not set errno, but it looks like the result
 * overflowed or not-a-number, set errno to ERANGE or EDOM.  Set errno
 * to 0 before calling a libm function, and invoke this macro after,
 * passing the function result.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X is evaluated more than once.
 */














/* Py_SET_ERANGE_ON_OVERFLOW(x)
 * An alias of Py_SET_ERRNO_ON_MATH_ERROR for backward-compatibility.
 */


/* Py_ADJUST_ERANGE1(x)
 * Py_ADJUST_ERANGE2(x, y)
 * Set errno to 0 before calling a libm function, and invoke one of these
 * macros after, passing the function result(s) (Py_ADJUST_ERANGE2 is useful
 * for functions returning complex results).  This makes two kinds of
 * adjustments to errno:  (A) If it looks like the platform libm set
 * errno=ERANGE due to underflow, clear errno. (B) If it looks like the
 * platform libm overflowed but didn't set errno, force errno to ERANGE.  In
 * effect, we're trying to force a useful implementation of C89 errno
 * behavior.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X and Y may be evaluated more than once.
 */





















/*  The functions _Py_dg_strtod and _Py_dg_dtoa in Python/dtoa.c (which are
 *  required to support the short float repr introduced in Python 3.1) require
 *  that the floating-point unit that's being used for arithmetic operations
 *  on C doubles is set to use 53-bit precision.  It also requires that the
 *  FPU rounding mode is round-half-to-even, but that's less often an issue.
 *
 *  If your FPU isn't already set to 53-bit precision/round-half-to-even, and
 *  you want to make use of _Py_dg_strtod and _Py_dg_dtoa, then you should
 *
 *     #define HAVE_PY_SET_53BIT_PRECISION 1
 *
 *  and also give appropriate definitions for the following three macros:
 *
 *    _PY_SET_53BIT_PRECISION_START : store original FPU settings, and
 *        set FPU to 53-bit precision/round-half-to-even
 *    _PY_SET_53BIT_PRECISION_END : restore original FPU settings
 *    _PY_SET_53BIT_PRECISION_HEADER : any variable declarations needed to
 *        use the two macros above.
 *
 * The macros are designed to be used within a single C function: see
 * Python/pystrtod.c for an example of their use.
 */

/* get and set x87 control word for gcc/x86 */

















/* get and set x87 control word for VisualStudio/x86 */










































/* default definitions are empty */






/* If we can't guarantee 53-bit precision, don't use the code
   in Python/dtoa.c, but fall back to standard code.  This
   means that repr of a float will be long (17 sig digits).

   Realistically, there are two things that could go wrong:

   (1) doubles aren't IEEE 754 doubles, or
   (2) we're on x86 with the rounding precision set to 64-bits
       (extended precision), and we don't know how to change
       the rounding precision.
 */





/* double rounding is symptomatic of use of extended precision on x86.  If
   we're seeing double rounding, and we don't have any mechanism available for
   changing the FPU rounding precision, then don't use Python/dtoa.c. */





/* Py_DEPRECATED(version)
 * Declare a variable, type, or function deprecated.
 * Usage:
 *    extern int old_var Py_DEPRECATED(2.3);
 *    typedef int T1 Py_DEPRECATED(2.4);
 *    extern int x() Py_DEPRECATED(2.5);
 */







/* _Py_HOT_FUNCTION
 * The hot attribute on a function is used to inform the compiler that the
 * function is a hot spot of the compiled program. The function is optimized
 * more aggressively and on many target it is placed into special subsection of
 * the text section so all hot functions appears close together improving
 * locality.
 *
 * Usage:
 *    int _Py_HOT_FUNCTION x(void) { return 3; }
 *
 * Issue #28618: This attribute must not be abused, otherwise it can have a
 * negative effect on performance. Only the functions were Python spend most of
 * its time must use it. Use a profiler when running performance benchmark
 * suite to find these functions.
 */






/* _Py_NO_INLINE
 * Disable inlining on a function. For example, it helps to reduce the C stack
 * consumption.
 *
 * Usage:
 *    int _Py_NO_INLINE x(void) { return 3; }
 */






/**************************************************************************
Prototypes that are missing from the standard include files on some systems
(and possibly only some versions of such systems.)

Please be conservative with adding new ones, document them and enclose them
in platform-specific #ifdefs.
**************************************************************************/











/* On QNX 6, struct termio must be declared by including sys/termio.h
   if TCGETA, TCSETA, TCSETAW, or TCSETAF are used.  sys/termio.h must
   be included before termios.h or it will generate an error. */





/* On 4.4BSD-descendants, ctype functions serves the whole range of
 * wchar_t character set rather than single byte code points only.
 * This characteristic can break some operations of string object
 * including str.upper() and str.split() on UTF-8 locales.  This
 * workaround was provided by Tim Robbins of FreeBSD project.
 */
































/* Declarations for symbol visibility.

  PyAPI_FUNC(type): Declares a public Python API function and return type
  PyAPI_DATA(type): Declares public Python data and its type
  PyMODINIT_FUNC:   A Python module init function.  If these functions are
                    inside the Python core, they are private to the core.
                    If in an extension module, it may be declared with
                    external linkage depending on the platform.

  As a number of platforms support/require "__declspec(dllimport/dllexport)",
  we support a HAVE_DECLSPEC_DLL macro to save duplication.
*/

/*
  All windows ports, except cygwin, are handled in PC/pyconfig.h.

  Cygwin is the only other autoconf platform requiring special
  linkage handling and it uses __declspec().
*/




/* only get special linkage if built as shared or platform is Cygwin */













        /* Building an extension module, or an embedded situation */
        /* public Python functions and data are imported */
        /* Under Cygwin, auto-import functions to prevent compilation */
        /* failures similar to those described at the bottom of 4.1: */
        /* http://docs.python.org/extending/windows.html#a-cookbook-approach */




        /* module init functions outside the core must be exported */









/* If no external linkage macros defined by now, create defaults */














/* limits.h constants that may be missing */




































/*
 * Hide GCC attributes from compilers that don't support them.
 */






/*
 * Specify alignment on compilers that support it.
 */






/* Eliminate end-of-loop code not reached warnings from SunPro C
 * when using do{...}while(0) macros
 */














/*
 * Convenient macros to deal with endianness of the platform. WORDS_BIGENDIAN is
 * detected by configure and defined in pyconfig.h. The code in pyconfig.h
 * also takes care of Apple's universal builds.
 */



































/* Maximum value of the Windows DWORD type */


/* This macro used to tell whether Python was built with multithreading
 * enabled.  Now multithreading is always enabled, but keep the macro
 * for compatibility.
 */










/* Minimum value between x and y */


/* Maximum value between x and y */


/* Absolute value of the number x */




/* Convert the argument to a string. For example, Py_STRINGIFY(123) is replaced
   with "123" by the preprocessor. Defines are also replaced by their value.
   For example Py_STRINGIFY(__LINE__) is replaced by the line number, not
   by "__LINE__". */


/* Get the size of a structure member in bytes */


/* Argument must be a char or an int in [-128, 127] or [0, 255]. */


/* Assert a build-time dependency, as an expression.

   Your compile will fail if the condition isn't true, or can't be evaluated
   by the compiler. This can be used in an expression: its value is 0.

   Example:

   #define foo_to_char(foo)  \
       ((char *)(foo)        \
        + Py_BUILD_ASSERT_EXPR(offsetof(struct foo, string) == 0))

   Written by Rusty Russell, public domain, http://ccodearchive.net/ */







/* Get the number of elements in a visible array

   This does not work on pointers, or arrays declared as [], or function
   parameters. With correct compiler support, such usage will cause a build
   error (see Py_BUILD_ASSERT_EXPR).

   Written by Rusty Russell, public domain, http://ccodearchive.net/

   Requires at GCC 3.1+ */













/* Define macros for inline documentation. */








/* Below "a" is a power of 2. */
/* Round down size "n" to be a multiple of "a". */

/* Round up size "n" to be a multiple of "a". */


/* Round pointer "p" down to the closest "a"-aligned address <= "p". */

/* Round pointer "p" up to the closest "a"-aligned address >= "p". */


/* Check if pointer "p" is aligned to "a"-bytes boundary. */







































































































































































































































































































































































































































































































































































/* Debug-mode build with pymalloc implies PYMALLOC_DEBUG.
 *  PYMALLOC_DEBUG is in error if pymalloc is not in use.
 */












/**************************************************************************
Symbols and macros to supply platform-independent interfaces to mathematical
functions and constants
**************************************************************************/

/* Python provides implementations for copysign, round and hypot in
 * Python/pymath.c just in case your math library doesn't provide the
 * functions.
 *
 *Note: PC/pyconfig.h defines copysign as _copysign
 */












/* extra declarations */










/* High precision definition of pi and e (Euler)
 * The values are taken from libc6's math.h.
 */















/* Tau (2pi) to 40 digits, taken from tauday.com/tau-digits. */





/* On x86, Py_FORCE_DOUBLE forces a floating-point number out of an x87 FPU
   register and into a 64-bit memory location, rounding from extended
   precision to double precision in the process.  On other platforms it does
   nothing. */

/* we take double rounding as evidence of x87 usage */


















/* Py_IS_NAN(X)
 * Return 1 if float or double arg is a NaN, else 0.
 * Caution:
 *     X is evaluated more than once.
 *     This may not work on all platforms.  Each platform has *some*
 *     way to spell this, though -- override in pyconfig.h if you have
 *     a platform where it doesn't work.
 * Note: PC/pyconfig.h defines Py_IS_NAN as _isnan
 */








/* Py_IS_INFINITY(X)
 * Return 1 if float or double arg is an infinity, else 0.
 * Caution:
 *    X is evaluated more than once.
 *    This implementation may set the underflow flag if |X| is very small;
 *    it really can't be implemented correctly (& easily) before C99.
 *    Override in pyconfig.h if you have a better spelling on your platform.
 *  Py_FORCE_DOUBLE is used to avoid getting false negatives from a
 *    non-infinite value v sitting in an 80-bit x87 register such that
 *    v becomes infinite when spilled from the register to 64-bit memory.
 * Note: PC/pyconfig.h defines Py_IS_INFINITY as _isinf
 */









/* Py_IS_FINITE(X)
 * Return 1 if float or double arg is neither infinite nor NAN, else 0.
 * Some compilers (e.g. VisualStudio) have intrisics for this, so a special
 * macro for this particular test is useful
 * Note: PC/pyconfig.h defines Py_IS_FINITE as _finite
 */










/* HUGE_VAL is supposed to expand to a positive double infinity.  Python
 * uses Py_HUGE_VAL instead because some platforms are broken in this
 * respect.  We used to embed code in pyport.h to try to worm around that,
 * but different platforms are broken in conflicting ways.  If you're on
 * a platform where HUGE_VAL is defined incorrectly, fiddle your Python
 * config to #define Py_HUGE_VAL to something that works on your platform.
 */




/* Py_NAN
 * A value that evaluates to a NaN. On IEEE 754 platforms INF*0 or
 * INF/INF works. Define Py_NO_NAN in pyconfig.h if your platform
 * doesn't support NaNs.
 */


    























/* Py_OVERFLOWED(X)
 * Return 1 iff a libm function overflowed.  Set errno to 0 before calling
 * a libm function, and invoke this macro after, passing the function
 * result.
 * Caution:
 *    This isn't reliable.  C99 no longer requires libm to set errno under
 *        any exceptional condition, but does require +- HUGE_VAL return
 *        values on overflow.  A 754 box *probably* maps HUGE_VAL to a
 *        double infinity, and we're cool if that's so, unless the input
 *        was an infinity and an infinity is the expected result.  A C89
 *        system sets errno to ERANGE, so we check for that too.  We're
 *        out of luck if a C99 754 box doesn't map HUGE_VAL to +Inf, or
 *        if the returned result is a NaN, or if a C89 box returns HUGE_VAL
 *        in non-overflow cases.
 *    X is evaluated more than once.
 * Some platforms have better way to spell this, so expect some #ifdef'ery.
 *
 * OpenBSD uses 'isinf()' because a compiler bug on that platform causes
 * the longer macro version to be mis-compiled. This isn't optimal, and
 * should be removed once a newer compiler is available on that platform.
 * The system that had the failure was running OpenBSD 3.2 on Intel, with
 * gcc 2.95.3.
 *
 * According to Tim's checkin, the FreeBSD systems use isinf() to work
 * around a FPE bug on that platform.
 */








/* Return whether integral type *type* is signed or not. */

/* Return the maximum value of integral type *type*. */

/* Return the minimum value of integral type *type*. */

/* Check whether *v* is in the range of integral type *type*. This is most
 * useful if *v* is floating-point, since demoting a floating-point *v* to an
 * integral type that cannot represent *v*'s integral part is undefined
 * behavior. */


















/* Object and type object interface */

/*
Objects are structures allocated on the heap.  Special rules apply to
the use of objects to ensure they are properly garbage-collected.
Objects are never allocated statically or on the stack; they must be
accessed through special macros and functions only.  (Type objects are
exceptions to the first rule; the standard types are represented by
statically initialized type objects, although work on type/class unification
for Python 2.2 made it possible to have heap-allocated type objects too).

An object has a 'reference count' that is increased or decreased when a
pointer to the object is copied or deleted; when the reference count
reaches zero there are no references to the object left and it can be
removed from the heap.

An object has a 'type' that determines what it represents and what kind
of data it contains.  An object's type is fixed when it is created.
Types themselves are represented as objects; an object contains a
pointer to the corresponding type object.  The type itself has a type
pointer pointing to the object representing the type 'type', which
contains a pointer to itself!).

Objects do not float around in memory; once allocated an object keeps
the same size and address.  Objects that must hold variable-size data
can contain pointers to variable-size parts of the object.  Not all
objects of the same type have the same size; but the size cannot change
after allocation.  (These restrictions are made so a reference to an
object can be simply a pointer -- moving an object would require
updating all the pointers, and changing an object's size would require
moving it if there was another object right next to it.)

Objects are always accessed through pointers of the type 'PyObject *'.
The type 'PyObject' is a structure that only contains the reference count
and the type pointer.  The actual memory allocated for an object
contains other data that can only be accessed after casting the pointer
to a pointer to a longer structure type.  This longer type must start
with the reference count and type fields; the macro PyObject_HEAD should be
used for this (to accommodate for future changes).  The implementation
of a particular object type can cast the object pointer to the proper
type and back.

A standard interface exists for objects that contain an array of items
whose size is determined when the object is allocated.
*/

/* Py_DEBUG implies Py_TRACE_REFS. */




/* Py_TRACE_REFS implies Py_REF_DEBUG. */






















/* PyObject_HEAD defines the initial segment of every PyObject. */









/* PyObject_VAR_HEAD defines the initial segment of all variable-size
 * container objects.  These end with a declaration of an array with 1
 * element, but enough space is malloc'ed so that the array actually
 * has room for ob_size elements.  Note that ob_size is an element count,
 * not necessarily a byte count.
 */



/* Nothing is actually declared to be a PyObject, but every pointer to
 * a Python object can be cast to a PyObject*.  This is inheritance built
 * by hand.  Similarly every pointer to a variable-size Python object can,
 * in addition, be cast to PyVarObject*.
 */
typedef struct _object {
    
    Py_ssize_t ob_refcnt;
    struct _typeobject *ob_type;
} PyObject;

typedef struct {
    PyObject ob_base;
    Py_ssize_t ob_size; /* Number of items in variable part */
} PyVarObject;






/********************* String Literals ****************************************/
/* This structure helps managing static strings. The basic usage goes like this:
   Instead of doing

       r = PyObject_CallMethod(o, "foo", "args", ...);

   do

       _Py_IDENTIFIER(foo);
       ...
       r = _PyObject_CallMethodId(o, &PyId_foo, "args", ...);

   PyId_foo is a static variable, either on block level or file level. On first
   usage, the string "foo" is interned, and the structures are linked. On interpreter
   shutdown, all strings are released (through _PyUnicode_ClearStaticStrings).

   Alternatively, _Py_static_string allows choosing the variable name.
   _PyUnicode_FromId returns a borrowed reference to the interned string.
   _PyObject_{Get,Set,Has}AttrId are __getattr__ versions using _Py_Identifier*.
*/
typedef struct _Py_Identifier {
    struct _Py_Identifier *next;
    const char* string;
    PyObject *object;
} _Py_Identifier;







/*
Type objects contain a string containing the type name (to help somewhat
in debugging), the allocation parameters (see PyObject_New() and
PyObject_NewVar()),
and methods for accessing objects of the type.  Methods are optional, a
nil pointer meaning that particular kind of access is not available for
this type.  The Py_DECREF() macro uses the tp_dealloc method without
checking for a nil pointer; it should always be implemented except if
the implementation can guarantee that the reference count will never
reach zero (e.g., for statically allocated type objects).

NB: the methods for certain type groups are now contained in separate
method blocks.
*/

typedef PyObject * (*unaryfunc)(PyObject *);
typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
typedef int (*inquiry)(PyObject *);
typedef Py_ssize_t (*lenfunc)(PyObject *);
typedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);
typedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);
typedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);
typedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);


/* buffer interface */
typedef struct bufferinfo {
    void *buf;
    PyObject *obj;        /* owned reference */
    Py_ssize_t len;
    Py_ssize_t itemsize;  /* This is Py_ssize_t so it can be
                             pointed to by strides in simple case.*/
    int readonly;
    int ndim;
    char *format;
    Py_ssize_t *shape;
    Py_ssize_t *strides;
    Py_ssize_t *suboffsets;
    void *internal;
} Py_buffer;

typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
typedef void (*releasebufferproc)(PyObject *, Py_buffer *);

/* Maximum number of dimensions */


/* Flags for getting buffers */


/*  we used to include an E, backwards compatible alias  */

























/* End buffer interface */


typedef int (*objobjproc)(PyObject *, PyObject *);
typedef int (*visitproc)(PyObject *, void *);
typedef int (*traverseproc)(PyObject *, visitproc, void *);


typedef struct {
    /* Number implementations must check *both*
       arguments for proper type and implement the necessary conversions
       in the slot functions themselves. */

    binaryfunc nb_add;
    binaryfunc nb_subtract;
    binaryfunc nb_multiply;
    binaryfunc nb_remainder;
    binaryfunc nb_divmod;
    ternaryfunc nb_power;
    unaryfunc nb_negative;
    unaryfunc nb_positive;
    unaryfunc nb_absolute;
    inquiry nb_bool;
    unaryfunc nb_invert;
    binaryfunc nb_lshift;
    binaryfunc nb_rshift;
    binaryfunc nb_and;
    binaryfunc nb_xor;
    binaryfunc nb_or;
    unaryfunc nb_int;
    void *nb_reserved;  /* the slot formerly known as nb_long */
    unaryfunc nb_float;

    binaryfunc nb_inplace_add;
    binaryfunc nb_inplace_subtract;
    binaryfunc nb_inplace_multiply;
    binaryfunc nb_inplace_remainder;
    ternaryfunc nb_inplace_power;
    binaryfunc nb_inplace_lshift;
    binaryfunc nb_inplace_rshift;
    binaryfunc nb_inplace_and;
    binaryfunc nb_inplace_xor;
    binaryfunc nb_inplace_or;

    binaryfunc nb_floor_divide;
    binaryfunc nb_true_divide;
    binaryfunc nb_inplace_floor_divide;
    binaryfunc nb_inplace_true_divide;

    unaryfunc nb_index;

    binaryfunc nb_matrix_multiply;
    binaryfunc nb_inplace_matrix_multiply;
} PyNumberMethods;

typedef struct {
    lenfunc sq_length;
    binaryfunc sq_concat;
    ssizeargfunc sq_repeat;
    ssizeargfunc sq_item;
    void *was_sq_slice;
    ssizeobjargproc sq_ass_item;
    void *was_sq_ass_slice;
    objobjproc sq_contains;

    binaryfunc sq_inplace_concat;
    ssizeargfunc sq_inplace_repeat;
} PySequenceMethods;

typedef struct {
    lenfunc mp_length;
    binaryfunc mp_subscript;
    objobjargproc mp_ass_subscript;
} PyMappingMethods;

typedef struct {
    unaryfunc am_await;
    unaryfunc am_aiter;
    unaryfunc am_anext;
} PyAsyncMethods;

typedef struct {
     getbufferproc bf_getbuffer;
     releasebufferproc bf_releasebuffer;
} PyBufferProcs;


typedef void (*freefunc)(void *);
typedef void (*destructor)(PyObject *);

/* We can't provide a full compile-time check that limited-API
   users won't implement tp_print. However, not defining printfunc
   and making tp_print of a different function pointer type
   should at least cause a warning in most cases. */
typedef int (*printfunc)(PyObject *, FILE *, int);

typedef PyObject *(*getattrfunc)(PyObject *, char *);
typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
typedef PyObject *(*reprfunc)(PyObject *);
typedef Py_hash_t (*hashfunc)(PyObject *);
typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
typedef PyObject *(*getiterfunc) (PyObject *);
typedef PyObject *(*iternextfunc) (PyObject *);
typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);




typedef struct _typeobject {
    PyVarObject ob_base;
    const char *tp_name; /* For printing, in format "<module>.<name>" */
    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

    /* Methods to implement standard operations */

    destructor tp_dealloc;
    printfunc tp_print;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)
                                    or tp_reserved (Python 3) */
    reprfunc tp_repr;

    /* Method suites for standard classes */

    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;

    /* More standard operations (here for binary compatibility) */

    hashfunc tp_hash;
    ternaryfunc tp_call;
    reprfunc tp_str;
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;

    /* Functions to access object as input/output buffer */
    PyBufferProcs *tp_as_buffer;

    /* Flags to define presence of optional/expanded features */
    unsigned long tp_flags;

    const char *tp_doc; /* Documentation string */

    /* Assigned meaning in release 2.0 */
    /* call function for all accessible objects */
    traverseproc tp_traverse;

    /* delete references to contained objects */
    inquiry tp_clear;

    /* Assigned meaning in release 2.1 */
    /* rich comparisons */
    richcmpfunc tp_richcompare;

    /* weak reference enabler */
    Py_ssize_t tp_weaklistoffset;

    /* Iterators */
    getiterfunc tp_iter;
    iternextfunc tp_iternext;

    /* Attribute descriptor and subclassing stuff */
    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;
    struct _typeobject *tp_base;
    PyObject *tp_dict;
    descrgetfunc tp_descr_get;
    descrsetfunc tp_descr_set;
    Py_ssize_t tp_dictoffset;
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    freefunc tp_free; /* Low-level free-memory routine */
    inquiry tp_is_gc; /* For PyObject_IS_GC */
    PyObject *tp_bases;
    PyObject *tp_mro; /* method resolution order */
    PyObject *tp_cache;
    PyObject *tp_subclasses;
    PyObject *tp_weaklist;
    destructor tp_del;

    /* Type attribute cache version tag. Added in version 2.6 */
    unsigned int tp_version_tag;

    destructor tp_finalize;









} PyTypeObject;


typedef struct{
    int slot;    /* slot id, see below */
    void *pfunc; /* function pointer */
} PyType_Slot;

typedef struct{
    const char* name;
    int basicsize;
    int itemsize;
    unsigned int flags;
    PyType_Slot *slots; /* terminated by slot==0. */
} PyType_Spec;

__declspec(dllimport) PyObject* PyType_FromSpec(PyType_Spec*);

__declspec(dllimport) PyObject* PyType_FromSpecWithBases(PyType_Spec*, PyObject*);


__declspec(dllimport) void* PyType_GetSlot(PyTypeObject*, int);



/* The *real* layout of a type object when allocated on the heap */
typedef struct _heaptypeobject {
    /* Note: there's a dependency on the order of these members
       in slotptr() in typeobject.c . */
    PyTypeObject ht_type;
    PyAsyncMethods as_async;
    PyNumberMethods as_number;
    PyMappingMethods as_mapping;
    PySequenceMethods as_sequence; /* as_sequence comes after as_mapping,
                                      so that the mapping wins when both
                                      the mapping and the sequence define
                                      a given operator (e.g. __getitem__).
                                      see add_operators() in typeobject.c . */
    PyBufferProcs as_buffer;
    PyObject *ht_name, *ht_slots, *ht_qualname;
    struct _dictkeysobject *ht_cached_keys;
    /* here are optional user slots, followed by the members. */
} PyHeapTypeObject;

/* access macro to the members which are floating "behind" the object */




/* Generic type check */
__declspec(dllimport) int PyType_IsSubtype(PyTypeObject *, PyTypeObject *);



extern __declspec(dllimport) PyTypeObject PyType_Type; /* built-in 'type' */
extern __declspec(dllimport) PyTypeObject PyBaseObject_Type; /* built-in 'object' */
extern __declspec(dllimport) PyTypeObject PySuper_Type; /* built-in 'super' */

__declspec(dllimport) unsigned long PyType_GetFlags(PyTypeObject*);





__declspec(dllimport) int PyType_Ready(PyTypeObject *);
__declspec(dllimport) PyObject * PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
__declspec(dllimport) PyObject * PyType_GenericNew(PyTypeObject *,
                                               PyObject *, PyObject *);

__declspec(dllimport) const char * _PyType_Name(PyTypeObject *);
__declspec(dllimport) PyObject * _PyType_Lookup(PyTypeObject *, PyObject *);
__declspec(dllimport) PyObject * _PyType_LookupId(PyTypeObject *, _Py_Identifier *);
__declspec(dllimport) PyObject * _PyObject_LookupSpecial(PyObject *, _Py_Identifier *);
__declspec(dllimport) PyTypeObject * _PyType_CalculateMetaclass(PyTypeObject *, PyObject *);

__declspec(dllimport) unsigned int PyType_ClearCache(void);
__declspec(dllimport) void PyType_Modified(PyTypeObject *);


__declspec(dllimport) PyObject * _PyType_GetDocFromInternalDoc(const char *, const char *);
__declspec(dllimport) PyObject * _PyType_GetTextSignatureFromInternalDoc(const char *, const char *);


/* Generic operations on objects */

struct _Py_Identifier;
__declspec(dllimport) int PyObject_Print(PyObject *, FILE *, int);
__declspec(dllimport) void _Py_BreakPoint(void);
__declspec(dllimport) void _PyObject_Dump(PyObject *);

__declspec(dllimport) PyObject * PyObject_Repr(PyObject *);
__declspec(dllimport) PyObject * PyObject_Str(PyObject *);
__declspec(dllimport) PyObject * PyObject_ASCII(PyObject *);
__declspec(dllimport) PyObject * PyObject_Bytes(PyObject *);
__declspec(dllimport) PyObject * PyObject_RichCompare(PyObject *, PyObject *, int);
__declspec(dllimport) int PyObject_RichCompareBool(PyObject *, PyObject *, int);
__declspec(dllimport) PyObject * PyObject_GetAttrString(PyObject *, const char *);
__declspec(dllimport) int PyObject_SetAttrString(PyObject *, const char *, PyObject *);
__declspec(dllimport) int PyObject_HasAttrString(PyObject *, const char *);
__declspec(dllimport) PyObject * PyObject_GetAttr(PyObject *, PyObject *);
__declspec(dllimport) int PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
__declspec(dllimport) int PyObject_HasAttr(PyObject *, PyObject *);

__declspec(dllimport) int _PyObject_IsAbstract(PyObject *);
__declspec(dllimport) PyObject * _PyObject_GetAttrId(PyObject *, struct _Py_Identifier *);
__declspec(dllimport) int _PyObject_SetAttrId(PyObject *, struct _Py_Identifier *, PyObject *);
__declspec(dllimport) int _PyObject_HasAttrId(PyObject *, struct _Py_Identifier *);
/* Replacements of PyObject_GetAttr() and _PyObject_GetAttrId() which
   don't raise AttributeError.

   Return 1 and set *result != NULL if an attribute is found.
   Return 0 and set *result == NULL if an attribute is not found;
   an AttributeError is silenced.
   Return -1 and set *result == NULL if an error other than AttributeError
   is raised.
*/
__declspec(dllimport) int _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **);
__declspec(dllimport) int _PyObject_LookupAttrId(PyObject *, struct _Py_Identifier *, PyObject **);
__declspec(dllimport) PyObject ** _PyObject_GetDictPtr(PyObject *);

__declspec(dllimport) PyObject * PyObject_SelfIter(PyObject *);

__declspec(dllimport) PyObject * _PyObject_NextNotImplemented(PyObject *);

__declspec(dllimport) PyObject * PyObject_GenericGetAttr(PyObject *, PyObject *);
__declspec(dllimport) int PyObject_GenericSetAttr(PyObject *,
                                              PyObject *, PyObject *);

__declspec(dllimport) int PyObject_GenericSetDict(PyObject *, PyObject *, void *);

__declspec(dllimport) Py_hash_t PyObject_Hash(PyObject *);
__declspec(dllimport) Py_hash_t PyObject_HashNotImplemented(PyObject *);
__declspec(dllimport) int PyObject_IsTrue(PyObject *);
__declspec(dllimport) int PyObject_Not(PyObject *);
__declspec(dllimport) int PyCallable_Check(PyObject *);

__declspec(dllimport) void PyObject_ClearWeakRefs(PyObject *);

__declspec(dllimport) void PyObject_CallFinalizer(PyObject *);
__declspec(dllimport) int PyObject_CallFinalizerFromDealloc(PyObject *);



/* Same as PyObject_Generic{Get,Set}Attr, but passing the attributes
   dict as the last parameter. */
__declspec(dllimport) PyObject *
_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int);
__declspec(dllimport) int
_PyObject_GenericSetAttrWithDict(PyObject *, PyObject *,
                                 PyObject *, PyObject *);


/* Helper to look up a builtin object */

__declspec(dllimport) PyObject *
_PyObject_GetBuiltin(const char *name);


/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a
   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),
   returning the names of the current locals.  In this case, if there are
   no current locals, NULL is returned, and PyErr_Occurred() is false.
*/
__declspec(dllimport) PyObject * PyObject_Dir(PyObject *);


/* Helpers for printing recursive container types */
__declspec(dllimport) int Py_ReprEnter(PyObject *);
__declspec(dllimport) void Py_ReprLeave(PyObject *);

/* Flag bits for printing: */


/*
`Type flags (tp_flags)

These flags are used to extend the type structure in a backwards-compatible
fashion. Extensions can use the flags to indicate (and test) when a given
type structure contains a new feature. The Python core will use these when
introducing new functionality between major revisions (to avoid mid-version
changes in the PYTHON_API_VERSION).

Arbitration of the flag bit positions will need to be coordinated among
all extension writers who publicly release their extensions (this will
be fewer than you might expect!)..

Most flags were removed as of Python 3.0 to make room for new flags.  (Some
flags are not for backwards compatibility but to indicate the presence of an
optional feature; these flags remain of course.)

Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.

Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
given type object has a specified feature.
*/

/* Set if the type object is dynamically allocated */


/* Set if the type allows subclassing */


/* Set if the type is 'ready' -- fully initialized */


/* Set while the type is being 'readied', to prevent recursive ready calls */


/* Objects support garbage collection (see objimp.h) */


/* These two bits are preserved for Stackless Python, next after this is 17 */






/* Objects support type attribute cache */



/* Type is abstract and cannot be instantiated */


/* These flags are used to determine if a type is a subclass. */














/* NOTE: The following flags reuse lower bits (removed as part of the
 * Python 3.0 transition). */

/* Type structure has tp_finalize member (3.4) */










/*
The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
reference counts.  Py_DECREF calls the object's deallocator function when
the refcount falls to 0; for
objects that don't contain references to other objects or heap memory
this can be the standard function free().  Both macros can be used
wherever a void expression is allowed.  The argument must not be a
NULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.
The macro _Py_NewReference(op) initialize reference counts to 1, and
in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
bookkeeping appropriate to the special build.

We assume that the reference count field can never overflow; this can
be proven when the size of the field is the same as the pointer size, so
we ignore the possibility.  Provided a C int is at least 32 bits (which
is implicitly assumed in many parts of this code), that's enough for
about 2**31 references to an object.

XXX The following became out of date in Python 2.2, but I'm not sure
XXX what the full truth is now.  Certainly, heap-allocated type objects
XXX can and should be deallocated.
Type objects should never be deallocated; the type pointer in an object
is not considered to be a reference to the type object, to save
complications in the deallocation function.  (This is actually a
decision that's up to the implementer of each new type so if you want,
you can count such references to the type object.)
*/

/* First define a pile of simple helper macros, one set per special
 * build symbol.  These either expand to the obvious things, or to
 * nothing at all when the special mode isn't in effect.  The main
 * macros can later be defined just once then, yet expand to different
 * things depending on which special build options are and aren't in effect.
 * Trust me <wink>:  while painful, this is 20x easier to understand than,
 * e.g, defining _Py_NewReference five different times in a maze of nested
 * #ifdefs (we used to do that -- it was impenetrable).
 */
















































/* Without Py_TRACE_REFS, there's little enough to do that we expand code
 * inline.
 */






























/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear
 * and tp_dealloc implementations.
 *
 * Note that "the obvious" code can be deadly:
 *
 *     Py_XDECREF(op);
 *     op = NULL;
 *
 * Typically, `op` is something like self->containee, and `self` is done
 * using its `containee` member.  In the code sequence above, suppose
 * `containee` is non-NULL with a refcount of 1.  Its refcount falls to
 * 0 on the first line, which can trigger an arbitrary amount of code,
 * possibly including finalizers (like __del__ methods or weakref callbacks)
 * coded in Python, which in turn can release the GIL and allow other threads
 * to run, etc.  Such code may even invoke methods of `self` again, or cause
 * cyclic gc to trigger, but-- oops! --self->containee still points to the
 * object being torn down, and it may be in an insane state while being torn
 * down.  This has in fact been a rich historic source of miserable (rare &
 * hard-to-diagnose) segfaulting (and other) bugs.
 *
 * The safe way is:
 *
 *      Py_CLEAR(op);
 *
 * That arranges to set `op` to NULL _before_ decref'ing, so that any code
 * triggered as a side-effect of `op` getting torn down no longer believes
 * `op` points to a valid object.
 *
 * There are cases where it's safe to use the naive code, but they're brittle.
 * For example, if `op` points to a Python integer, you know that destroying
 * one of those can't cause problems -- but in part that relies on that
 * Python integers aren't currently weakly referencable.  Best practice is
 * to use Py_CLEAR() even if you can't think of a reason for why you need to.
 */









/* Macros to use in case the object pointer may be NULL: */















/* Safely decref `op` and set `op` to `op2`.
 *
 * As in case of Py_CLEAR "the obvious" code can be deadly:
 *
 *     Py_DECREF(op);
 *     op = op2;
 *
 * The safe way is:
 *
 *      Py_SETREF(op, op2);
 *
 * That arranges to set `op` to `op2` _before_ decref'ing, so that any code
 * triggered as a side-effect of `op` getting torn down no longer believes
 * `op` points to a valid object.
 *
 * Py_XSETREF is a variant of Py_SETREF that uses Py_XDECREF instead of
 * Py_DECREF.
 */

















/*
These are provided as conveniences to Python runtime embedders, so that
they can have object code that is not dependent on Python compilation flags.
*/
__declspec(dllimport) void Py_IncRef(PyObject *);
__declspec(dllimport) void Py_DecRef(PyObject *);


extern __declspec(dllimport) PyTypeObject _PyNone_Type;
extern __declspec(dllimport) PyTypeObject _PyNotImplemented_Type;


/*
_Py_NoneStruct is an object of undefined type which can be used in contexts
where NULL (nil) is not suitable (since NULL often means 'error').

Don't forget to apply Py_INCREF() when returning this value!!!
*/
extern __declspec(dllimport) PyObject _Py_NoneStruct; /* Don't use this directly */


/* Macro for returning Py_None from a function */


/*
Py_NotImplemented is a singleton used to signal that an operation is
not implemented for a given type combination.
*/
extern __declspec(dllimport) PyObject _Py_NotImplementedStruct; /* Don't use this directly */


/* Macro for returning Py_NotImplemented from a function */



/* Rich comparison opcodes */







/*
 * Macro for implementing rich comparisons
 *
 * Needs to be a macro because any C-comparable type can be used.
 */















/* Maps Py_LT to Py_GT, ..., Py_GE to Py_LE.
 * Defined in object.c.
 */
extern __declspec(dllimport) int _Py_SwappedOp[];



/*
More conventions
================

Argument Checking
-----------------

Functions that take objects as arguments normally don't check for nil
arguments, but they do check the type of the argument, and return an
error if the function doesn't apply to the type.

Failure Modes
-------------

Functions may fail for a variety of reasons, including running out of
memory.  This is communicated to the caller in two ways: an error string
is set (see errors.h), and the function result differs: functions that
normally return a pointer return NULL for failure, functions returning
an integer return -1 (which could be a legal return value too!), and
other functions return 0 for success and -1 for failure.
Callers should always check for errors before using the result.  If
an error was set, the caller must either explicitly clear it, or pass
the error on to its caller.

Reference Counts
----------------

It takes a while to get used to the proper usage of reference counts.

Functions that create an object set the reference count to 1; such new
objects must be stored somewhere or destroyed again with Py_DECREF().
Some functions that 'store' objects, such as PyTuple_SetItem() and
PyList_SetItem(),
don't increment the reference count of the object, since the most
frequent use is to store a fresh object.  Functions that 'retrieve'
objects, such as PyTuple_GetItem() and PyDict_GetItemString(), also
don't increment
the reference count, since most frequently the object is only looked at
quickly.  Thus, to retrieve an object and store it again, the caller
must call Py_INCREF() explicitly.

NOTE: functions that 'consume' a reference count, like
PyList_SetItem(), consume the reference even if the object wasn't
successfully stored, to simplify error handling.

It seems attractive to make other functions that take an object as
argument consume a reference count; however, this may quickly get
confusing (even the current practice is already confusing).  Consider
it carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at
times.
*/


/* Trashcan mechanism, thanks to Christian Tismer.

When deallocating a container object, it's possible to trigger an unbounded
chain of deallocations, as each Py_DECREF in turn drops the refcount on "the
next" object in the chain to 0.  This can easily lead to stack faults, and
especially in threads (which typically have less stack space to work with).

A container object that participates in cyclic gc can avoid this by
bracketing the body of its tp_dealloc function with a pair of macros:

static void
mytype_dealloc(mytype *p)
{
    ... declarations go here ...

    PyObject_GC_UnTrack(p);        // must untrack first
    Py_TRASHCAN_SAFE_BEGIN(p)
    ... The body of the deallocator goes here, including all calls ...
    ... to Py_DECREF on contained objects.                         ...
    Py_TRASHCAN_SAFE_END(p)
}

CAUTION:  Never return from the middle of the body!  If the body needs to
"get out early", put a label immediately before the Py_TRASHCAN_SAFE_END
call, and goto it.  Else the call-depth counter (see below) will stay
above 0 forever, and the trashcan will never get emptied.

How it works:  The BEGIN macro increments a call-depth counter.  So long
as this counter is small, the body of the deallocator is run directly without
further ado.  But if the counter gets large, it instead adds p to a list of
objects to be deallocated later, skips the body of the deallocator, and
resumes execution after the END macro.  The tp_dealloc routine then returns
without deallocating anything (and so unbounded call-stack depth is avoided).

When the call stack finishes unwinding again, code generated by the END macro
notices this, and calls another routine to deallocate all the objects that
may have been added to the list of deferred deallocations.  In effect, a
chain of N deallocations is broken into (N-1)/(PyTrash_UNWIND_LEVEL-1) pieces,
with the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.
*/


/* This is the old private API, invoked by the macros before 3.2.4.
   Kept for binary compatibility of extensions using the stable ABI. */
__declspec(dllimport) void _PyTrash_deposit_object(PyObject*);
__declspec(dllimport) void _PyTrash_destroy_chain(void);


/* The new thread-safe private API, invoked by the macros below. */
__declspec(dllimport) void _PyTrash_thread_deposit_object(PyObject*);
__declspec(dllimport) void _PyTrash_thread_destroy_chain(void);








            /* The body of the deallocator is here. */










__declspec(dllimport) void
_PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks,
                       size_t sizeof_block);
__declspec(dllimport) void
_PyObject_DebugTypeStats(FILE *out);








/**************************************************************************
Symbols and macros to supply platform-independent interfaces to time related
functions and constants
**************************************************************************/




/* _PyTime_t: Python timestamp with subsecond precision. It can be used to
   store a duration, and so indirectly a date (related to another date, like
   UNIX epoch). */
typedef int64_t _PyTime_t;



typedef enum {
    /* Round towards minus infinity (-inf).
       For example, used to read a clock. */
    _PyTime_ROUND_FLOOR=0,
    /* Round towards infinity (+inf).
       For example, used for timeout to wait "at least" N seconds. */
    _PyTime_ROUND_CEILING=1,
    /* Round to nearest with ties going to nearest even integer.
       For example, used to round from a Python float. */
    _PyTime_ROUND_HALF_EVEN=2,
    /* Round away from zero
       For example, used for timeout. _PyTime_ROUND_CEILING rounds
       -1e-9 to 0 milliseconds which causes bpo-31786 issue.
       _PyTime_ROUND_UP rounds -1e-9 to -1 millisecond which keeps
       the timeout sign as expected. select.poll(timeout) must block
       for negative values." */
    _PyTime_ROUND_UP=3,
    /* _PyTime_ROUND_TIMEOUT (an alias for _PyTime_ROUND_UP) should be
       used for timeouts. */
    _PyTime_ROUND_TIMEOUT = _PyTime_ROUND_UP
} _PyTime_round_t;


/* Convert a time_t to a PyLong. */
__declspec(dllimport) PyObject * _PyLong_FromTime_t(
    time_t sec);

/* Convert a PyLong to a time_t. */
__declspec(dllimport) time_t _PyLong_AsTime_t(
    PyObject *obj);

/* Convert a number of seconds, int or float, to time_t. */
__declspec(dllimport) int _PyTime_ObjectToTime_t(
    PyObject *obj,
    time_t *sec,
    _PyTime_round_t);

/* Convert a number of seconds, int or float, to a timeval structure.
   usec is in the range [0; 999999] and rounded towards zero.
   For example, -1.2 is converted to (-2, 800000). */
__declspec(dllimport) int _PyTime_ObjectToTimeval(
    PyObject *obj,
    time_t *sec,
    long *usec,
    _PyTime_round_t);

/* Convert a number of seconds, int or float, to a timespec structure.
   nsec is in the range [0; 999999999] and rounded towards zero.
   For example, -1.2 is converted to (-2, 800000000). */
__declspec(dllimport) int _PyTime_ObjectToTimespec(
    PyObject *obj,
    time_t *sec,
    long *nsec,
    _PyTime_round_t);


/* Create a timestamp from a number of seconds. */
__declspec(dllimport) _PyTime_t _PyTime_FromSeconds(int seconds);

/* Macro to create a timestamp from a number of seconds, no integer overflow.
   Only use the macro for small values, prefer _PyTime_FromSeconds(). */



/* Create a timestamp from a number of nanoseconds. */
__declspec(dllimport) _PyTime_t _PyTime_FromNanoseconds(_PyTime_t ns);

/* Create a timestamp from nanoseconds (Python int). */
__declspec(dllimport) int _PyTime_FromNanosecondsObject(_PyTime_t *t,
    PyObject *obj);

/* Convert a number of seconds (Python float or int) to a timetamp.
   Raise an exception and return -1 on error, return 0 on success. */
__declspec(dllimport) int _PyTime_FromSecondsObject(_PyTime_t *t,
    PyObject *obj,
    _PyTime_round_t round);

/* Convert a number of milliseconds (Python float or int, 10^-3) to a timetamp.
   Raise an exception and return -1 on error, return 0 on success. */
__declspec(dllimport) int _PyTime_FromMillisecondsObject(_PyTime_t *t,
    PyObject *obj,
    _PyTime_round_t round);

/* Convert a timestamp to a number of seconds as a C double. */
__declspec(dllimport) double _PyTime_AsSecondsDouble(_PyTime_t t);

/* Convert timestamp to a number of milliseconds (10^-3 seconds). */
__declspec(dllimport) _PyTime_t _PyTime_AsMilliseconds(_PyTime_t t,
    _PyTime_round_t round);

/* Convert timestamp to a number of microseconds (10^-6 seconds). */
__declspec(dllimport) _PyTime_t _PyTime_AsMicroseconds(_PyTime_t t,
    _PyTime_round_t round);

/* Convert timestamp to a number of nanoseconds (10^-9 seconds) as a Python int
   object. */
__declspec(dllimport) PyObject * _PyTime_AsNanosecondsObject(_PyTime_t t);

/* Create a timestamp from a timeval structure.
   Raise an exception and return -1 on overflow, return 0 on success. */
__declspec(dllimport) int _PyTime_FromTimeval(_PyTime_t *tp, struct timeval *tv);

/* Convert a timestamp to a timeval structure (microsecond resolution).
   tv_usec is always positive.
   Raise an exception and return -1 if the conversion overflowed,
   return 0 on success. */
__declspec(dllimport) int _PyTime_AsTimeval(_PyTime_t t,
    struct timeval *tv,
    _PyTime_round_t round);

/* Similar to _PyTime_AsTimeval(), but don't raise an exception on error. */
__declspec(dllimport) int _PyTime_AsTimeval_noraise(_PyTime_t t,
    struct timeval *tv,
    _PyTime_round_t round);

/* Convert a timestamp to a number of seconds (secs) and microseconds (us).
   us is always positive. This function is similar to _PyTime_AsTimeval()
   except that secs is always a time_t type, whereas the timeval structure
   uses a C long for tv_sec on Windows.
   Raise an exception and return -1 if the conversion overflowed,
   return 0 on success. */
__declspec(dllimport) int _PyTime_AsTimevalTime_t(
    _PyTime_t t,
    time_t *secs,
    int *us,
    _PyTime_round_t round);












/* Compute ticks * mul / div.
   The caller must ensure that ((div - 1) * mul) cannot overflow. */
__declspec(dllimport) _PyTime_t _PyTime_MulDiv(_PyTime_t ticks,
    _PyTime_t mul,
    _PyTime_t div);

/* Get the current time from the system clock.

   The function cannot fail. _PyTime_Init() ensures that the system clock
   works. */
__declspec(dllimport) _PyTime_t _PyTime_GetSystemClock(void);

/* Get the time of a monotonic clock, i.e. a clock that cannot go backwards.
   The clock is not affected by system clock updates. The reference point of
   the returned value is undefined, so that only the difference between the
   results of consecutive calls is valid.

   The function cannot fail. _PyTime_Init() ensures that a monotonic clock
   is available and works. */
__declspec(dllimport) _PyTime_t _PyTime_GetMonotonicClock(void);


/* Structure used by time.get_clock_info() */
typedef struct {
    const char *implementation;
    int monotonic;
    int adjustable;
    double resolution;
} _Py_clock_info_t;

/* Get the current time from the system clock.
 * Fill clock information if info is not NULL.
 * Raise an exception and return -1 on error, return 0 on success.
 */
__declspec(dllimport) int _PyTime_GetSystemClockWithInfo(
    _PyTime_t *t,
    _Py_clock_info_t *info);

/* Get the time of a monotonic clock, i.e. a clock that cannot go backwards.
   The clock is not affected by system clock updates. The reference point of
   the returned value is undefined, so that only the difference between the
   results of consecutive calls is valid.

   Fill info (if set) with information of the function used to get the time.

   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int _PyTime_GetMonotonicClockWithInfo(
    _PyTime_t *t,
    _Py_clock_info_t *info);


/* Initialize time.
   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int _PyTime_Init(void);

/* Converts a timestamp to the Gregorian time, using the local time zone.
   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int _PyTime_localtime(time_t t, struct tm *tm);

/* Converts a timestamp to the Gregorian time, assuming UTC.
   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int _PyTime_gmtime(time_t t, struct tm *tm);

/* Get the performance counter: clock with the highest available resolution to
   measure a short duration.

   The function cannot fail. _PyTime_Init() ensures that the system clock
   works. */
__declspec(dllimport) _PyTime_t _PyTime_GetPerfCounter(void);

/* Get the performance counter: clock with the highest available resolution to
   measure a short duration.

   Fill info (if set) with information of the function used to get the time.

   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int _PyTime_GetPerfCounterWithInfo(
    _PyTime_t *t,
    _Py_clock_info_t *info);









/* The PyMem_ family:  low-level memory allocation interfaces.
   See objimpl.h for the PyObject_ memory family.
*/











__declspec(dllimport) void * PyMem_RawMalloc(size_t size);
__declspec(dllimport) void * PyMem_RawCalloc(size_t nelem, size_t elsize);
__declspec(dllimport) void * PyMem_RawRealloc(void *ptr, size_t new_size);
__declspec(dllimport) void PyMem_RawFree(void *ptr);

/* Configure the Python memory allocators. Pass NULL to use default
   allocators. */
__declspec(dllimport) int _PyMem_SetupAllocators(const char *opt);

/* Try to get the allocators name set by _PyMem_SetupAllocators(). */
__declspec(dllimport) const char* _PyMem_GetAllocatorsName(void);

/* Track an allocated memory block in the tracemalloc module.
   Return 0 on success, return -1 on error (failed to allocate memory to store
   the trace).

   Return -2 if tracemalloc is disabled.

   If memory block is already tracked, update the existing trace. */
__declspec(dllimport) int PyTraceMalloc_Track(
    unsigned int domain,
    uintptr_t ptr,
    size_t size);

/* Untrack an allocated memory block in the tracemalloc module.
   Do nothing if the block was not tracked.

   Return -2 if tracemalloc is disabled, otherwise return 0. */
__declspec(dllimport) int PyTraceMalloc_Untrack(
    unsigned int domain,
    uintptr_t ptr);

/* Get the traceback where a memory block was allocated.

   Return a tuple of (filename: str, lineno: int) tuples.

   Return None if the tracemalloc module is disabled or if the memory block
   is not tracked by tracemalloc.

   Raise an exception and return NULL on error. */
__declspec(dllimport) PyObject* _PyTraceMalloc_GetTraceback(
    unsigned int domain,
    uintptr_t ptr);



/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyMem_ with calls to the platform malloc/realloc/
   calloc/free.  For example, on Windows different DLLs may end up using
   different heaps, and if you use PyMem_Malloc you'll get the memory from the
   heap used by the Python DLL; it could be a disaster if you free()'ed that
   directly in your own extension.  Using PyMem_Free instead ensures Python
   can return the memory to the proper heap.  As another example, in
   PYMALLOC_DEBUG mode, Python wraps all calls to all PyMem_ and PyObject_
   memory functions in special debugging wrappers that add additional
   debugging info to dynamic memory blocks.  The system routines have no idea
   what to do with that stuff, and the Python wrappers have no idea what to do
   with raw blocks obtained directly by the system routines then.

   The GIL must be held when using these APIs.
*/

/*
 * Raw memory interface
 * ====================
 */

/* Functions

   Functions supplying platform-independent semantics for malloc/realloc/
   free.  These functions make sure that allocating 0 bytes returns a distinct
   non-NULL pointer (whenever possible -- if we're flat out of memory, NULL
   may be returned), even if the platform malloc and realloc don't.
   Returned pointers must be checked for NULL explicitly.  No action is
   performed on failure (no exception is set, no warning is printed, etc).
*/

__declspec(dllimport) void * PyMem_Malloc(size_t size);

__declspec(dllimport) void * PyMem_Calloc(size_t nelem, size_t elsize);

__declspec(dllimport) void * PyMem_Realloc(void *ptr, size_t new_size);
__declspec(dllimport) void PyMem_Free(void *ptr);


/* strdup() using PyMem_RawMalloc() */
__declspec(dllimport) char * _PyMem_RawStrdup(const char *str);

/* strdup() using PyMem_Malloc() */
__declspec(dllimport) char * _PyMem_Strdup(const char *str);

/* wcsdup() using PyMem_RawMalloc() */
__declspec(dllimport) wchar_t* _PyMem_RawWcsdup(const wchar_t *str);


/* Macros. */

/* PyMem_MALLOC(0) means malloc(1). Some systems would return NULL
   for malloc(0), which would be treated as an error. Some platforms
   would return a pointer with no memory behind it, which would break
   pymalloc. To solve these problems, allocate an extra byte. */
/* Returns NULL to indicate error if a negative size or size larger than
   Py_ssize_t can represent is supplied.  Helps prevents security holes. */




/*
 * Type-oriented memory interface
 * ==============================
 *
 * Allocate memory for n objects of the given type.  Returns a new pointer
 * or NULL if the request was too large or memory allocation failed.  Use
 * these macros rather than doing the multiplication yourself so that proper
 * overflow checking is always done.
 */








/*
 * The value of (p) is always clobbered by this macro regardless of success.
 * The caller MUST check if (p) is NULL afterwards and deal with the memory
 * error if so.  This means the original value of (p) MUST be saved for the
 * caller's memory error handler to not lose track of it.
 */







/* PyMem{Del,DEL} are left over from ancient days, and shouldn't be used
 * anymore.  They're just confusing aliases for PyMem_{Free,FREE} now.
 */




typedef enum {
    /* PyMem_RawMalloc(), PyMem_RawRealloc() and PyMem_RawFree() */
    PYMEM_DOMAIN_RAW,

    /* PyMem_Malloc(), PyMem_Realloc() and PyMem_Free() */
    PYMEM_DOMAIN_MEM,

    /* PyObject_Malloc(), PyObject_Realloc() and PyObject_Free() */
    PYMEM_DOMAIN_OBJ
} PyMemAllocatorDomain;

typedef struct {
    /* user context passed as the first argument to the 4 functions */
    void *ctx;

    /* allocate a memory block */
    void* (*malloc) (void *ctx, size_t size);

    /* allocate a memory block initialized by zeros */
    void* (*calloc) (void *ctx, size_t nelem, size_t elsize);

    /* allocate or resize a memory block */
    void* (*realloc) (void *ctx, void *ptr, size_t new_size);

    /* release a memory block */
    void (*free) (void *ctx, void *ptr);
} PyMemAllocatorEx;

/* Get the memory block allocator of the specified domain. */
__declspec(dllimport) void PyMem_GetAllocator(PyMemAllocatorDomain domain,
                                    PyMemAllocatorEx *allocator);

/* Set the memory block allocator of the specified domain.

   The new allocator must return a distinct non-NULL pointer when requesting
   zero bytes.

   For the PYMEM_DOMAIN_RAW domain, the allocator must be thread-safe: the GIL
   is not held when the allocator is called.

   If the new allocator is not a hook (don't call the previous allocator), the
   PyMem_SetupDebugHooks() function must be called to reinstall the debug hooks
   on top on the new allocator. */
__declspec(dllimport) void PyMem_SetAllocator(PyMemAllocatorDomain domain,
                                    PyMemAllocatorEx *allocator);

/* Setup hooks to detect bugs in the following Python memory allocator
   functions:

   - PyMem_RawMalloc(), PyMem_RawRealloc(), PyMem_RawFree()
   - PyMem_Malloc(), PyMem_Realloc(), PyMem_Free()
   - PyObject_Malloc(), PyObject_Realloc() and PyObject_Free()

   Newly allocated memory is filled with the byte 0xCB, freed memory is filled
   with the byte 0xDB. Additional checks:

   - detect API violations, ex: PyObject_Free() called on a buffer allocated
     by PyMem_Malloc()
   - detect write before the start of the buffer (buffer underflow)
   - detect write after the end of the buffer (buffer overflow)

   The function does nothing if Python is not compiled is debug mode. */
__declspec(dllimport) void PyMem_SetupDebugHooks(void);




















/* The PyObject_ memory family:  high-level object memory interfaces.
   See pymem.h for the low-level PyMem_ family.
*/










/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyObject_ memory functions with calls to the platform
   malloc/realloc/ calloc/free, or with calls to PyMem_.
*/

/*
Functions and macros for modules that implement new object types.

 - PyObject_New(type, typeobj) allocates memory for a new object of the given
   type, and initializes part of it.  'type' must be the C structure type used
   to represent the object, and 'typeobj' the address of the corresponding
   type object.  Reference count and type pointer are filled in; the rest of
   the bytes of the object are *undefined*!  The resulting expression type is
   'type *'.  The size of the object is determined by the tp_basicsize field
   of the type object.

 - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size
   object with room for n items.  In addition to the refcount and type pointer
   fields, this also fills in the ob_size field.

 - PyObject_Del(op) releases the memory allocated for an object.  It does not
   run a destructor -- it only frees the memory.  PyObject_Free is identical.

 - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't
   allocate memory.  Instead of a 'type' parameter, they take a pointer to a
   new object (allocated by an arbitrary allocator), and initialize its object
   header fields.

Note that objects created with PyObject_{New, NewVar} are allocated using the
specialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is
enabled.  In addition, a special debugging allocator is used if PYMALLOC_DEBUG
is also #defined.

In case a specific form of memory management is needed (for example, if you
must use the platform malloc heap(s), or shared memory, or C++ local storage or
operator new), you must first allocate the object with your custom allocator,
then pass its pointer to PyObject_{Init, InitVar} for filling in its Python-
specific fields:  reference count, type pointer, possibly others.  You should
be aware that Python has no control over these objects because they don't
cooperate with the Python memory manager.  Such objects may not be eligible
for automatic garbage collection and you have to make sure that they are
released accordingly whenever their destructor gets called (cf. the specific
form of memory management you're using).

Unless you have specific memory management requirements, use
PyObject_{New, NewVar, Del}.
*/

/*
 * Raw object memory interface
 * ===========================
 */

/* Functions to call the same malloc/realloc/free as used by Python's
   object allocator.  If WITH_PYMALLOC is enabled, these may differ from
   the platform malloc/realloc/free.  The Python object allocator is
   designed for fast, cache-conscious allocation of many "small" objects,
   and with low hidden memory overhead.

   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.

   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).
   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory
   at p.

   Returned pointers must be checked for NULL explicitly; no action is
   performed on failure other than to return NULL (no warning it printed, no
   exception is set, etc).

   For allocating objects, use PyObject_{New, NewVar} instead whenever
   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed
   so that you can exploit Python's small-block allocator for non-object
   uses.  If you must use these routines to allocate object memory, make sure
   the object gets initialized via PyObject_{Init, InitVar} after obtaining
   the raw memory.
*/
__declspec(dllimport) void * PyObject_Malloc(size_t size);

__declspec(dllimport) void * PyObject_Calloc(size_t nelem, size_t elsize);

__declspec(dllimport) void * PyObject_Realloc(void *ptr, size_t new_size);
__declspec(dllimport) void PyObject_Free(void *ptr);


/* This function returns the number of allocated memory blocks, regardless of size */
__declspec(dllimport) Py_ssize_t _Py_GetAllocatedBlocks(void);


/* Macros */


__declspec(dllimport) int _PyObject_DebugMallocStats(FILE *out);



/* Macros */







/*
 * Generic object allocator interface
 * ==================================
 */

/* Functions */
__declspec(dllimport) PyObject * PyObject_Init(PyObject *, PyTypeObject *);
__declspec(dllimport) PyVarObject * PyObject_InitVar(PyVarObject *,
                                                 PyTypeObject *, Py_ssize_t);
__declspec(dllimport) PyObject * _PyObject_New(PyTypeObject *);
__declspec(dllimport) PyVarObject * _PyObject_NewVar(PyTypeObject *, Py_ssize_t);






/* Macros trading binary compatibility for speed. See also pymem.h.
   Note that these macros expect non-NULL object pointers.*/







/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a
   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The
   value is rounded up to the closest multiple of sizeof(void *), in order to
   ensure that pointer fields at the end of the object are correctly aligned
   for the platform (this is of special importance for subclasses of, e.g.,
   str or int, so that pointers can be stored after the embedded data).

   Note that there's no memory wastage in doing this, as malloc has to
   return (at worst) pointer-aligned memory anyway.
*/


















/* This example code implements an object constructor with a custom
   allocator, where PyObject_New is inlined, and shows the important
   distinction between two steps (at least):
       1) the actual allocation of the object storage;
       2) the initialization of the Python specific fields
      in this storage with PyObject_{Init, InitVar}.

   PyObject *
   YourObject_New(...)
   {
       PyObject *op;

       op = (PyObject *) Your_Allocator(_PyObject_SIZE(YourTypeStruct));
       if (op == NULL)
       return PyErr_NoMemory();

       PyObject_Init(op, &YourTypeStruct);

       op->ob_field = value;
       ...
       return op;
   }

   Note that in C++, the use of the new operator usually implies that
   the 1st step is performed automatically for you, so in a C++ class
   constructor you would start directly with PyObject_Init/InitVar
*/


typedef struct {
    /* user context passed as the first argument to the 2 functions */
    void *ctx;

    /* allocate an arena of size bytes */
    void* (*alloc) (void *ctx, size_t size);

    /* free an arena */
    void (*free) (void *ctx, void *ptr, size_t size);
} PyObjectArenaAllocator;

/* Get the arena allocator. */
__declspec(dllimport) void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator);

/* Set the arena allocator. */
__declspec(dllimport) void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator);



/*
 * Garbage Collection Support
 * ==========================
 */

/* C equivalent of gc.collect() which ignores the state of gc.enabled. */
__declspec(dllimport) Py_ssize_t PyGC_Collect(void);


__declspec(dllimport) Py_ssize_t _PyGC_CollectNoFail(void);
__declspec(dllimport) Py_ssize_t _PyGC_CollectIfEnabled(void);


/* Test if a type has a GC head */


/* Test if an object has a GC head */



__declspec(dllimport) PyVarObject * _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);



/* GC information is stored BEFORE the object structure. */

typedef union _gc_head {
    struct {
        union _gc_head *gc_next;
        union _gc_head *gc_prev;
        Py_ssize_t gc_refs;
    } gc;
    double dummy;  /* force worst-case alignment */
} PyGC_Head;

extern PyGC_Head *_PyGC_generation0;



/* Bit 0 is set when tp_finalize is called */

/* The (N-1) most significant bits contain the gc state / refcount */

























/* Tell the GC to track this object.  NB: While the object is tracked the
 * collector it must be safe to call the ob_traverse method. */











/* Tell the GC to stop tracking this object.
 * gc_next doesn't need to be set to NULL, but doing so is a good
 * way to provoke memory errors if calling code is confused.
 */









/* True if the object is currently tracked by the GC. */



/* True if the object may be tracked by the GC in the future, or already is.
   This can be useful to implement some optimizations. */






__declspec(dllimport) PyObject * _PyObject_GC_Malloc(size_t size);
__declspec(dllimport) PyObject * _PyObject_GC_Calloc(size_t size);

__declspec(dllimport) PyObject * _PyObject_GC_New(PyTypeObject *);
__declspec(dllimport) PyVarObject * _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
__declspec(dllimport) void PyObject_GC_Track(void *);
__declspec(dllimport) void PyObject_GC_UnTrack(void *);
__declspec(dllimport) void PyObject_GC_Del(void *);







/* Utility macro to help write tp_traverse functions.
 * To use this macro, the tp_traverse function must name its arguments
 * "visit" and "arg".  This is intended to keep tp_traverse functions
 * looking as much alike as possible.
 */










/* Test if a type supports weak references */











/* Do not renumber the file; these numbers are part of the stable ABI. */
/* Disabled, see #10181 */
















































































/* New in 3.5 */











/* Helpers for hash functions */

__declspec(dllimport) Py_hash_t _Py_HashDouble(double);
__declspec(dllimport) Py_hash_t _Py_HashPointer(void*);
__declspec(dllimport) Py_hash_t _Py_HashBytes(const void*, Py_ssize_t);


/* Prime multiplier used in string and various other hashes. */


/* Parameters used for the numeric hash implementation.  See notes for
   _Py_HashDouble in Python/pyhash.c.  Numeric hashes are based on
   reduction modulo the prime 2**_PyHASH_BITS - 1. */













/* hash secret
 *
 * memory layout on 64 bit systems
 *   cccccccc cccccccc cccccccc  uc -- unsigned char[24]
 *   pppppppp ssssssss ........  fnv -- two Py_hash_t
 *   k0k0k0k0 k1k1k1k1 ........  siphash -- two uint64_t
 *   ........ ........ ssssssss  djbx33a -- 16 bytes padding + one Py_hash_t
 *   ........ ........ eeeeeeee  pyexpat XML hash salt
 *
 * memory layout on 32 bit systems
 *   cccccccc cccccccc cccccccc  uc
 *   ppppssss ........ ........  fnv -- two Py_hash_t
 *   k0k0k0k0 k1k1k1k1 ........  siphash -- two uint64_t (*)
 *   ........ ........ ssss....  djbx33a -- 16 bytes padding + one Py_hash_t
 *   ........ ........ eeee....  pyexpat XML hash salt
 *
 * (*) The siphash member may not be available on 32 bit platforms without
 *     an unsigned int64 data type.
 */

typedef union {
    /* ensure 24 bytes */
    unsigned char uc[24];
    /* two Py_hash_t for FNV */
    struct {
        Py_hash_t prefix;
        Py_hash_t suffix;
    } fnv;
    /* two uint64 for SipHash24 */
    struct {
        uint64_t k0;
        uint64_t k1;
    } siphash;
    /* a different (!) Py_hash_t for small string optimization */
    struct {
        unsigned char padding[16];
        Py_hash_t suffix;
    } djbx33a;
    struct {
        unsigned char padding[16];
        Py_hash_t hashsalt;
    } expat;
} _Py_HashSecret_t;
extern __declspec(dllimport) _Py_HashSecret_t _Py_HashSecret;







/* hash function definition */

typedef struct {
    Py_hash_t (*const hash)(const void *, Py_ssize_t);
    const char *name;
    const int hash_bits;
    const int seed_bits;
} PyHash_FuncDef;

__declspec(dllimport) PyHash_FuncDef* PyHash_GetFuncDef(void);



/* cutoff for small string DJBX33A optimization in range [1, cutoff).
 *
 * About 50% of the strings in a typical Python application are smaller than
 * 6 to 7 chars. However DJBX33A is vulnerable to hash collision attacks.
 * NEVER use DJBX33A for long strings!
 *
 * A Py_HASH_CUTOFF of 0 disables small string optimization. 32 bit platforms
 * should use a smaller cutoff because it is easier to create colliding
 * strings. A cutoff of 7 on 64bit platforms and 5 on 32bit platforms should
 * provide a decent safety margin.
 */







/* hash algorithm selection
 *
 * The values for Py_HASH_SIPHASH24 and Py_HASH_FNV are hard-coded in the
 * configure script.
 *
 * - FNV is available on all platforms and architectures.
 * - SIPHASH24 only works on plaforms that don't require aligned memory for integers.
 * - With EXTERNAL embedders can provide an alternative implementation with::
 *
 *     PyHash_FuncDef PyHash_Func = {...};
 *
 * XXX: Figure out __declspec() for extern PyHash_FuncDef.
 */



























/* These global variable are defined in pylifecycle.c */
/* XXX (ncoghlan): move these declarations to pylifecycle.h? */
extern __declspec(dllimport) int Py_DebugFlag;
extern __declspec(dllimport) int Py_VerboseFlag;
extern __declspec(dllimport) int Py_QuietFlag;
extern __declspec(dllimport) int Py_InteractiveFlag;
extern __declspec(dllimport) int Py_InspectFlag;
extern __declspec(dllimport) int Py_OptimizeFlag;
extern __declspec(dllimport) int Py_NoSiteFlag;
extern __declspec(dllimport) int Py_BytesWarningFlag;
extern __declspec(dllimport) int Py_FrozenFlag;
extern __declspec(dllimport) int Py_IgnoreEnvironmentFlag;
extern __declspec(dllimport) int Py_DontWriteBytecodeFlag;
extern __declspec(dllimport) int Py_NoUserSiteDirectory;
extern __declspec(dllimport) int Py_UnbufferedStdioFlag;
extern __declspec(dllimport) int Py_HashRandomizationFlag;
extern __declspec(dllimport) int Py_IsolatedFlag;


extern __declspec(dllimport) int Py_LegacyWindowsFSEncodingFlag;
extern __declspec(dllimport) int Py_LegacyWindowsStdioFlag;


/* this is a wrapper around getenv() that pays attention to
   Py_IgnoreEnvironmentFlag.  It should be used for getting variables like
   PYTHONPATH and PYTHONHOME from the environment */










/* ByteArray object interface */








//
// stdarg.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdarg.h> header.
//
#pragma once




__pragma(pack(push, 8))










__pragma(pack(pop))


/* Type PyByteArrayObject represents a mutable array of bytes.
 * The Python API is that of a sequence;
 * the bytes are mapped to ints in [0, 256).
 * Bytes are not characters; they may be used to encode characters.
 * The only way to go between bytes and str/unicode is via encoding
 * and decoding.
 * For the convenience of C programmers, the bytes type is considered
 * to contain a char pointer, not an unsigned char pointer.
 */

/* Object layout */

typedef struct {
    PyVarObject ob_base;
    Py_ssize_t ob_alloc; /* How many bytes allocated in ob_bytes */
    char *ob_bytes;      /* Physical backing buffer */
    char *ob_start;      /* Logical start inside ob_bytes */
    /* XXX(nnorwitz): should ob_exports be Py_ssize_t? */
    int ob_exports;      /* How many buffer exports */
} PyByteArrayObject;


/* Type object */
extern __declspec(dllimport) PyTypeObject PyByteArray_Type;
extern __declspec(dllimport) PyTypeObject PyByteArrayIter_Type;

/* Type check macros */



/* Direct API functions */
__declspec(dllimport) PyObject * PyByteArray_FromObject(PyObject *);
__declspec(dllimport) PyObject * PyByteArray_Concat(PyObject *, PyObject *);
__declspec(dllimport) PyObject * PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
__declspec(dllimport) Py_ssize_t PyByteArray_Size(PyObject *);
__declspec(dllimport) char * PyByteArray_AsString(PyObject *);
__declspec(dllimport) int PyByteArray_Resize(PyObject *, Py_ssize_t);

/* Macros, trading safety for speed */






extern __declspec(dllimport) char _PyByteArray_empty_string[];









/* Bytes (String) object interface */









/*
Type PyBytesObject represents a character string.  An extra zero byte is
reserved at the end to ensure it is zero-terminated, but a size is
present so strings with null bytes in them can be represented.  This
is an immutable object type.

There are functions to create new string objects, to test
an object for string-ness, and to get the
string value.  The latter function returns a null pointer
if the object is not of the proper type.
There is a variant that takes an explicit size as well as a
variant that assumes a zero-terminated string.  Note that none of the
functions should be applied to nil objects.
*/

/* Caching the hash (ob_shash) saves recalculation of a string's hash value.
   This significantly speeds up dict lookups. */


typedef struct {
    PyVarObject ob_base;
    Py_hash_t ob_shash;
    char ob_sval[1];

    /* Invariants:
     *     ob_sval contains space for 'ob_size+1' elements.
     *     ob_sval[ob_size] == 0.
     *     ob_shash is the hash of the string or -1 if not computed yet.
     */
} PyBytesObject;


extern __declspec(dllimport) PyTypeObject PyBytes_Type;
extern __declspec(dllimport) PyTypeObject PyBytesIter_Type;





__declspec(dllimport) PyObject * PyBytes_FromStringAndSize(const char *, Py_ssize_t);
__declspec(dllimport) PyObject * PyBytes_FromString(const char *);
__declspec(dllimport) PyObject * PyBytes_FromObject(PyObject *);
__declspec(dllimport) PyObject * PyBytes_FromFormatV(const char*, va_list)
                                ;
__declspec(dllimport) PyObject * PyBytes_FromFormat(const char*, ...)
                                ;
__declspec(dllimport) Py_ssize_t PyBytes_Size(PyObject *);
__declspec(dllimport) char * PyBytes_AsString(PyObject *);
__declspec(dllimport) PyObject * PyBytes_Repr(PyObject *, int);
__declspec(dllimport) void PyBytes_Concat(PyObject **, PyObject *);
__declspec(dllimport) void PyBytes_ConcatAndDel(PyObject **, PyObject *);

__declspec(dllimport) int _PyBytes_Resize(PyObject **, Py_ssize_t);
__declspec(dllimport) PyObject* _PyBytes_FormatEx(
    const char *format,
    Py_ssize_t format_len,
    PyObject *args,
    int use_bytearray);
__declspec(dllimport) PyObject* _PyBytes_FromHex(
    PyObject *string,
    int use_bytearray);

__declspec(dllimport) PyObject * PyBytes_DecodeEscape(const char *, Py_ssize_t,
                                            const char *, Py_ssize_t,
                                            const char *);

/* Helper for PyBytes_DecodeEscape that detects invalid escape chars. */
__declspec(dllimport) PyObject * _PyBytes_DecodeEscape(const char *, Py_ssize_t,
                                             const char *, Py_ssize_t,
                                             const char *,
                                             const char **);


/* Macro, trading safety for speed */






/* _PyBytes_Join(sep, x) is like sep.join(x).  sep must be PyBytesObject*,
   x must be an iterable object. */

__declspec(dllimport) PyObject * _PyBytes_Join(PyObject *sep, PyObject *x);


/* Provides access to the internal data buffer and size of a string
   object or the default encoded version of a Unicode object. Passing
   NULL as *len parameter will force the string buffer to be
   0-terminated (passing a string with embedded NULL characters will
   cause an exception).  */
__declspec(dllimport) int PyBytes_AsStringAndSize(
    PyObject *obj,      /* string or Unicode object */
    char **s,           /* pointer to buffer variable */
    Py_ssize_t *len     /* pointer to length variable or NULL
                           (only possible for 0-terminated
                           strings) */
    );

/* Using the current locale, insert the thousands grouping
   into the string pointed to by buffer.  For the argument descriptions,
   see Objects/stringlib/localeutil.h */

__declspec(dllimport) Py_ssize_t _PyBytes_InsertThousandsGroupingLocale(char *buffer,
                                                   Py_ssize_t n_buffer,
                                                   char *digits,
                                                   Py_ssize_t n_digits,
                                                   Py_ssize_t min_width);

/* Using explicit passed-in values, insert the thousands grouping
   into the string pointed to by buffer.  For the argument descriptions,
   see Objects/stringlib/localeutil.h */
__declspec(dllimport) Py_ssize_t _PyBytes_InsertThousandsGrouping(char *buffer,
                                                   Py_ssize_t n_buffer,
                                                   char *digits,
                                                   Py_ssize_t n_digits,
                                                   Py_ssize_t min_width,
                                                   const char *grouping,
                                                   const char *thousands_sep);


/* Flags used by string formatting */







/* The _PyBytesWriter structure is big: it contains an embedded "stack buffer".
   A _PyBytesWriter variable must be declared at the end of variables in a
   function to optimize the memory allocation on the stack. */
typedef struct {
    /* bytes, bytearray or NULL (when the small buffer is used) */
    PyObject *buffer;

    /* Number of allocated size. */
    Py_ssize_t allocated;

    /* Minimum number of allocated bytes,
       incremented by _PyBytesWriter_Prepare() */
    Py_ssize_t min_size;

    /* If non-zero, use a bytearray instead of a bytes object for buffer. */
    int use_bytearray;

    /* If non-zero, overallocate the buffer (default: 0).
       This flag must be zero if use_bytearray is non-zero. */
    int overallocate;

    /* Stack buffer */
    int use_small_buffer;
    char small_buffer[512];
} _PyBytesWriter;

/* Initialize a bytes writer

   By default, the overallocation is disabled. Set the overallocate attribute
   to control the allocation of the buffer. */
__declspec(dllimport) void _PyBytesWriter_Init(_PyBytesWriter *writer);

/* Get the buffer content and reset the writer.
   Return a bytes object, or a bytearray object if use_bytearray is non-zero.
   Raise an exception and return NULL on error. */
__declspec(dllimport) PyObject * _PyBytesWriter_Finish(_PyBytesWriter *writer,
    void *str);

/* Deallocate memory of a writer (clear its internal buffer). */
__declspec(dllimport) void _PyBytesWriter_Dealloc(_PyBytesWriter *writer);

/* Allocate the buffer to write size bytes.
   Return the pointer to the beginning of buffer data.
   Raise an exception and return NULL on error. */
__declspec(dllimport) void* _PyBytesWriter_Alloc(_PyBytesWriter *writer,
    Py_ssize_t size);

/* Ensure that the buffer is large enough to write *size* bytes.
   Add size to the writer minimum size (min_size attribute).

   str is the current pointer inside the buffer.
   Return the updated current pointer inside the buffer.
   Raise an exception and return NULL on error. */
__declspec(dllimport) void* _PyBytesWriter_Prepare(_PyBytesWriter *writer,
    void *str,
    Py_ssize_t size);

/* Resize the buffer to make it larger.
   The new buffer may be larger than size bytes because of overallocation.
   Return the updated current pointer inside the buffer.
   Raise an exception and return NULL on error.

   Note: size must be greater than the number of allocated bytes in the writer.

   This function doesn't use the writer minimum size (min_size attribute).

   See also _PyBytesWriter_Prepare().
   */
__declspec(dllimport) void* _PyBytesWriter_Resize(_PyBytesWriter *writer,
    void *str,
    Py_ssize_t size);

/* Write bytes.
   Raise an exception and return NULL on error. */
__declspec(dllimport) void* _PyBytesWriter_WriteBytes(_PyBytesWriter *writer,
    void *str,
    const void *bytes,
    Py_ssize_t size);













/*

Unicode implementation based on original code by Fredrik Lundh,
modified by Marc-Andre Lemburg (mal@lemburg.com) according to the
Unicode Integration Proposal. (See
http://www.egenix.com/files/python/unicode-proposal.txt).

Copyright (c) Corporation for National Research Initiatives.


 Original header:
 --------------------------------------------------------------------

 * Yet another Unicode string type for Python.  This type supports the
 * 16-bit Basic Multilingual Plane (BMP) only.
 *
 * Written by Fredrik Lundh, January 1999.
 *
 * Copyright (c) 1999 by Secret Labs AB.
 * Copyright (c) 1999 by Fredrik Lundh.
 *
 * fredrik@pythonware.com
 * http://www.pythonware.com
 *
 * --------------------------------------------------------------------
 * This Unicode String Type is
 *
 * Copyright (c) 1999 by Secret Labs AB
 * Copyright (c) 1999 by Fredrik Lundh
 *
 * By obtaining, using, and/or copying this software and/or its
 * associated documentation, you agree that you have read, understood,
 * and will comply with the following terms and conditions:
 *
 * Permission to use, copy, modify, and distribute this software and its
 * associated documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appears in all
 * copies, and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Secret Labs
 * AB or the author not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.
 *
 * SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * -------------------------------------------------------------------- */


//
// ctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the narrow character (char) classification functionality.
//
#pragma once





//
// corecrt_wctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) classification functionality,
// shared by <ctype.h>, <wchar.h>, and <wctype.h>.
//
#pragma once



__pragma(pack(push, 8))







// This declaration allows the user access to the ctype look-up
// array _ctype defined in ctype.obj by simply including ctype.h


    


        
    

     const unsigned short* __cdecl __pctype_func(void);
     const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    


// Bit masks for the possible character types














//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Classification and Conversion Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   int __cdecl iswalnum  (  wint_t _C);
   int __cdecl iswalpha  (  wint_t _C);
   int __cdecl iswascii  (  wint_t _C);
   int __cdecl iswblank  (  wint_t _C);
   int __cdecl iswcntrl  (  wint_t _C);


   int __cdecl iswdigit  (  wint_t _C);

   int __cdecl iswgraph  (  wint_t _C);
   int __cdecl iswlower  (  wint_t _C);
   int __cdecl iswprint  (  wint_t _C);
   int __cdecl iswpunct  (  wint_t _C);
   int __cdecl iswspace  (  wint_t _C);
   int __cdecl iswupper  (  wint_t _C);
   int __cdecl iswxdigit (  wint_t _C);
   int __cdecl __iswcsymf(  wint_t _C);
   int __cdecl __iswcsym (  wint_t _C);

   int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


   wint_t __cdecl towupper(  wint_t _C);
   wint_t __cdecl towlower(  wint_t _C);
   int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

   wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
   wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
   int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



       int __cdecl isleadbyte(  int _C);
       int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details."))  int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Macro and Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    

        
        
        
        
        
        
        
        
        
        
        
        
        

        
        
        
        
        
        
        
        
        
        
        
        

        
            
        

    
// CRT_REFACTOR TODO I've had to remove the inline function definitions because
// they break the debugger build.  These were moved here from <wctype.h> in
// C968560.  We need to figure out what is wrong.
//#else
//    #ifndef _CTYPE_DISABLE_MACROS
//        inline int __cdecl iswalpha (_In_ wint_t _C) { return iswctype(_C, _ALPHA); }
//        inline int __cdecl iswupper (_In_ wint_t _C) { return iswctype(_C, _UPPER); }
//        inline int __cdecl iswlower (_In_ wint_t _C) { return iswctype(_C, _LOWER); }
//        inline int __cdecl iswdigit (_In_ wint_t _C) { return iswctype(_C, _DIGIT); }
//        inline int __cdecl iswxdigit(_In_ wint_t _C) { return iswctype(_C, _HEX); }
//        inline int __cdecl iswspace (_In_ wint_t _C) { return iswctype(_C, _SPACE); }
//        inline int __cdecl iswpunct (_In_ wint_t _C) { return iswctype(_C, _PUNCT); }
//        inline int __cdecl iswblank (_In_ wint_t _C) { return (((_C) == '\t') ? _BLANK : iswctype(_C,_BLANK)); }
//        inline int __cdecl iswalnum (_In_ wint_t _C) { return iswctype(_C, _ALPHA | _DIGIT); }
//        inline int __cdecl iswprint (_In_ wint_t _C) { return iswctype(_C, _BLANK | _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl iswgraph (_In_ wint_t _C) { return iswctype(_C, _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl iswcntrl (_In_ wint_t _C) { return iswctype(_C, _CONTROL); }
//        inline int __cdecl iswascii (_In_ wint_t _C) { return (unsigned)(_C) < 0x80; }
//
//        inline int __cdecl _iswalpha_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _ALPHA); }
//        inline int __cdecl _iswupper_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _UPPER); }
//        inline int __cdecl _iswlower_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _LOWER); }
//        inline int __cdecl _iswdigit_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _DIGIT); }
//        inline int __cdecl _iswxdigit_l(_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _HEX); }
//        inline int __cdecl _iswspace_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _SPACE); }
//        inline int __cdecl _iswpunct_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _PUNCT); }
//        inline int __cdecl _iswblank_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _BLANK); }
//        inline int __cdecl _iswalnum_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _ALPHA | _DIGIT); }
//        inline int __cdecl _iswprint_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _BLANK | _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl _iswgraph_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl _iswcntrl_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _CONTROL); }
//
//        #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
//        inline int __cdecl isleadbyte(_In_ int _C)
//        {
//            return __pctype_func()[(unsigned char)(_C)] & _LEADBYTE;
//        }
//        #endif
//    #endif




__pragma(pack(pop))


__pragma(pack(push, 8))




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Function Declarations
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   int __cdecl _isctype(  int _C,   int _Type);
   int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
    int __cdecl isalpha(  int _C);
   int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
    int __cdecl isupper(  int _C);
   int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
    int __cdecl islower(  int _C);
   int __cdecl _islower_l(  int _C,   _locale_t _Locale);


    int __cdecl isdigit(  int _C);

   int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
   int __cdecl isxdigit(  int _C);
   int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);


    int __cdecl isspace(  int _C);

   int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
   int __cdecl ispunct(  int _C);
   int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
   int __cdecl isblank(  int _C);
   int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
    int __cdecl isalnum(  int _C);
   int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
   int __cdecl isprint(  int _C);
   int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
   int __cdecl isgraph(  int _C);
   int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
   int __cdecl iscntrl(  int _C);
   int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);


    int __cdecl toupper(  int _C);


    int __cdecl tolower(  int _C);

    int __cdecl _tolower(  int _C);
   int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
    int __cdecl _toupper(  int _C);
   int __cdecl _toupper_l(  int _C,   _locale_t _Locale);

   int __cdecl __isascii(  int _C);
   int __cdecl __toascii(  int _C);
   int __cdecl __iscsymf(  int _C);
   int __cdecl __iscsym(  int _C);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Macro Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
__inline int __cdecl __acrt_locale_get_ctype_array_value(
      unsigned short const * const _Locale_pctype_array,
              int                    const _Char_value,
                             int                    const _Mask
    )
{
    // The C Standard specifies valid input to a ctype function ranges from -1 to 255.
    // To avoid undefined behavior, we should check this range for all accesses.
    // Note _locale_pctype array does extend to -127 to support accessing
    // _pctype directly with signed chars.
    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }

    return 0;
}



    // Maximum number of bytes in multi-byte character in the current locale
    // (also defined in stdlib.h).
    




















    // In the debug CRT, we make all calls through the validation function to catch
    // invalid integer inputs that yield undefined behavior.
    




        
    



    
    
    
    







        __forceinline int __cdecl __ascii_tolower(int const _C)
        {
            if (_C >= 'A' && _C <= 'Z')
            {
                return _C - ('A' - 'a');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_toupper(int const _C)
        {
            if (_C >= 'a' && _C <= 'z')
            {
                return _C - ('a' - 'A');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_iswalpha(int const _C)
        {
            return (_C >= 'A' && _C <= 'Z') || (_C >= 'a' && _C <= 'z');
        }

        __forceinline int __cdecl __ascii_iswdigit(int const _C)
        {
            return _C >= '0' && _C <= '9';
        }

        __forceinline int __cdecl __ascii_towlower(int const _C)
        {
            return __ascii_tolower(_C);
        }

        __forceinline int __cdecl __ascii_towupper(int const _C)
        {
            return __ascii_toupper(_C);
        }
    



    














    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    



    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        


        if (_Locale)
        {
            return __acrt_locale_get_ctype_array_value(__acrt_get_locale_data_prefix(_Locale)->_locale_pctype, _C, _Mask);
        }

        return (__acrt_locale_get_ctype_array_value(__pctype_func(), (_C), (_Mask)));
        
    }

    
    

    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale) {
            if (_C >= -1 && _C <= 255)
            {
                return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
            }

            if (__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
            {
                return _isctype_l(_C, _Mask, _Locale);
            }

            return 0; // >0xFF and SBCS locale
        }

        return _chvalidchk_l(_C, _Mask, 0);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    // Microsoft C version 2.0 extended ctype macros
    
    
    
    

    
    
    
    





    
    
    
    





__pragma(pack(pop))



/* === Internal API ======================================================= */

/* --- Internal Unicode Format -------------------------------------------- */

/* Python 3.x requires unicode */








/* If wchar_t can be used for UCS-4 storage, set Py_UNICODE_WIDE.
   Otherwise, Unicode strings are stored as UCS-2 (with limited support
   for UTF-16) */





/* Set these flags if the platform has "wchar.h" and the
   wchar_t type is a 16-bit unsigned type */
/* #define HAVE_WCHAR_H */
/* #define HAVE_USABLE_WCHAR_T */

/* Py_UNICODE was the native Unicode storage format (code unit) used by
   Python and represents a single Unicode element in the Unicode type.
   With PEP 393, Py_UNICODE is deprecated and replaced with a
   typedef to wchar_t. */



typedef wchar_t Py_UNICODE /* Py_DEPRECATED(3.3) */;


/* If the compiler provides a wchar_t type we try to support it
   through the interface functions PyUnicode_FromWideChar(),
   PyUnicode_AsWideChar() and PyUnicode_AsWideCharString(). */









//
// wchar.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// All of the types, macros, and function declarations for all wide-character
// related functionality.  Most of the functionality is in the #included
// <corecrt_wxxxx.h> headers, which are also #included by other public headers.
//
#pragma once






//
// corecrt_wconio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) console I/O functionality,
// shared by both <conio.h> and <wchar.h>
//
#pragma once




__pragma(pack(push, 8))









    
     
     errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    


    
     int __cdecl _cputws(
          wchar_t const* _Buffer
        );

           wint_t __cdecl _getwch  (void);
           wint_t __cdecl _getwche (void);
      wint_t __cdecl _putwch  (  wchar_t _Character);
      wint_t __cdecl _ungetwch(  wint_t  _Character);

           wint_t __cdecl _getwch_nolock  (void);
           wint_t __cdecl _getwche_nolock (void);
      wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
      wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (Console)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
     int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )



    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vcwprintf_l(_Format, ((void *)0), _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )



    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vcwprintf_s_l(_Format, ((void *)0), _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )



    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vcwprintf_p_l(_Format, ((void *)0), _ArgList);
    }


    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vcwprintf_l(_Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vcwprintf_s_l(_Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vcwprintf_p_l(_Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (Console)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
     int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }


     
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )



    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, ((void *)0), _ArgList);
        #pragma warning(pop)
    }


    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )



    {
        return _vcwscanf_s_l(_Format, ((void *)0), _ArgList);
    }


     
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


     
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, ((void *)0), _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Locale)));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__va_start(&_ArgList, _Format)));
        _Result = _vcwscanf_s_l(_Format, ((void *)0), _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }






__pragma(pack(pop))



//
// corecrt_wdirect.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) directory functionality, shared
// by <direct.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8))






 
   
 __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
 __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
 int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
 int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
 int __cdecl _wrmdir(
      wchar_t const* _Path
    );



__pragma(pack(pop))



//
// corecrt_wprocess.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) process functionality, shared
// by <process.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8))




    

         intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         int __cdecl _wsystem(
              wchar_t const* _Command
            );

    




__pragma(pack(pop))









__pragma(pack(push, 8))








typedef wchar_t _Wint_t;





        
     wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
     _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



     wint_t __cdecl btowc(
          int _Ch
        );

     size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
     errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    


       size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);


     
     errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    


      size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);


     
     errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    


      size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);


     int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == ((void *)0) || _P->_Wchar == 0;
    }

    __inline wchar_t * __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t *)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

















__pragma(pack(pop))




/* Py_UCS4 and Py_UCS2 are typedefs for the respective
   unicode representations. */
typedef uint32_t Py_UCS4;
typedef uint16_t Py_UCS2;
typedef uint8_t Py_UCS1;

/* --- Internal Unicode Operations ---------------------------------------- */

/* Since splitting on whitespace is an important use case, and
   whitespace in most situations is solely ASCII whitespace, we
   optimize for the common case by using a quick look-up table
   _Py_ascii_whitespace (see below) with an inlined check.

 */






































/* macros to work with surrogates */



/* Join two surrogate characters and return a single Py_UCS4 value. */



/* high surrogate = top 10 bits added to D800 */

/* low surrogate = bottom 10 bits added to DC00 */


/* Check if substring matches at given offset.  The offset must be
   valid, and the substring must not be empty. */












/* --- Unicode Type ------------------------------------------------------- */



/* ASCII-only strings created through PyUnicode_New use the PyASCIIObject
   structure. state.ascii and state.compact are set, and the data
   immediately follow the structure. utf8_length and wstr_length can be found
   in the length field; the utf8 pointer is equal to the data pointer. */
typedef struct {
    /* There are 4 forms of Unicode strings:

       - compact ascii:

         * structure = PyASCIIObject
         * test: PyUnicode_IS_COMPACT_ASCII(op)
         * kind = PyUnicode_1BYTE_KIND
         * compact = 1
         * ascii = 1
         * ready = 1
         * (length is the length of the utf8 and wstr strings)
         * (data starts just after the structure)
         * (since ASCII is decoded from UTF-8, the utf8 string are the data)

       - compact:

         * structure = PyCompactUnicodeObject
         * test: PyUnicode_IS_COMPACT(op) && !PyUnicode_IS_ASCII(op)
         * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or
           PyUnicode_4BYTE_KIND
         * compact = 1
         * ready = 1
         * ascii = 0
         * utf8 is not shared with data
         * utf8_length = 0 if utf8 is NULL
         * wstr is shared with data and wstr_length=length
           if kind=PyUnicode_2BYTE_KIND and sizeof(wchar_t)=2
           or if kind=PyUnicode_4BYTE_KIND and sizeof(wchar_t)=4
         * wstr_length = 0 if wstr is NULL
         * (data starts just after the structure)

       - legacy string, not ready:

         * structure = PyUnicodeObject
         * test: kind == PyUnicode_WCHAR_KIND
         * length = 0 (use wstr_length)
         * hash = -1
         * kind = PyUnicode_WCHAR_KIND
         * compact = 0
         * ascii = 0
         * ready = 0
         * interned = SSTATE_NOT_INTERNED
         * wstr is not NULL
         * data.any is NULL
         * utf8 is NULL
         * utf8_length = 0

       - legacy string, ready:

         * structure = PyUnicodeObject structure
         * test: !PyUnicode_IS_COMPACT(op) && kind != PyUnicode_WCHAR_KIND
         * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or
           PyUnicode_4BYTE_KIND
         * compact = 0
         * ready = 1
         * data.any is not NULL
         * utf8 is shared and utf8_length = length with data.any if ascii = 1
         * utf8_length = 0 if utf8 is NULL
         * wstr is shared with data.any and wstr_length = length
           if kind=PyUnicode_2BYTE_KIND and sizeof(wchar_t)=2
           or if kind=PyUnicode_4BYTE_KIND and sizeof(wchar_4)=4
         * wstr_length = 0 if wstr is NULL

       Compact strings use only one memory block (structure + characters),
       whereas legacy strings use one block for the structure and one block
       for characters.

       Legacy strings are created by PyUnicode_FromUnicode() and
       PyUnicode_FromStringAndSize(NULL, size) functions. They become ready
       when PyUnicode_READY() is called.

       See also _PyUnicode_CheckConsistency().
    */
    PyObject ob_base;
    Py_ssize_t length;          /* Number of code points in the string */
    Py_hash_t hash;             /* Hash value; -1 if not set */
    struct {
        /*
           SSTATE_NOT_INTERNED (0)
           SSTATE_INTERNED_MORTAL (1)
           SSTATE_INTERNED_IMMORTAL (2)

           If interned != SSTATE_NOT_INTERNED, the two references from the
           dictionary to this object are *not* counted in ob_refcnt.
         */
        unsigned int interned:2;
        /* Character size:

           - PyUnicode_WCHAR_KIND (0):

             * character type = wchar_t (16 or 32 bits, depending on the
               platform)

           - PyUnicode_1BYTE_KIND (1):

             * character type = Py_UCS1 (8 bits, unsigned)
             * all characters are in the range U+0000-U+00FF (latin1)
             * if ascii is set, all characters are in the range U+0000-U+007F
               (ASCII), otherwise at least one character is in the range
               U+0080-U+00FF

           - PyUnicode_2BYTE_KIND (2):

             * character type = Py_UCS2 (16 bits, unsigned)
             * all characters are in the range U+0000-U+FFFF (BMP)
             * at least one character is in the range U+0100-U+FFFF

           - PyUnicode_4BYTE_KIND (4):

             * character type = Py_UCS4 (32 bits, unsigned)
             * all characters are in the range U+0000-U+10FFFF
             * at least one character is in the range U+10000-U+10FFFF
         */
        unsigned int kind:3;
        /* Compact is with respect to the allocation scheme. Compact unicode
           objects only require one memory block while non-compact objects use
           one block for the PyUnicodeObject struct and another for its data
           buffer. */
        unsigned int compact:1;
        /* The string only contains characters in the range U+0000-U+007F (ASCII)
           and the kind is PyUnicode_1BYTE_KIND. If ascii is set and compact is
           set, use the PyASCIIObject structure. */
        unsigned int ascii:1;
        /* The ready flag indicates whether the object layout is initialized
           completely. This means that this is either a compact object, or
           the data pointer is filled out. The bit is redundant, and helps
           to minimize the test in PyUnicode_IS_READY(). */
        unsigned int ready:1;
        /* Padding to ensure that PyUnicode_DATA() is always aligned to
           4 bytes (see issue #19537 on m68k). */
        unsigned int :24;
    } state;
    wchar_t *wstr;              /* wchar_t representation (null-terminated) */
} PyASCIIObject;

/* Non-ASCII strings allocated through PyUnicode_New use the
   PyCompactUnicodeObject structure. state.compact is set, and the data
   immediately follow the structure. */
typedef struct {
    PyASCIIObject _base;
    Py_ssize_t utf8_length;     /* Number of bytes in utf8, excluding the
                                 * terminating \0. */
    char *utf8;                 /* UTF-8 representation (null-terminated) */
    Py_ssize_t wstr_length;     /* Number of code points in wstr, possible
                                 * surrogates count as two code points. */
} PyCompactUnicodeObject;

/* Strings allocated through PyUnicode_FromUnicode(NULL, len) use the
   PyUnicodeObject structure. The actual string data is initially in the wstr
   block, and copied into the data block using _PyUnicode_Ready. */
typedef struct {
    PyCompactUnicodeObject _base;
    union {
        void *any;
        Py_UCS1 *latin1;
        Py_UCS2 *ucs2;
        Py_UCS4 *ucs4;
    } data;                     /* Canonical, smallest-form Unicode buffer */
} PyUnicodeObject;


extern __declspec(dllimport) PyTypeObject PyUnicode_Type;
extern __declspec(dllimport) PyTypeObject PyUnicodeIter_Type;





/* Fast access macros */







/* Returns the deprecated Py_UNICODE representation's size in code units
   (this includes surrogate pairs as 2 units).
   If the Py_UNICODE representation is not available, it will be computed
   on request.  Use PyUnicode_GET_LENGTH() for the length in code points. */








    /* Py_DEPRECATED(3.3) */



    /* Py_DEPRECATED(3.3) */

/* Alias for PyUnicode_AsUnicode().  This will create a wchar_t/Py_UNICODE
   representation on demand.  Using this macro is very inefficient now,
   try to port your code to use the new PyUnicode_*BYTE_DATA() macros or
   use PyUnicode_WRITE() and PyUnicode_READ(). */





    /* Py_DEPRECATED(3.3) */



    /* Py_DEPRECATED(3.3) */


/* --- Flexible String Representation Helper Macros (PEP 393) -------------- */

/* Values for PyASCIIObject.state: */

/* Interning state. */




/* Return true if the string contains only ASCII characters, or 0 if not. The
   string may be compact (PyUnicode_IS_COMPACT_ASCII) or not, but must be
   ready. */





/* Return true if the string is compact or 0 if not.
   No type checks or Ready calls are performed. */



/* Return true if the string is a compact ASCII string (use PyASCIIObject
   structure), or 0 if not.  No type checks or Ready calls are performed. */



enum PyUnicode_Kind {
/* String contains only wstr byte characters.  This is only possible
   when the string was created with a legacy API and _PyUnicode_Ready()
   has not been called yet.  */
    PyUnicode_WCHAR_KIND = 0,
/* Return values of the PyUnicode_KIND() macro: */
    PyUnicode_1BYTE_KIND = 1,
    PyUnicode_2BYTE_KIND = 2,
    PyUnicode_4BYTE_KIND = 4
};

/* Return pointers to the canonical representation cast to unsigned char,
   Py_UCS2, or Py_UCS4 for direct character access.
   No checks are performed, use PyUnicode_KIND() before to ensure
   these will work correctly. */





/* Return one of the PyUnicode_*_KIND values defined above. */





/* Return a void pointer to the raw unicode buffer. */














/* In the access macros below, "kind" may be evaluated more than once.
   All other macro parameters are evaluated exactly once, so it is safe
   to put side effects into them (such as increasing the index). */

/* Write into the canonical representation, this macro does not do any sanity
   checks and is intended for usage in loops.  The caller should cache the
   kind and data pointers obtained from other macro calls.
   index is the index in the string (starts at 0) and value is the new
   code point value which should be written to that location. */


















/* Read a code point from the string's canonical representation.  No checks
   or ready calls are performed. */










/* PyUnicode_READ_CHAR() is less efficient than PyUnicode_READ() because it
   calls PyUnicode_KIND() and might call it twice.  For single reads, use
   PyUnicode_READ_CHAR, for multiple consecutive reads callers should
   cache kind and use PyUnicode_READ instead. */












/* Returns the length of the unicode string. The caller has to make sure that
   the string has it's canonical representation set before calling
   this macro.  Call PyUnicode_(FAST_)Ready to ensure that. */






/* Fast check to determine whether an object is ready. Equivalent to
   PyUnicode_IS_COMPACT(op) || ((PyUnicodeObject*)(op))->data.any) */



/* PyUnicode_READY() does less work than _PyUnicode_Ready() in the best
   case.  If the canonical representation is not yet set, it will still call
   _PyUnicode_Ready().
   Returns 0 on success and -1 on errors. */





/* Return a maximum character value which is suitable for creating another
   string based on op.  This is always an approximation but more efficient
   than iterating over the string. */












/* --- Constants ---------------------------------------------------------- */

/* This Unicode character will be used as replacement character during
   decoding if the errors argument is set to "replace". Note: the
   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
   Unicode 3.0. */



/* === Public API ========================================================= */

/* --- Plain Py_UNICODE --------------------------------------------------- */

/* With PEP 393, this is the recommended way to allocate a new unicode object.
   This function will allocate the object and its buffer in a single memory
   block.  Objects created using this function are not resizable. */

__declspec(dllimport) PyObject* PyUnicode_New(
    Py_ssize_t size,            /* Number of code points in the new string */
    Py_UCS4 maxchar             /* maximum code point value in the string */
    );


/* Initializes the canonical string representation from the deprecated
   wstr/Py_UNICODE representation. This function is used to convert Unicode
   objects which were created using the old API to the new flexible format
   introduced with PEP 393.

   Don't call this function directly, use the public PyUnicode_READY() macro
   instead. */

__declspec(dllimport) int _PyUnicode_Ready(
    PyObject *unicode           /* Unicode object */
    );


/* Get a copy of a Unicode string. */

__declspec(dllimport) PyObject* _PyUnicode_Copy(
    PyObject *unicode
    );


/* Copy character from one unicode object into another, this function performs
   character conversion when necessary and falls back to memcpy() if possible.

   Fail if to is too small (smaller than *how_many* or smaller than
   len(from)-from_start), or if kind(from[from_start:from_start+how_many]) >
   kind(to), or if *to* has more than 1 reference.

   Return the number of written character, or return -1 and raise an exception
   on error.

   Pseudo-code:

       how_many = min(how_many, len(from) - from_start)
       to[to_start:to_start+how_many] = from[from_start:from_start+how_many]
       return how_many

   Note: The function doesn't write a terminating null character.
   */

__declspec(dllimport) Py_ssize_t PyUnicode_CopyCharacters(
    PyObject *to,
    Py_ssize_t to_start,
    PyObject *from,
    Py_ssize_t from_start,
    Py_ssize_t how_many
    );

/* Unsafe version of PyUnicode_CopyCharacters(): don't check arguments and so
   may crash if parameters are invalid (e.g. if the output string
   is too short). */
__declspec(dllimport) void _PyUnicode_FastCopyCharacters(
    PyObject *to,
    Py_ssize_t to_start,
    PyObject *from,
    Py_ssize_t from_start,
    Py_ssize_t how_many
    );



/* Fill a string with a character: write fill_char into
   unicode[start:start+length].

   Fail if fill_char is bigger than the string maximum character, or if the
   string has more than 1 reference.

   Return the number of written character, or return -1 and raise an exception
   on error. */
__declspec(dllimport) Py_ssize_t PyUnicode_Fill(
    PyObject *unicode,
    Py_ssize_t start,
    Py_ssize_t length,
    Py_UCS4 fill_char
    );

/* Unsafe version of PyUnicode_Fill(): don't check arguments and so may crash
   if parameters are invalid (e.g. if length is longer than the string). */
__declspec(dllimport) void _PyUnicode_FastFill(
    PyObject *unicode,
    Py_ssize_t start,
    Py_ssize_t length,
    Py_UCS4 fill_char
    );


/* Create a Unicode Object from the Py_UNICODE buffer u of the given
   size.

   u may be NULL which causes the contents to be undefined. It is the
   user's responsibility to fill in the needed data afterwards. Note
   that modifying the Unicode object contents after construction is
   only allowed if u was set to NULL.

   The buffer is copied into the new object. */


__declspec(dllimport) PyObject* PyUnicode_FromUnicode(
    const Py_UNICODE *u,        /* Unicode buffer */
    Py_ssize_t size             /* size of buffer */
    ) /* Py_DEPRECATED(3.3) */;


/* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */
__declspec(dllimport) PyObject* PyUnicode_FromStringAndSize(
    const char *u,             /* UTF-8 encoded string */
    Py_ssize_t size            /* size of buffer */
    );

/* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
   UTF-8 encoded bytes.  The size is determined with strlen(). */
__declspec(dllimport) PyObject* PyUnicode_FromString(
    const char *u              /* UTF-8 encoded string */
    );


/* Create a new string from a buffer of Py_UCS1, Py_UCS2 or Py_UCS4 characters.
   Scan the string to find the maximum character. */
__declspec(dllimport) PyObject* PyUnicode_FromKindAndData(
    int kind,
    const void *buffer,
    Py_ssize_t size);

/* Create a new string from a buffer of ASCII characters.
   WARNING: Don't check if the string contains any non-ASCII character. */
__declspec(dllimport) PyObject* _PyUnicode_FromASCII(
    const char *buffer,
    Py_ssize_t size);



__declspec(dllimport) PyObject* PyUnicode_Substring(
    PyObject *str,
    Py_ssize_t start,
    Py_ssize_t end);



/* Compute the maximum character of the substring unicode[start:end].
   Return 127 for an empty string. */
__declspec(dllimport) Py_UCS4 _PyUnicode_FindMaxChar (
    PyObject *unicode,
    Py_ssize_t start,
    Py_ssize_t end);



/* Copy the string into a UCS4 buffer including the null character if copy_null
   is set. Return NULL and raise an exception on error. Raise a SystemError if
   the buffer is smaller than the string. Return buffer on success.

   buflen is the length of the buffer in (Py_UCS4) characters. */
__declspec(dllimport) Py_UCS4* PyUnicode_AsUCS4(
    PyObject *unicode,
    Py_UCS4* buffer,
    Py_ssize_t buflen,
    int copy_null);

/* Copy the string into a UCS4 buffer. A new buffer is allocated using
 * PyMem_Malloc; if this fails, NULL is returned with a memory error
   exception set. */
__declspec(dllimport) Py_UCS4* PyUnicode_AsUCS4Copy(PyObject *unicode);



/* Return a read-only pointer to the Unicode object's internal
   Py_UNICODE buffer.
   If the wchar_t/Py_UNICODE representation is not yet available, this
   function will calculate it. */

__declspec(dllimport) Py_UNICODE * PyUnicode_AsUnicode(
    PyObject *unicode           /* Unicode object */
    ) /* Py_DEPRECATED(3.3) */;

/* Similar to PyUnicode_AsUnicode(), but raises a ValueError if the string
   contains null characters. */
__declspec(dllimport) const Py_UNICODE * _PyUnicode_AsUnicode(
    PyObject *unicode           /* Unicode object */
    );

/* Return a read-only pointer to the Unicode object's internal
   Py_UNICODE buffer and save the length at size.
   If the wchar_t/Py_UNICODE representation is not yet available, this
   function will calculate it. */

__declspec(dllimport) Py_UNICODE * PyUnicode_AsUnicodeAndSize(
    PyObject *unicode,          /* Unicode object */
    Py_ssize_t *size            /* location where to save the length */
    )  /* Py_DEPRECATED(3.3) */;



/* Get the length of the Unicode object. */

__declspec(dllimport) Py_ssize_t PyUnicode_GetLength(
    PyObject *unicode
);


/* Get the number of Py_UNICODE units in the
   string representation. */

__declspec(dllimport) Py_ssize_t PyUnicode_GetSize(
    PyObject *unicode           /* Unicode object */
    ) ;


/* Read a character from the string. */

__declspec(dllimport) Py_UCS4 PyUnicode_ReadChar(
    PyObject *unicode,
    Py_ssize_t index
    );

/* Write a character to the string. The string must have been created through
   PyUnicode_New, must not be shared, and must not have been hashed yet.

   Return 0 on success, -1 on error. */

__declspec(dllimport) int PyUnicode_WriteChar(
    PyObject *unicode,
    Py_ssize_t index,
    Py_UCS4 character
    );



/* Get the maximum ordinal for a Unicode character. */
__declspec(dllimport) Py_UNICODE PyUnicode_GetMax(void) ;


/* Resize a Unicode object. The length is the number of characters, except
   if the kind of the string is PyUnicode_WCHAR_KIND: in this case, the length
   is the number of Py_UNICODE characters.

   *unicode is modified to point to the new (resized) object and 0
   returned on success.

   Try to resize the string in place (which is usually faster than allocating
   a new string and copy characters), or create a new string.

   Error handling is implemented as follows: an exception is set, -1
   is returned and *unicode left untouched.

   WARNING: The function doesn't check string content, the result may not be a
            string in canonical representation. */

__declspec(dllimport) int PyUnicode_Resize(
    PyObject **unicode,         /* Pointer to the Unicode object */
    Py_ssize_t length           /* New length */
    );

/* Decode obj to a Unicode object.

   bytes, bytearray and other bytes-like objects are decoded according to the
   given encoding and error handler. The encoding and error handler can be
   NULL to have the interface use UTF-8 and "strict".

   All other objects (including Unicode objects) raise an exception.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/

__declspec(dllimport) PyObject* PyUnicode_FromEncodedObject(
    PyObject *obj,              /* Object */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    );

/* Copy an instance of a Unicode subtype to a new true Unicode object if
   necessary. If obj is already a true Unicode object (not a subtype), return
   the reference with *incremented* refcount.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/

__declspec(dllimport) PyObject* PyUnicode_FromObject(
    PyObject *obj      /* Object */
    );

__declspec(dllimport) PyObject * PyUnicode_FromFormatV(
    const char *format,   /* ASCII-encoded string  */
    va_list vargs
    );
__declspec(dllimport) PyObject * PyUnicode_FromFormat(
    const char *format,   /* ASCII-encoded string  */
    ...
    );


typedef struct {
    PyObject *buffer;
    void *data;
    enum PyUnicode_Kind kind;
    Py_UCS4 maxchar;
    Py_ssize_t size;
    Py_ssize_t pos;

    /* minimum number of allocated characters (default: 0) */
    Py_ssize_t min_length;

    /* minimum character (default: 127, ASCII) */
    Py_UCS4 min_char;

    /* If non-zero, overallocate the buffer (default: 0). */
    unsigned char overallocate;

    /* If readonly is 1, buffer is a shared string (cannot be modified)
       and size is set to 0. */
    unsigned char readonly;
} _PyUnicodeWriter ;

/* Initialize a Unicode writer.
 *
 * By default, the minimum buffer size is 0 character and overallocation is
 * disabled. Set min_length, min_char and overallocate attributes to control
 * the allocation of the buffer. */
__declspec(dllimport) void
_PyUnicodeWriter_Init(_PyUnicodeWriter *writer);

/* Prepare the buffer to write 'length' characters
   with the specified maximum character.

   Return 0 on success, raise an exception and return -1 on error. */








/* Don't call this function directly, use the _PyUnicodeWriter_Prepare() macro
   instead. */
__declspec(dllimport) int
_PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer,
                                 Py_ssize_t length, Py_UCS4 maxchar);

/* Prepare the buffer to have at least the kind KIND.
   For example, kind=PyUnicode_2BYTE_KIND ensures that the writer will
   support characters in range U+000-U+FFFF.

   Return 0 on success, raise an exception and return -1 on error. */






/* Don't call this function directly, use the _PyUnicodeWriter_PrepareKind()
   macro instead. */
__declspec(dllimport) int
_PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer,
                                     enum PyUnicode_Kind kind);

/* Append a Unicode character.
   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int
_PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer,
    Py_UCS4 ch
    );

/* Append a Unicode string.
   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int
_PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer,
    PyObject *str               /* Unicode string */
    );

/* Append a substring of a Unicode string.
   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int
_PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer,
    PyObject *str,              /* Unicode string */
    Py_ssize_t start,
    Py_ssize_t end
    );

/* Append an ASCII-encoded byte string.
   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int
_PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer,
    const char *str,           /* ASCII-encoded byte string */
    Py_ssize_t len             /* number of bytes, or -1 if unknown */
    );

/* Append a latin1-encoded byte string.
   Return 0 on success, raise an exception and return -1 on error. */
__declspec(dllimport) int
_PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer,
    const char *str,           /* latin1-encoded byte string */
    Py_ssize_t len             /* length in bytes */
    );

/* Get the value of the writer as a Unicode string. Clear the
   buffer of the writer. Raise an exception and return NULL
   on error. */
__declspec(dllimport) PyObject *
_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer);

/* Deallocate memory of a writer (clear its internal buffer). */
__declspec(dllimport) void
_PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer);



/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
__declspec(dllimport) int _PyUnicode_FormatAdvancedWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    PyObject *format_spec,
    Py_ssize_t start,
    Py_ssize_t end);


__declspec(dllimport) void PyUnicode_InternInPlace(PyObject **);
__declspec(dllimport) void PyUnicode_InternImmortal(PyObject **);
__declspec(dllimport) PyObject * PyUnicode_InternFromString(
    const char *u              /* UTF-8 encoded string */
    );

__declspec(dllimport) void _Py_ReleaseInternedUnicodeStrings(void);


/* Use only if you know it's a string */



/* --- wchar_t support for platforms which support it --------------------- */



/* Create a Unicode Object from the wchar_t buffer w of the given
   size.

   The buffer is copied into the new object. */

__declspec(dllimport) PyObject* PyUnicode_FromWideChar(
    const wchar_t *w,           /* wchar_t buffer */
    Py_ssize_t size             /* size of buffer */
    );

/* Copies the Unicode Object contents into the wchar_t buffer w.  At
   most size wchar_t characters are copied.

   Note that the resulting wchar_t string may or may not be
   0-terminated.  It is the responsibility of the caller to make sure
   that the wchar_t string is 0-terminated in case this is required by
   the application.

   Returns the number of wchar_t characters copied (excluding a
   possibly trailing 0-termination character) or -1 in case of an
   error. */

__declspec(dllimport) Py_ssize_t PyUnicode_AsWideChar(
    PyObject *unicode,          /* Unicode object */
    wchar_t *w,                 /* wchar_t buffer */
    Py_ssize_t size             /* size of buffer */
    );

/* Convert the Unicode object to a wide character string. The output string
   always ends with a nul character. If size is not NULL, write the number of
   wide characters (excluding the null character) into *size.

   Returns a buffer allocated by PyMem_Malloc() (use PyMem_Free() to free it)
   on success. On error, returns NULL, *size is undefined and raises a
   MemoryError. */

__declspec(dllimport) wchar_t* PyUnicode_AsWideCharString(
    PyObject *unicode,          /* Unicode object */
    Py_ssize_t *size            /* number of characters of the result */
    );


__declspec(dllimport) void* _PyUnicode_AsKind(PyObject *s, unsigned int kind);




/* --- Unicode ordinals --------------------------------------------------- */

/* Create a Unicode Object from the given Unicode code point ordinal.

   The ordinal must be in range(0x110000). A ValueError is
   raised in case it is not.

*/

__declspec(dllimport) PyObject* PyUnicode_FromOrdinal(int ordinal);

/* --- Free-list management ----------------------------------------------- */

/* Clear the free list used by the Unicode implementation.

   This can be used to release memory used for objects on the free
   list back to the Python memory allocator.

*/

__declspec(dllimport) int PyUnicode_ClearFreeList(void);

/* === Builtin Codecs =====================================================

   Many of these APIs take two arguments encoding and errors. These
   parameters encoding and errors have the same semantics as the ones
   of the builtin str() API.

   Setting encoding to NULL causes the default encoding (UTF-8) to be used.

   Error handling is set by errors which may also be set to NULL
   meaning to use the default handling defined for the codec. Default
   error handling for all builtin codecs is "strict" (ValueErrors are
   raised).

   The codecs all use a similar interface. Only deviation from the
   generic ones are documented.

*/

/* --- Manage the default encoding ---------------------------------------- */

/* Returns a pointer to the default encoding (UTF-8) of the
   Unicode object unicode and the size of the encoded representation
   in bytes stored in *size.

   In case of an error, no *size is set.

   This function caches the UTF-8 encoded string in the unicodeobject
   and subsequent calls will return the same string.  The memory is released
   when the unicodeobject is deallocated.

   _PyUnicode_AsStringAndSize is a #define for PyUnicode_AsUTF8AndSize to
   support the previous internal function with the same behaviour.

   *** This API is for interpreter INTERNAL USE ONLY and will likely
   *** be removed or changed in the future.

   *** If you need to access the Unicode object as UTF-8 bytes string,
   *** please use PyUnicode_AsUTF8String() instead.
*/


__declspec(dllimport) const char * PyUnicode_AsUTF8AndSize(
    PyObject *unicode,
    Py_ssize_t *size);



/* Returns a pointer to the default encoding (UTF-8) of the
   Unicode object unicode.

   Like PyUnicode_AsUTF8AndSize(), this also caches the UTF-8 representation
   in the unicodeobject.

   _PyUnicode_AsString is a #define for PyUnicode_AsUTF8 to
   support the previous internal function with the same behaviour.

   Use of this API is DEPRECATED since no size information can be
   extracted from the returned data.

   *** This API is for interpreter INTERNAL USE ONLY and will likely
   *** be removed or changed for Python 3.1.

   *** If you need to access the Unicode object as UTF-8 bytes string,
   *** please use PyUnicode_AsUTF8String() instead.

*/


__declspec(dllimport) const char * PyUnicode_AsUTF8(PyObject *unicode);



/* Returns "utf-8".  */

__declspec(dllimport) const char* PyUnicode_GetDefaultEncoding(void);

/* --- Generic Codecs ----------------------------------------------------- */

/* Create a Unicode object by decoding the encoded string s of the
   given size. */

__declspec(dllimport) PyObject* PyUnicode_Decode(
    const char *s,              /* encoded string */
    Py_ssize_t size,            /* size of buffer */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    );

/* Decode a Unicode object unicode and return the result as Python
   object.

   This API is DEPRECATED. The only supported standard encoding is rot13.
   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
   that decode from str. */

__declspec(dllimport) PyObject* PyUnicode_AsDecodedObject(
    PyObject *unicode,          /* Unicode object */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    ) ;

/* Decode a Unicode object unicode and return the result as Unicode
   object.

   This API is DEPRECATED. The only supported standard encoding is rot13.
   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
   that decode from str to str. */

__declspec(dllimport) PyObject* PyUnicode_AsDecodedUnicode(
    PyObject *unicode,          /* Unicode object */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    ) ;

/* Encodes a Py_UNICODE buffer of the given size and returns a
   Python string object. */


__declspec(dllimport) PyObject* PyUnicode_Encode(
    const Py_UNICODE *s,        /* Unicode char buffer */
    Py_ssize_t size,            /* number of Py_UNICODE chars to encode */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    ) ;


/* Encodes a Unicode object and returns the result as Python
   object.

   This API is DEPRECATED.  It is superseded by PyUnicode_AsEncodedString()
   since all standard encodings (except rot13) encode str to bytes.
   Use PyCodec_Encode() for encoding with rot13 and non-standard codecs
   that encode form str to non-bytes. */

__declspec(dllimport) PyObject* PyUnicode_AsEncodedObject(
    PyObject *unicode,          /* Unicode object */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    ) ;

/* Encodes a Unicode object and returns the result as Python string
   object. */

__declspec(dllimport) PyObject* PyUnicode_AsEncodedString(
    PyObject *unicode,          /* Unicode object */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    );

/* Encodes a Unicode object and returns the result as Unicode
   object.

   This API is DEPRECATED.  The only supported standard encodings is rot13.
   Use PyCodec_Encode() to encode with rot13 and non-standard codecs
   that encode from str to str. */

__declspec(dllimport) PyObject* PyUnicode_AsEncodedUnicode(
    PyObject *unicode,          /* Unicode object */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    ) ;

/* Build an encoding map. */

__declspec(dllimport) PyObject* PyUnicode_BuildEncodingMap(
    PyObject* string            /* 256 character map */
   );

/* --- UTF-7 Codecs ------------------------------------------------------- */

__declspec(dllimport) PyObject* PyUnicode_DecodeUTF7(
    const char *string,         /* UTF-7 encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors          /* error handling */
    );

__declspec(dllimport) PyObject* PyUnicode_DecodeUTF7Stateful(
    const char *string,         /* UTF-7 encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors,         /* error handling */
    Py_ssize_t *consumed        /* bytes consumed */
    );


__declspec(dllimport) PyObject* PyUnicode_EncodeUTF7(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */
    int base64SetO,             /* Encode RFC2152 Set O characters in base64 */
    int base64WhiteSpace,       /* Encode whitespace (sp, ht, nl, cr) in base64 */
    const char *errors          /* error handling */
    ) ;
__declspec(dllimport) PyObject* _PyUnicode_EncodeUTF7(
    PyObject *unicode,          /* Unicode object */
    int base64SetO,             /* Encode RFC2152 Set O characters in base64 */
    int base64WhiteSpace,       /* Encode whitespace (sp, ht, nl, cr) in base64 */
    const char *errors          /* error handling */
    );


/* --- UTF-8 Codecs ------------------------------------------------------- */

__declspec(dllimport) PyObject* PyUnicode_DecodeUTF8(
    const char *string,         /* UTF-8 encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors          /* error handling */
    );

__declspec(dllimport) PyObject* PyUnicode_DecodeUTF8Stateful(
    const char *string,         /* UTF-8 encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors,         /* error handling */
    Py_ssize_t *consumed        /* bytes consumed */
    );

__declspec(dllimport) PyObject* PyUnicode_AsUTF8String(
    PyObject *unicode           /* Unicode object */
    );


__declspec(dllimport) PyObject* _PyUnicode_AsUTF8String(
    PyObject *unicode,
    const char *errors);

__declspec(dllimport) PyObject* PyUnicode_EncodeUTF8(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */
    const char *errors          /* error handling */
    ) ;


/* --- UTF-32 Codecs ------------------------------------------------------ */

/* Decodes length bytes from a UTF-32 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict".

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

    *byteorder == -1: little endian
    *byteorder == 0:  native order
    *byteorder == 1:  big endian

   In native mode, the first four bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/

__declspec(dllimport) PyObject* PyUnicode_DecodeUTF32(
    const char *string,         /* UTF-32 encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors,         /* error handling */
    int *byteorder              /* pointer to byteorder to use
                                   0=native;-1=LE,1=BE; updated on
                                   exit */
    );

__declspec(dllimport) PyObject* PyUnicode_DecodeUTF32Stateful(
    const char *string,         /* UTF-32 encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors,         /* error handling */
    int *byteorder,             /* pointer to byteorder to use
                                   0=native;-1=LE,1=BE; updated on
                                   exit */
    Py_ssize_t *consumed        /* bytes consumed */
    );

/* Returns a Python string using the UTF-32 encoding in native byte
   order. The string always starts with a BOM mark.  */

__declspec(dllimport) PyObject* PyUnicode_AsUTF32String(
    PyObject *unicode           /* Unicode object */
    );

/* Returns a Python string object holding the UTF-32 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

*/


__declspec(dllimport) PyObject* PyUnicode_EncodeUTF32(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */
    const char *errors,         /* error handling */
    int byteorder               /* byteorder to use 0=BOM+native;-1=LE,1=BE */
    ) ;
__declspec(dllimport) PyObject* _PyUnicode_EncodeUTF32(
    PyObject *object,           /* Unicode object */
    const char *errors,         /* error handling */
    int byteorder               /* byteorder to use 0=BOM+native;-1=LE,1=BE */
    );


/* --- UTF-16 Codecs ------------------------------------------------------ */

/* Decodes length bytes from a UTF-16 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict".

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

    *byteorder == -1: little endian
    *byteorder == 0:  native order
    *byteorder == 1:  big endian

   In native mode, the first two bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/

__declspec(dllimport) PyObject* PyUnicode_DecodeUTF16(
    const char *string,         /* UTF-16 encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors,         /* error handling */
    int *byteorder              /* pointer to byteorder to use
                                   0=native;-1=LE,1=BE; updated on
                                   exit */
    );

__declspec(dllimport) PyObject* PyUnicode_DecodeUTF16Stateful(
    const char *string,         /* UTF-16 encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors,         /* error handling */
    int *byteorder,             /* pointer to byteorder to use
                                   0=native;-1=LE,1=BE; updated on
                                   exit */
    Py_ssize_t *consumed        /* bytes consumed */
    );

/* Returns a Python string using the UTF-16 encoding in native byte
   order. The string always starts with a BOM mark.  */

__declspec(dllimport) PyObject* PyUnicode_AsUTF16String(
    PyObject *unicode           /* Unicode object */
    );

/* Returns a Python string object holding the UTF-16 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

   Note that Py_UNICODE data is being interpreted as UTF-16 reduced to
   UCS-2. This trick makes it possible to add full UTF-16 capabilities
   at a later point without compromising the APIs.

*/


__declspec(dllimport) PyObject* PyUnicode_EncodeUTF16(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */
    const char *errors,         /* error handling */
    int byteorder               /* byteorder to use 0=BOM+native;-1=LE,1=BE */
    ) ;
__declspec(dllimport) PyObject* _PyUnicode_EncodeUTF16(
    PyObject* unicode,          /* Unicode object */
    const char *errors,         /* error handling */
    int byteorder               /* byteorder to use 0=BOM+native;-1=LE,1=BE */
    );


/* --- Unicode-Escape Codecs ---------------------------------------------- */

__declspec(dllimport) PyObject* PyUnicode_DecodeUnicodeEscape(
    const char *string,         /* Unicode-Escape encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors          /* error handling */
    );


/* Helper for PyUnicode_DecodeUnicodeEscape that detects invalid escape
   chars. */
__declspec(dllimport) PyObject* _PyUnicode_DecodeUnicodeEscape(
        const char *string,     /* Unicode-Escape encoded string */
        Py_ssize_t length,      /* size of string */
        const char *errors,     /* error handling */
        const char **first_invalid_escape  /* on return, points to first
                                              invalid escaped char in
                                              string. */
);


__declspec(dllimport) PyObject* PyUnicode_AsUnicodeEscapeString(
    PyObject *unicode           /* Unicode object */
    );


__declspec(dllimport) PyObject* PyUnicode_EncodeUnicodeEscape(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length           /* Number of Py_UNICODE chars to encode */
    ) ;


/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */

__declspec(dllimport) PyObject* PyUnicode_DecodeRawUnicodeEscape(
    const char *string,         /* Raw-Unicode-Escape encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors          /* error handling */
    );

__declspec(dllimport) PyObject* PyUnicode_AsRawUnicodeEscapeString(
    PyObject *unicode           /* Unicode object */
    );


__declspec(dllimport) PyObject* PyUnicode_EncodeRawUnicodeEscape(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length           /* Number of Py_UNICODE chars to encode */
    ) ;


/* --- Unicode Internal Codec ---------------------------------------------

    Only for internal use in _codecsmodule.c */


PyObject *_PyUnicode_DecodeUnicodeInternal(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );


/* --- Latin-1 Codecs -----------------------------------------------------

   Note: Latin-1 corresponds to the first 256 Unicode ordinals.

*/

__declspec(dllimport) PyObject* PyUnicode_DecodeLatin1(
    const char *string,         /* Latin-1 encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors          /* error handling */
    );

__declspec(dllimport) PyObject* PyUnicode_AsLatin1String(
    PyObject *unicode           /* Unicode object */
    );


__declspec(dllimport) PyObject* _PyUnicode_AsLatin1String(
    PyObject* unicode,
    const char* errors);

__declspec(dllimport) PyObject* PyUnicode_EncodeLatin1(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */
    const char *errors          /* error handling */
    ) ;


/* --- ASCII Codecs -------------------------------------------------------

   Only 7-bit ASCII data is excepted. All other codes generate errors.

*/

__declspec(dllimport) PyObject* PyUnicode_DecodeASCII(
    const char *string,         /* ASCII encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors          /* error handling */
    );

__declspec(dllimport) PyObject* PyUnicode_AsASCIIString(
    PyObject *unicode           /* Unicode object */
    );


__declspec(dllimport) PyObject* _PyUnicode_AsASCIIString(
    PyObject* unicode,
    const char* errors);

__declspec(dllimport) PyObject* PyUnicode_EncodeASCII(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */
    const char *errors          /* error handling */
    ) ;


/* --- Character Map Codecs -----------------------------------------------

   This codec uses mappings to encode and decode characters.

   Decoding mappings must map byte ordinals (integers in the range from 0 to
   255) to Unicode strings, integers (which are then interpreted as Unicode
   ordinals) or None.  Unmapped data bytes (ones which cause a LookupError)
   as well as mapped to None, 0xFFFE or '\ufffe' are treated as "undefined
   mapping" and cause an error.

   Encoding mappings must map Unicode ordinal integers to bytes objects,
   integers in the range from 0 to 255 or None.  Unmapped character
   ordinals (ones which cause a LookupError) as well as mapped to
   None are treated as "undefined mapping" and cause an error.

*/

__declspec(dllimport) PyObject* PyUnicode_DecodeCharmap(
    const char *string,         /* Encoded string */
    Py_ssize_t length,          /* size of string */
    PyObject *mapping,          /* decoding mapping */
    const char *errors          /* error handling */
    );

__declspec(dllimport) PyObject* PyUnicode_AsCharmapString(
    PyObject *unicode,          /* Unicode object */
    PyObject *mapping           /* encoding mapping */
    );


__declspec(dllimport) PyObject* PyUnicode_EncodeCharmap(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */
    PyObject *mapping,          /* encoding mapping */
    const char *errors          /* error handling */
    ) ;
__declspec(dllimport) PyObject* _PyUnicode_EncodeCharmap(
    PyObject *unicode,          /* Unicode object */
    PyObject *mapping,          /* encoding mapping */
    const char *errors          /* error handling */
    );


/* Translate a Py_UNICODE buffer of the given length by applying a
   character mapping table to it and return the resulting Unicode
   object.

   The mapping table must map Unicode ordinal integers to Unicode strings,
   Unicode ordinal integers or None (causing deletion of the character).

   Mapping tables may be dictionaries or sequences. Unmapped character
   ordinals (ones which cause a LookupError) are left untouched and
   are copied as-is.

*/


__declspec(dllimport) PyObject * PyUnicode_TranslateCharmap(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */
    PyObject *table,            /* Translate table */
    const char *errors          /* error handling */
    ) ;




/* --- MBCS codecs for Windows -------------------------------------------- */

__declspec(dllimport) PyObject* PyUnicode_DecodeMBCS(
    const char *string,         /* MBCS encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors          /* error handling */
    );

__declspec(dllimport) PyObject* PyUnicode_DecodeMBCSStateful(
    const char *string,         /* MBCS encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors,         /* error handling */
    Py_ssize_t *consumed        /* bytes consumed */
    );


__declspec(dllimport) PyObject* PyUnicode_DecodeCodePageStateful(
    int code_page,              /* code page number */
    const char *string,         /* encoded string */
    Py_ssize_t length,          /* size of string */
    const char *errors,         /* error handling */
    Py_ssize_t *consumed        /* bytes consumed */
    );


__declspec(dllimport) PyObject* PyUnicode_AsMBCSString(
    PyObject *unicode           /* Unicode object */
    );


__declspec(dllimport) PyObject* PyUnicode_EncodeMBCS(
    const Py_UNICODE *data,     /* Unicode char buffer */
    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */
    const char *errors          /* error handling */
    ) ;



__declspec(dllimport) PyObject* PyUnicode_EncodeCodePage(
    int code_page,              /* code page number */
    PyObject *unicode,          /* Unicode object */
    const char *errors          /* error handling */
    );





/* --- Decimal Encoder ---------------------------------------------------- */

/* Takes a Unicode string holding a decimal value and writes it into
   an output buffer using standard ASCII digit codes.

   The output buffer has to provide at least length+1 bytes of storage
   area. The output string is 0-terminated.

   The encoder converts whitespace to ' ', decimal characters to their
   corresponding ASCII digit and all other Latin-1 characters except
   \0 as-is. Characters outside this range (Unicode ordinals 1-256)
   are treated as errors. This includes embedded NULL bytes.

   Error handling is defined by the errors argument:

      NULL or "strict": raise a ValueError
      "ignore": ignore the wrong characters (these are not copied to the
                output buffer)
      "replace": replaces illegal characters with '?'

   Returns 0 on success, -1 on failure.

*/

__declspec(dllimport) int PyUnicode_EncodeDecimal(
    Py_UNICODE *s,              /* Unicode buffer */
    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */
    char *output,               /* Output buffer; must have size >= length */
    const char *errors          /* error handling */
    ) /* Py_DEPRECATED(3.3) */;

/* Transforms code points that have decimal digit property to the
   corresponding ASCII digit code points.

   Returns a new Unicode string on success, NULL on failure.
*/

__declspec(dllimport) PyObject* PyUnicode_TransformDecimalToASCII(
    Py_UNICODE *s,              /* Unicode buffer */
    Py_ssize_t length           /* Number of Py_UNICODE chars to transform */
    ) /* Py_DEPRECATED(3.3) */;

/* Coverts a Unicode object holding a decimal value to an ASCII string
   for using in int, float and complex parsers.
   Transforms code points that have decimal digit property to the
   corresponding ASCII digit code points.  Transforms spaces to ASCII.
   Transforms code points starting from the first non-ASCII code point that
   is neither a decimal digit nor a space to the end into '?'. */

__declspec(dllimport) PyObject* _PyUnicode_TransformDecimalAndSpaceToASCII(
    PyObject *unicode           /* Unicode object */
    );


/* --- Locale encoding --------------------------------------------------- */


/* Decode a string from the current locale encoding. The decoder is strict if
   *surrogateescape* is equal to zero, otherwise it uses the 'surrogateescape'
   error handler (PEP 383) to escape undecodable bytes. If a byte sequence can
   be decoded as a surrogate character and *surrogateescape* is not equal to
   zero, the byte sequence is escaped using the 'surrogateescape' error handler
   instead of being decoded. *str* must end with a null character but cannot
   contain embedded null characters. */

__declspec(dllimport) PyObject* PyUnicode_DecodeLocaleAndSize(
    const char *str,
    Py_ssize_t len,
    const char *errors);

/* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string
   length using strlen(). */

__declspec(dllimport) PyObject* PyUnicode_DecodeLocale(
    const char *str,
    const char *errors);

/* Encode a Unicode object to the current locale encoding. The encoder is
   strict is *surrogateescape* is equal to zero, otherwise the
   "surrogateescape" error handler is used. Return a bytes object. The string
   cannot contain embedded null characters. */

__declspec(dllimport) PyObject* PyUnicode_EncodeLocale(
    PyObject *unicode,
    const char *errors
    );


/* --- File system encoding ---------------------------------------------- */

/* ParseTuple converter: encode str objects to bytes using
   PyUnicode_EncodeFSDefault(); bytes objects are output as-is. */

__declspec(dllimport) int PyUnicode_FSConverter(PyObject*, void*);

/* ParseTuple converter: decode bytes objects to unicode using
   PyUnicode_DecodeFSDefaultAndSize(); str objects are output as-is. */

__declspec(dllimport) int PyUnicode_FSDecoder(PyObject*, void*);

/* Decode a null-terminated string using Py_FileSystemDefaultEncoding
   and the "surrogateescape" error handler.

   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
   encoding.

   Use PyUnicode_DecodeFSDefaultAndSize() if the string length is known.
*/

__declspec(dllimport) PyObject* PyUnicode_DecodeFSDefault(
    const char *s               /* encoded string */
    );

/* Decode a string using Py_FileSystemDefaultEncoding
   and the "surrogateescape" error handler.

   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
   encoding.
*/

__declspec(dllimport) PyObject* PyUnicode_DecodeFSDefaultAndSize(
    const char *s,               /* encoded string */
    Py_ssize_t size              /* size */
    );

/* Encode a Unicode object to Py_FileSystemDefaultEncoding with the
   "surrogateescape" error handler, and return bytes.

   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
   encoding.
*/

__declspec(dllimport) PyObject* PyUnicode_EncodeFSDefault(
    PyObject *unicode
    );

/* --- Methods & Slots ----------------------------------------------------

   These are capable of handling Unicode objects and strings on input
   (we refer to them as strings in the descriptions) and return
   Unicode objects or integers as appropriate. */

/* Concat two strings giving a new Unicode string. */

__declspec(dllimport) PyObject* PyUnicode_Concat(
    PyObject *left,             /* Left string */
    PyObject *right             /* Right string */
    );

/* Concat two strings and put the result in *pleft
   (sets *pleft to NULL on error) */

__declspec(dllimport) void PyUnicode_Append(
    PyObject **pleft,           /* Pointer to left string */
    PyObject *right             /* Right string */
    );

/* Concat two strings, put the result in *pleft and drop the right object
   (sets *pleft to NULL on error) */

__declspec(dllimport) void PyUnicode_AppendAndDel(
    PyObject **pleft,           /* Pointer to left string */
    PyObject *right             /* Right string */
    );

/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. If negative, no limit is set.

   Separators are not included in the resulting list.

*/

__declspec(dllimport) PyObject* PyUnicode_Split(
    PyObject *s,                /* String to split */
    PyObject *sep,              /* String separator */
    Py_ssize_t maxsplit         /* Maxsplit count */
    );

/* Dito, but split at line breaks.

   CRLF is considered to be one line break. Line breaks are not
   included in the resulting list. */

__declspec(dllimport) PyObject* PyUnicode_Splitlines(
    PyObject *s,                /* String to split */
    int keepends                /* If true, line end markers are included */
    );

/* Partition a string using a given separator. */

__declspec(dllimport) PyObject* PyUnicode_Partition(
    PyObject *s,                /* String to partition */
    PyObject *sep               /* String separator */
    );

/* Partition a string using a given separator, searching from the end of the
   string. */

__declspec(dllimport) PyObject* PyUnicode_RPartition(
    PyObject *s,                /* String to partition */
    PyObject *sep               /* String separator */
    );

/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. But unlike PyUnicode_Split
   PyUnicode_RSplit splits from the end of the string. If negative,
   no limit is set.

   Separators are not included in the resulting list.

*/

__declspec(dllimport) PyObject* PyUnicode_RSplit(
    PyObject *s,                /* String to split */
    PyObject *sep,              /* String separator */
    Py_ssize_t maxsplit         /* Maxsplit count */
    );

/* Translate a string by applying a character mapping table to it and
   return the resulting Unicode object.

   The mapping table must map Unicode ordinal integers to Unicode strings,
   Unicode ordinal integers or None (causing deletion of the character).

   Mapping tables may be dictionaries or sequences. Unmapped character
   ordinals (ones which cause a LookupError) are left untouched and
   are copied as-is.

*/

__declspec(dllimport) PyObject * PyUnicode_Translate(
    PyObject *str,              /* String */
    PyObject *table,            /* Translate table */
    const char *errors          /* error handling */
    );

/* Join a sequence of strings using the given separator and return
   the resulting Unicode string. */

__declspec(dllimport) PyObject* PyUnicode_Join(
    PyObject *separator,        /* Separator string */
    PyObject *seq               /* Sequence object */
    );


__declspec(dllimport) PyObject * _PyUnicode_JoinArray(
    PyObject *separator,
    PyObject *const *items,
    Py_ssize_t seqlen
    );


/* Return 1 if substr matches str[start:end] at the given tail end, 0
   otherwise. */

__declspec(dllimport) Py_ssize_t PyUnicode_Tailmatch(
    PyObject *str,              /* String */
    PyObject *substr,           /* Prefix or Suffix string */
    Py_ssize_t start,           /* Start index */
    Py_ssize_t end,             /* Stop index */
    int direction               /* Tail end: -1 prefix, +1 suffix */
    );

/* Return the first position of substr in str[start:end] using the
   given search direction or -1 if not found. -2 is returned in case
   an error occurred and an exception is set. */

__declspec(dllimport) Py_ssize_t PyUnicode_Find(
    PyObject *str,              /* String */
    PyObject *substr,           /* Substring to find */
    Py_ssize_t start,           /* Start index */
    Py_ssize_t end,             /* Stop index */
    int direction               /* Find direction: +1 forward, -1 backward */
    );


/* Like PyUnicode_Find, but search for single character only. */
__declspec(dllimport) Py_ssize_t PyUnicode_FindChar(
    PyObject *str,
    Py_UCS4 ch,
    Py_ssize_t start,
    Py_ssize_t end,
    int direction
    );


/* Count the number of occurrences of substr in str[start:end]. */

__declspec(dllimport) Py_ssize_t PyUnicode_Count(
    PyObject *str,              /* String */
    PyObject *substr,           /* Substring to count */
    Py_ssize_t start,           /* Start index */
    Py_ssize_t end              /* Stop index */
    );

/* Replace at most maxcount occurrences of substr in str with replstr
   and return the resulting Unicode object. */

__declspec(dllimport) PyObject * PyUnicode_Replace(
    PyObject *str,              /* String */
    PyObject *substr,           /* Substring to find */
    PyObject *replstr,          /* Substring to replace */
    Py_ssize_t maxcount         /* Max. number of replacements to apply;
                                   -1 = all */
    );

/* Compare two strings and return -1, 0, 1 for less than, equal,
   greater than resp.
   Raise an exception and return -1 on error. */

__declspec(dllimport) int PyUnicode_Compare(
    PyObject *left,             /* Left string */
    PyObject *right             /* Right string */
    );


/* Test whether a unicode is equal to ASCII identifier.  Return 1 if true,
   0 otherwise.  The right argument must be ASCII identifier.
   Any error occurs inside will be cleared before return. */

__declspec(dllimport) int _PyUnicode_EqualToASCIIId(
    PyObject *left,             /* Left string */
    _Py_Identifier *right       /* Right identifier */
    );


/* Compare a Unicode object with C string and return -1, 0, 1 for less than,
   equal, and greater than, respectively.  It is best to pass only
   ASCII-encoded strings, but the function interprets the input string as
   ISO-8859-1 if it contains non-ASCII characters.
   This function does not raise exceptions. */

__declspec(dllimport) int PyUnicode_CompareWithASCIIString(
    PyObject *left,
    const char *right           /* ASCII-encoded string */
    );


/* Test whether a unicode is equal to ASCII string.  Return 1 if true,
   0 otherwise.  The right argument must be ASCII-encoded string.
   Any error occurs inside will be cleared before return. */

__declspec(dllimport) int _PyUnicode_EqualToASCIIString(
    PyObject *left,
    const char *right           /* ASCII-encoded string */
    );


/* Rich compare two strings and return one of the following:

   - NULL in case an exception was raised
   - Py_True or Py_False for successful comparisons
   - Py_NotImplemented in case the type combination is unknown

   Possible values for op:

     Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE

*/

__declspec(dllimport) PyObject * PyUnicode_RichCompare(
    PyObject *left,             /* Left string */
    PyObject *right,            /* Right string */
    int op                      /* Operation: Py_EQ, Py_NE, Py_GT, etc. */
    );

/* Apply an argument tuple or dictionary to a format string and return
   the resulting Unicode string. */

__declspec(dllimport) PyObject * PyUnicode_Format(
    PyObject *format,           /* Format string */
    PyObject *args              /* Argument tuple or dictionary */
    );

/* Checks whether element is contained in container and return 1/0
   accordingly.

   element has to coerce to a one element Unicode string. -1 is
   returned in case of an error. */

__declspec(dllimport) int PyUnicode_Contains(
    PyObject *container,        /* Container string */
    PyObject *element           /* Element string */
    );

/* Checks whether argument is a valid identifier. */

__declspec(dllimport) int PyUnicode_IsIdentifier(PyObject *s);


/* Externally visible for str.strip(unicode) */
__declspec(dllimport) PyObject * _PyUnicode_XStrip(
    PyObject *self,
    int striptype,
    PyObject *sepobj
    );


/* Using explicit passed-in values, insert the thousands grouping
   into the string pointed to by buffer.  For the argument descriptions,
   see Objects/stringlib/localeutil.h */

__declspec(dllimport) Py_ssize_t _PyUnicode_InsertThousandsGrouping(
    PyObject *unicode,
    Py_ssize_t index,
    Py_ssize_t n_buffer,
    void *digits,
    Py_ssize_t n_digits,
    Py_ssize_t min_width,
    const char *grouping,
    PyObject *thousands_sep,
    Py_UCS4 *maxchar);

/* === Characters Type APIs =============================================== */

/* Helper array used by Py_UNICODE_ISSPACE(). */


extern __declspec(dllimport) const unsigned char _Py_ascii_whitespace[];

/* These should not be used directly. Use the Py_UNICODE_IS* and
   Py_UNICODE_TO* macros instead.

   These APIs are implemented in Objects/unicodectype.c.

*/

__declspec(dllimport) int _PyUnicode_IsLowercase(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsUppercase(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsTitlecase(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsXidStart(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsXidContinue(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsWhitespace(
    const Py_UCS4 ch         /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsLinebreak(
    const Py_UCS4 ch         /* Unicode character */
    );

__declspec(dllimport) Py_UCS4 _PyUnicode_ToLowercase(
    Py_UCS4 ch       /* Unicode character */
    ) /* Py_DEPRECATED(3.3) */;

__declspec(dllimport) Py_UCS4 _PyUnicode_ToUppercase(
    Py_UCS4 ch       /* Unicode character */
    ) /* Py_DEPRECATED(3.3) */;

__declspec(dllimport) Py_UCS4 _PyUnicode_ToTitlecase(
    Py_UCS4 ch       /* Unicode character */
    ) ;

__declspec(dllimport) int _PyUnicode_ToLowerFull(
    Py_UCS4 ch,       /* Unicode character */
    Py_UCS4 *res
    );

__declspec(dllimport) int _PyUnicode_ToTitleFull(
    Py_UCS4 ch,       /* Unicode character */
    Py_UCS4 *res
    );

__declspec(dllimport) int _PyUnicode_ToUpperFull(
    Py_UCS4 ch,       /* Unicode character */
    Py_UCS4 *res
    );

__declspec(dllimport) int _PyUnicode_ToFoldedFull(
    Py_UCS4 ch,       /* Unicode character */
    Py_UCS4 *res
    );

__declspec(dllimport) int _PyUnicode_IsCaseIgnorable(
    Py_UCS4 ch         /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsCased(
    Py_UCS4 ch         /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_ToDecimalDigit(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_ToDigit(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) double _PyUnicode_ToNumeric(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsDecimalDigit(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsDigit(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsNumeric(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsPrintable(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) int _PyUnicode_IsAlpha(
    Py_UCS4 ch       /* Unicode character */
    );

__declspec(dllimport) size_t Py_UNICODE_strlen(
    const Py_UNICODE *u
    ) ;

__declspec(dllimport) Py_UNICODE* Py_UNICODE_strcpy(
    Py_UNICODE *s1,
    const Py_UNICODE *s2) ;

__declspec(dllimport) Py_UNICODE* Py_UNICODE_strcat(
    Py_UNICODE *s1, const Py_UNICODE *s2) ;

__declspec(dllimport) Py_UNICODE* Py_UNICODE_strncpy(
    Py_UNICODE *s1,
    const Py_UNICODE *s2,
    size_t n) ;

__declspec(dllimport) int Py_UNICODE_strcmp(
    const Py_UNICODE *s1,
    const Py_UNICODE *s2
    ) ;

__declspec(dllimport) int Py_UNICODE_strncmp(
    const Py_UNICODE *s1,
    const Py_UNICODE *s2,
    size_t n
    ) ;

__declspec(dllimport) Py_UNICODE* Py_UNICODE_strchr(
    const Py_UNICODE *s,
    Py_UNICODE c
    ) ;

__declspec(dllimport) Py_UNICODE* Py_UNICODE_strrchr(
    const Py_UNICODE *s,
    Py_UNICODE c
    ) ;

__declspec(dllimport) PyObject* _PyUnicode_FormatLong(PyObject *, int, int, int);

/* Create a copy of a unicode string ending with a nul character. Return NULL
   and raise a MemoryError exception on memory allocation failure, otherwise
   return a new allocated buffer (use PyMem_Free() to free the buffer). */

__declspec(dllimport) Py_UNICODE* PyUnicode_AsUnicodeCopy(
    PyObject *unicode
    ) ;







/* For asserts that call _PyUnicode_CheckConsistency(), which would
 * otherwise be a problem when building with asserts but without Py_DEBUG. */




/* Return an interned Unicode object for an Identifier; may fail if there is no memory.*/
__declspec(dllimport) PyObject* _PyUnicode_FromId(_Py_Identifier*);
/* Clear all static strings. */
__declspec(dllimport) void _PyUnicode_ClearStaticStrings(void);

/* Fast equality check when the inputs are known to be exact unicode types
   and where the hash values are equal (i.e. a very probable match) */
__declspec(dllimport) int _PyUnicode_EQ(PyObject *, PyObject *);















/* Long (arbitrary precision) integer object interface */

typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */

extern __declspec(dllimport) PyTypeObject PyLong_Type;





__declspec(dllimport) PyObject * PyLong_FromLong(long);
__declspec(dllimport) PyObject * PyLong_FromUnsignedLong(unsigned long);
__declspec(dllimport) PyObject * PyLong_FromSize_t(size_t);
__declspec(dllimport) PyObject * PyLong_FromSsize_t(Py_ssize_t);
__declspec(dllimport) PyObject * PyLong_FromDouble(double);
__declspec(dllimport) long PyLong_AsLong(PyObject *);
__declspec(dllimport) long PyLong_AsLongAndOverflow(PyObject *, int *);
__declspec(dllimport) Py_ssize_t PyLong_AsSsize_t(PyObject *);
__declspec(dllimport) size_t PyLong_AsSize_t(PyObject *);
__declspec(dllimport) unsigned long PyLong_AsUnsignedLong(PyObject *);
__declspec(dllimport) unsigned long PyLong_AsUnsignedLongMask(PyObject *);

__declspec(dllimport) int _PyLong_AsInt(PyObject *);

__declspec(dllimport) PyObject * PyLong_GetInfo(void);

/* It may be useful in the future. I've added it in the PyInt -> PyLong
   cleanup to keep the extra information. [CH] */


/* Issue #1983: pid_t can be longer than a C long on some systems */





























/* Used by Python/mystrtoul.c, _PyBytes_FromHex(),
   _PyBytes_DecodeEscapeRecode(), etc. */

extern __declspec(dllimport) unsigned char _PyLong_DigitValue[256];


/* _PyLong_Frexp returns a double x and an exponent e such that the
   true value is approximately equal to x * 2**e.  e is >= 0.  x is
   0.0 if and only if the input is 0 (in which case, e and x are both
   zeroes); otherwise, 0.5 <= abs(x) < 1.0.  On overflow, which is
   possible if the number of bits doesn't fit into a Py_ssize_t, sets
   OverflowError and returns -1.0 for x, 0 for e. */

__declspec(dllimport) double _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e);


__declspec(dllimport) double PyLong_AsDouble(PyObject *);
__declspec(dllimport) PyObject * PyLong_FromVoidPtr(void *);
__declspec(dllimport) void * PyLong_AsVoidPtr(PyObject *);

__declspec(dllimport) PyObject * PyLong_FromLongLong(long long);
__declspec(dllimport) PyObject * PyLong_FromUnsignedLongLong(unsigned long long);
__declspec(dllimport) long long PyLong_AsLongLong(PyObject *);
__declspec(dllimport) unsigned long long PyLong_AsUnsignedLongLong(PyObject *);
__declspec(dllimport) unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *);
__declspec(dllimport) long long PyLong_AsLongLongAndOverflow(PyObject *, int *);

__declspec(dllimport) PyObject * PyLong_FromString(const char *, char **, int);

__declspec(dllimport) PyObject * PyLong_FromUnicode(Py_UNICODE*, Py_ssize_t, int) ;
__declspec(dllimport) PyObject * PyLong_FromUnicodeObject(PyObject *u, int base);
__declspec(dllimport) PyObject * _PyLong_FromBytes(const char *, Py_ssize_t, int);



/* _PyLong_Sign.  Return 0 if v is 0, -1 if v < 0, +1 if v > 0.
   v must not be NULL, and must be a normalized long.
   There are no error cases.
*/
__declspec(dllimport) int _PyLong_Sign(PyObject *v);


/* _PyLong_NumBits.  Return the number of bits needed to represent the
   absolute value of a long.  For example, this returns 1 for 1 and -1, 2
   for 2 and -2, and 2 for 3 and -3.  It returns 0 for 0.
   v must not be NULL, and must be a normalized long.
   (size_t)-1 is returned and OverflowError set if the true result doesn't
   fit in a size_t.
*/
__declspec(dllimport) size_t _PyLong_NumBits(PyObject *v);

/* _PyLong_DivmodNear.  Given integers a and b, compute the nearest
   integer q to the exact quotient a / b, rounding to the nearest even integer
   in the case of a tie.  Return (q, r), where r = a - q*b.  The remainder r
   will satisfy abs(r) <= abs(b)/2, with equality possible only if q is
   even.
*/
__declspec(dllimport) PyObject * _PyLong_DivmodNear(PyObject *, PyObject *);

/* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in
   base 256, and return a Python int with the same numeric value.
   If n is 0, the integer is 0.  Else:
   If little_endian is 1/true, bytes[n-1] is the MSB and bytes[0] the LSB;
   else (little_endian is 0/false) bytes[0] is the MSB and bytes[n-1] the
   LSB.
   If is_signed is 0/false, view the bytes as a non-negative integer.
   If is_signed is 1/true, view the bytes as a 2's-complement integer,
   non-negative if bit 0x80 of the MSB is clear, negative if set.
   Error returns:
   + Return NULL with the appropriate exception set if there's not
     enough memory to create the Python int.
*/
__declspec(dllimport) PyObject * _PyLong_FromByteArray(
    const unsigned char* bytes, size_t n,
    int little_endian, int is_signed);

/* _PyLong_AsByteArray: Convert the least-significant 8*n bits of long
   v to a base-256 integer, stored in array bytes.  Normally return 0,
   return -1 on error.
   If little_endian is 1/true, store the MSB at bytes[n-1] and the LSB at
   bytes[0]; else (little_endian is 0/false) store the MSB at bytes[0] and
   the LSB at bytes[n-1].
   If is_signed is 0/false, it's an error if v < 0; else (v >= 0) n bytes
   are filled and there's nothing special about bit 0x80 of the MSB.
   If is_signed is 1/true, bytes is filled with the 2's-complement
   representation of v's value.  Bit 0x80 of the MSB is the sign bit.
   Error returns (-1):
   + is_signed is 0 and v < 0.  TypeError is set in this case, and bytes
     isn't altered.
   + n isn't big enough to hold the full mathematical value of v.  For
     example, if is_signed is 0 and there are more digits in the v than
     fit in n; or if is_signed is 1, v < 0, and n is just 1 bit shy of
     being large enough to hold a sign bit.  OverflowError is set in this
     case, but bytes holds the least-significant n bytes of the true value.
*/
__declspec(dllimport) int _PyLong_AsByteArray(PyLongObject* v,
    unsigned char* bytes, size_t n,
    int little_endian, int is_signed);

/* _PyLong_FromNbInt: Convert the given object to a PyLongObject
   using the nb_int slot, if available.  Raise TypeError if either the
   nb_int slot is not available or the result of the call to nb_int
   returns something not of type int.
*/
__declspec(dllimport) PyLongObject *_PyLong_FromNbInt(PyObject *);

/* _PyLong_Format: Convert the long to a string object with given base,
   appending a base prefix of 0[box] if base is 2, 8 or 16. */
__declspec(dllimport) PyObject * _PyLong_Format(PyObject *obj, int base);

__declspec(dllimport) int _PyLong_FormatWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    int base,
    int alternate);

__declspec(dllimport) char* _PyLong_FormatBytesWriter(
    _PyBytesWriter *writer,
    char *str,
    PyObject *obj,
    int base,
    int alternate);

/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
__declspec(dllimport) int _PyLong_FormatAdvancedWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    PyObject *format_spec,
    Py_ssize_t start,
    Py_ssize_t end);


/* These aren't really part of the int object, but they're handy. The
   functions are in Python/mystrtoul.c.
 */
__declspec(dllimport) unsigned long PyOS_strtoul(const char *, char **, int);
__declspec(dllimport) long PyOS_strtol(const char *, char **, int);


/* For use by the gcd function in mathmodule.c */
__declspec(dllimport) PyObject * _PyLong_GCD(PyObject *, PyObject *);



extern __declspec(dllimport) PyObject * _PyLong_Zero;
extern __declspec(dllimport) PyObject * _PyLong_One;
















/* This is published for the benefit of "friends" marshal.c and _decimal.c. */

/* Parameters of the integer representation.  There are two different
   sets of parameters: one set for 30-bit digits, stored in an unsigned 32-bit
   integer type, and one set for 15-bit digits with each digit stored in an
   unsigned short.  The value of PYLONG_BITS_IN_DIGIT, defined either at
   configure time or in pyport.h, is used to decide which digit size to use.

   Type 'digit' should be able to hold 2*PyLong_BASE-1, and type 'twodigits'
   should be an unsigned integer type able to hold all integers up to
   PyLong_BASE*PyLong_BASE-1.  x_sub assumes that 'digit' is an unsigned type,
   and that overflow is handled by taking the result modulo 2**N for some N >
   PyLong_SHIFT.  The majority of the code doesn't care about the precise
   value of PyLong_SHIFT, but there are some notable exceptions:

   - long_pow() requires that PyLong_SHIFT be divisible by 5

   - PyLong_{As,From}ByteArray require that PyLong_SHIFT be at least 8

   - long_hash() requires that PyLong_SHIFT is *strictly* less than the number
     of bits in an unsigned long, as do the PyLong <-> long (or unsigned long)
     conversion functions

   - the Python int <-> size_t/Py_ssize_t conversion functions expect that
     PyLong_SHIFT is strictly less than the number of bits in a size_t

   - the marshal code currently expects that PyLong_SHIFT is a multiple of 15

   - NSMALLNEGINTS and NSMALLPOSINTS should be small enough to fit in a single
     digit; with the current values this forces PyLong_SHIFT >= 9

  The values 15 and 30 should fit all of the above requirements, on any
  platform.
*/


typedef uint32_t digit;
typedef int32_t sdigit; /* signed variant of digit */
typedef uint64_t twodigits;
typedef int64_t stwodigits; /* signed variant of twodigits */





















/* Long integer representation.
   The absolute value of a number is equal to
        SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
   Negative numbers are represented with ob_size < 0;
   zero is represented by ob_size == 0.
   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant
   digit) is never zero.  Also, in all cases, for all valid i,
        0 <= ob_digit[i] <= MASK.
   The allocation function takes care of allocating extra memory
   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.

   CAUTION:  Generic code manipulating subtypes of PyVarObject has to
   aware that ints abuse  ob_size's sign bit.
*/

struct _longobject {
    PyVarObject ob_base;
    digit ob_digit[1];
};

__declspec(dllimport) PyLongObject * _PyLong_New(Py_ssize_t);

/* Return a copy of src. */
__declspec(dllimport) PyObject * _PyLong_Copy(PyLongObject *src);








/* Boolean object interface */








extern __declspec(dllimport) PyTypeObject PyBool_Type;



/* Py_False and Py_True are the only two bools in existence.
Don't forget to apply Py_INCREF() when returning either!!! */

/* Don't use these directly */
extern __declspec(dllimport) struct _longobject _Py_FalseStruct, _Py_TrueStruct;

/* Use these macros */



/* Macros for returning Py_True or Py_False, respectively */



/* Function to return a bool from a C long */
__declspec(dllimport) PyObject * PyBool_FromLong(long);








/* Float object interface */

/*
PyFloatObject represents a (double precision) floating point number.
*/








typedef struct {
    PyObject ob_base;
    double ob_fval;
} PyFloatObject;


extern __declspec(dllimport) PyTypeObject PyFloat_Type;















__declspec(dllimport) double PyFloat_GetMax(void);
__declspec(dllimport) double PyFloat_GetMin(void);
__declspec(dllimport) PyObject * PyFloat_GetInfo(void);

/* Return Python float from string PyObject. */
__declspec(dllimport) PyObject * PyFloat_FromString(PyObject*);

/* Return Python float from C double. */
__declspec(dllimport) PyObject * PyFloat_FromDouble(double);

/* Extract C double from Python float.  The macro version trades safety for
   speed. */
__declspec(dllimport) double PyFloat_AsDouble(PyObject *);





/* _PyFloat_{Pack,Unpack}{4,8}
 *
 * The struct and pickle (at least) modules need an efficient platform-
 * independent way to store floating-point values as byte strings.
 * The Pack routines produce a string from a C double, and the Unpack
 * routines produce a C double from such a string.  The suffix (4 or 8)
 * specifies the number of bytes in the string.
 *
 * On platforms that appear to use (see _PyFloat_Init()) IEEE-754 formats
 * these functions work by copying bits.  On other platforms, the formats the
 * 4- byte format is identical to the IEEE-754 single precision format, and
 * the 8-byte format to the IEEE-754 double precision format, although the
 * packing of INFs and NaNs (if such things exist on the platform) isn't
 * handled correctly, and attempting to unpack a string containing an IEEE
 * INF or NaN will raise an exception.
 *
 * On non-IEEE platforms with more precision, or larger dynamic range, than
 * 754 supports, not all values can be packed; on non-IEEE platforms with less
 * precision, or smaller dynamic range, not all values can be unpacked.  What
 * happens in such cases is partly accidental (alas).
 */

/* The pack routines write 2, 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if you want the string in little-endian format (exponent
 * last, at p+1, p+3 or p+7), false if you want big-endian format (exponent
 * first, at p).
 * Return value:  0 if all is OK, -1 if error (and an exception is
 * set, most likely OverflowError).
 * There are two problems on non-IEEE platforms:
 * 1):  What this does is undefined if x is a NaN or infinity.
 * 2):  -0.0 and +0.0 produce the same string.
 */
__declspec(dllimport) int _PyFloat_Pack2(double x, unsigned char *p, int le);
__declspec(dllimport) int _PyFloat_Pack4(double x, unsigned char *p, int le);
__declspec(dllimport) int _PyFloat_Pack8(double x, unsigned char *p, int le);

/* Needed for the old way for marshal to store a floating point number.
   Returns the string length copied into p, -1 on error.
 */
__declspec(dllimport) int _PyFloat_Repr(double x, char *p, size_t len);

/* Used to get the important decimal digits of a double */
__declspec(dllimport) int _PyFloat_Digits(char *buf, double v, int *signum);
__declspec(dllimport) void _PyFloat_DigitsInit(void);

/* The unpack routines read 2, 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if the string is in little-endian format (exponent
 * last, at p+1, p+3 or p+7), false if big-endian (exponent first, at p).
 * Return value:  The unpacked double.  On error, this is -1.0 and
 * PyErr_Occurred() is true (and an exception is set, most likely
 * OverflowError).  Note that on a non-IEEE platform this will refuse
 * to unpack a string that represents a NaN or infinity.
 */
__declspec(dllimport) double _PyFloat_Unpack2(const unsigned char *p, int le);
__declspec(dllimport) double _PyFloat_Unpack4(const unsigned char *p, int le);
__declspec(dllimport) double _PyFloat_Unpack8(const unsigned char *p, int le);

/* free list api */
__declspec(dllimport) int PyFloat_ClearFreeList(void);

__declspec(dllimport) void _PyFloat_DebugMallocStats(FILE* out);

/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
__declspec(dllimport) int _PyFloat_FormatAdvancedWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    PyObject *format_spec,
    Py_ssize_t start,
    Py_ssize_t end);








/* Complex number structure */








typedef struct {
    double real;
    double imag;
} Py_complex;

/* Operations on complex numbers from complexmodule.c */

__declspec(dllimport) Py_complex _Py_c_sum(Py_complex, Py_complex);
__declspec(dllimport) Py_complex _Py_c_diff(Py_complex, Py_complex);
__declspec(dllimport) Py_complex _Py_c_neg(Py_complex);
__declspec(dllimport) Py_complex _Py_c_prod(Py_complex, Py_complex);
__declspec(dllimport) Py_complex _Py_c_quot(Py_complex, Py_complex);
__declspec(dllimport) Py_complex _Py_c_pow(Py_complex, Py_complex);
__declspec(dllimport) double _Py_c_abs(Py_complex);


/* Complex object interface */

/*
PyComplexObject represents a complex number with double-precision
real and imaginary parts.
*/

typedef struct {
    PyObject ob_base;
    Py_complex cval;
} PyComplexObject;


extern __declspec(dllimport) PyTypeObject PyComplex_Type;





__declspec(dllimport) PyObject * PyComplex_FromCComplex(Py_complex);

__declspec(dllimport) PyObject * PyComplex_FromDoubles(double real, double imag);

__declspec(dllimport) double PyComplex_RealAsDouble(PyObject *op);
__declspec(dllimport) double PyComplex_ImagAsDouble(PyObject *op);

__declspec(dllimport) Py_complex PyComplex_AsCComplex(PyObject *op);


/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */

__declspec(dllimport) int _PyComplex_FormatAdvancedWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    PyObject *format_spec,
    Py_ssize_t start,
    Py_ssize_t end);









/* Range object interface */







/*
A range object represents an integer range.  This is an immutable object;
a range cannot change its value after creation.

Range objects behave like the corresponding tuple objects except that
they are represented by a start, stop, and step datamembers.
*/

extern __declspec(dllimport) PyTypeObject PyRange_Type;
extern __declspec(dllimport) PyTypeObject PyRangeIter_Type;
extern __declspec(dllimport) PyTypeObject PyLongRangeIter_Type;









/* Memory view object. In Python this is available as "memoryview". */








extern __declspec(dllimport) PyTypeObject _PyManagedBuffer_Type;

extern __declspec(dllimport) PyTypeObject PyMemoryView_Type;




/* Get a pointer to the memoryview's private copy of the exporter's buffer. */

/* Get a pointer to the exporting object (this may be NULL!). */



__declspec(dllimport) PyObject * PyMemoryView_FromObject(PyObject *base);

__declspec(dllimport) PyObject * PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
                                               int flags);


__declspec(dllimport) PyObject * PyMemoryView_FromBuffer(Py_buffer *info);

__declspec(dllimport) PyObject * PyMemoryView_GetContiguous(PyObject *base,
                                                  int buffertype,
                                                  char order);


/* The structs are declared here so that macros can work, but they shouldn't
   be considered public. Don't access their fields directly, use the macros
   and functions instead! */



typedef struct {
    PyObject ob_base;
    int flags;          /* state flags */
    Py_ssize_t exports; /* number of direct memoryview exports */
    Py_buffer master; /* snapshot buffer obtained from the original exporter */
} _PyManagedBufferObject;


/* memoryview state flags */






typedef struct {
    PyVarObject ob_base;
    _PyManagedBufferObject *mbuf; /* managed buffer */
    Py_hash_t hash;               /* hash value for read-only views */
    int flags;                    /* state flags */
    Py_ssize_t exports;           /* number of buffer re-exports */
    Py_buffer view;               /* private copy of the exporter's view */
    PyObject *weakreflist;
    Py_ssize_t ob_array[1];       /* shape, strides, suboffsets */
} PyMemoryViewObject;









/* Tuple object interface */







/*
Another generally useful object type is a tuple of object pointers.
For Python, this is an immutable type.  C code can change the tuple items
(but not their number), and even use tuples as general-purpose arrays of
object references, but in general only brand new tuples should be mutated,
not ones that might already have been exposed to Python code.

*** WARNING *** PyTuple_SetItem does not increment the new item's reference
count, but does decrement the reference count of the item it replaces,
if not nil.  It does *decrement* the reference count if it is *not*
inserted in the tuple.  Similarly, PyTuple_GetItem does not increment the
returned item's reference count.
*/


typedef struct {
    PyVarObject ob_base;
    PyObject *ob_item[1];

    /* ob_item contains space for 'ob_size' elements.
     * Items must normally not be NULL, except during construction when
     * the tuple is not yet visible outside the function that builds it.
     */
} PyTupleObject;


extern __declspec(dllimport) PyTypeObject PyTuple_Type;
extern __declspec(dllimport) PyTypeObject PyTupleIter_Type;





__declspec(dllimport) PyObject * PyTuple_New(Py_ssize_t size);
__declspec(dllimport) Py_ssize_t PyTuple_Size(PyObject *);
__declspec(dllimport) PyObject * PyTuple_GetItem(PyObject *, Py_ssize_t);
__declspec(dllimport) int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *);
__declspec(dllimport) PyObject * PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);

__declspec(dllimport) int _PyTuple_Resize(PyObject **, Py_ssize_t);

__declspec(dllimport) PyObject * PyTuple_Pack(Py_ssize_t, ...);

__declspec(dllimport) void _PyTuple_MaybeUntrack(PyObject *);


/* Macro, trading safety for speed */




/* Macro, *only* to be used to fill in brand new tuples */



__declspec(dllimport) int PyTuple_ClearFreeList(void);

__declspec(dllimport) void _PyTuple_DebugMallocStats(FILE *out);









/* List object interface */

/*
Another generally useful object type is a list of object pointers.
This is a mutable type: the list items can be changed, and items can be
added or removed.  Out-of-range indices or non-list objects are ignored.

*** WARNING *** PyList_SetItem does not increment the new item's reference
count, but does decrement the reference count of the item it replaces,
if not nil.  It does *decrement* the reference count if it is *not*
inserted in the list.  Similarly, PyList_GetItem does not increment the
returned item's reference count.
*/








typedef struct {
    PyVarObject ob_base;
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 <= ob_size <= allocated
     *     len(list) == ob_size
     *     ob_item == NULL implies ob_size == allocated == 0
     * list.sort() temporarily sets allocated to -1 to detect mutations.
     *
     * Items must normally not be NULL, except during construction when
     * the list is not yet visible outside the function that builds it.
     */
    Py_ssize_t allocated;
} PyListObject;


extern __declspec(dllimport) PyTypeObject PyList_Type;
extern __declspec(dllimport) PyTypeObject PyListIter_Type;
extern __declspec(dllimport) PyTypeObject PyListRevIter_Type;
extern __declspec(dllimport) PyTypeObject PySortWrapper_Type;





__declspec(dllimport) PyObject * PyList_New(Py_ssize_t size);
__declspec(dllimport) Py_ssize_t PyList_Size(PyObject *);
__declspec(dllimport) PyObject * PyList_GetItem(PyObject *, Py_ssize_t);
__declspec(dllimport) int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *);
__declspec(dllimport) int PyList_Insert(PyObject *, Py_ssize_t, PyObject *);
__declspec(dllimport) int PyList_Append(PyObject *, PyObject *);
__declspec(dllimport) PyObject * PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
__declspec(dllimport) int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
__declspec(dllimport) int PyList_Sort(PyObject *);
__declspec(dllimport) int PyList_Reverse(PyObject *);
__declspec(dllimport) PyObject * PyList_AsTuple(PyObject *);

__declspec(dllimport) PyObject * _PyList_Extend(PyListObject *, PyObject *);

__declspec(dllimport) int PyList_ClearFreeList(void);
__declspec(dllimport) void _PyList_DebugMallocStats(FILE *out);


/* Macro, trading safety for speed */




















/* Dictionary object type -- mapping from hashable object to object */

/* The distribution includes a separate file, Objects/dictnotes.txt,
   describing explorations into dictionary design and optimization.
   It covers typical dictionary use patterns, the parameters for
   tuning dictionaries, and several ideas for possible optimizations.
*/



typedef struct _dictkeysobject PyDictKeysObject;

/* The ma_values pointer is NULL for a combined table
 * or points to an array of PyObject* for a split table
 */
typedef struct {
    PyObject ob_base;

    /* Number of items in the dictionary */
    Py_ssize_t ma_used;

    /* Dictionary version: globally unique, value change each time
       the dictionary is modified */
    uint64_t ma_version_tag;

    PyDictKeysObject *ma_keys;

    /* If ma_values is NULL, the table is "combined": keys and values
       are stored in ma_keys.

       If ma_values is not NULL, the table is splitted:
       keys are stored in ma_keys and values are stored in ma_values */
    PyObject **ma_values;
} PyDictObject;

typedef struct {
    PyObject ob_base;
    PyDictObject *dv_dict;
} _PyDictViewObject;



extern __declspec(dllimport) PyTypeObject PyDict_Type;
extern __declspec(dllimport) PyTypeObject PyDictIterKey_Type;
extern __declspec(dllimport) PyTypeObject PyDictIterValue_Type;
extern __declspec(dllimport) PyTypeObject PyDictIterItem_Type;
extern __declspec(dllimport) PyTypeObject PyDictKeys_Type;
extern __declspec(dllimport) PyTypeObject PyDictItems_Type;
extern __declspec(dllimport) PyTypeObject PyDictValues_Type;







/* This excludes Values, since they are not sets. */




__declspec(dllimport) PyObject * PyDict_New(void);
__declspec(dllimport) PyObject * PyDict_GetItem(PyObject *mp, PyObject *key);

__declspec(dllimport) PyObject * _PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key,
                                       Py_hash_t hash);

__declspec(dllimport) PyObject * PyDict_GetItemWithError(PyObject *mp, PyObject *key);

__declspec(dllimport) PyObject * _PyDict_GetItemIdWithError(PyObject *dp,
                                                  struct _Py_Identifier *key);
__declspec(dllimport) PyObject * PyDict_SetDefault(
    PyObject *mp, PyObject *key, PyObject *defaultobj);

__declspec(dllimport) int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);

__declspec(dllimport) int _PyDict_SetItem_KnownHash(PyObject *mp, PyObject *key,
                                          PyObject *item, Py_hash_t hash);

__declspec(dllimport) int PyDict_DelItem(PyObject *mp, PyObject *key);

__declspec(dllimport) int _PyDict_DelItem_KnownHash(PyObject *mp, PyObject *key,
                                          Py_hash_t hash);
__declspec(dllimport) int _PyDict_DelItemIf(PyObject *mp, PyObject *key,
                                  int (*predicate)(PyObject *value));

__declspec(dllimport) void PyDict_Clear(PyObject *mp);
__declspec(dllimport) int PyDict_Next(
    PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);

PyDictKeysObject *_PyDict_NewKeysForClass(void);
__declspec(dllimport) PyObject * PyObject_GenericGetDict(PyObject *, void *);
__declspec(dllimport) int _PyDict_Next(
    PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, Py_hash_t *hash);
PyObject *_PyDictView_New(PyObject *, PyTypeObject *);

__declspec(dllimport) PyObject * PyDict_Keys(PyObject *mp);
__declspec(dllimport) PyObject * PyDict_Values(PyObject *mp);
__declspec(dllimport) PyObject * PyDict_Items(PyObject *mp);
__declspec(dllimport) Py_ssize_t PyDict_Size(PyObject *mp);
__declspec(dllimport) PyObject * PyDict_Copy(PyObject *mp);
__declspec(dllimport) int PyDict_Contains(PyObject *mp, PyObject *key);

/* Get the number of items of a dictionary. */

__declspec(dllimport) int _PyDict_Contains(PyObject *mp, PyObject *key, Py_hash_t hash);
__declspec(dllimport) PyObject * _PyDict_NewPresized(Py_ssize_t minused);
__declspec(dllimport) void _PyDict_MaybeUntrack(PyObject *mp);
__declspec(dllimport) int _PyDict_HasOnlyStringKeys(PyObject *mp);
Py_ssize_t _PyDict_KeysSize(PyDictKeysObject *keys);
__declspec(dllimport) Py_ssize_t _PyDict_SizeOf(PyDictObject *);
__declspec(dllimport) PyObject * _PyDict_Pop(PyObject *, PyObject *, PyObject *);
PyObject *_PyDict_Pop_KnownHash(PyObject *, PyObject *, Py_hash_t, PyObject *);
PyObject *_PyDict_FromKeys(PyObject *, PyObject *, PyObject *);


__declspec(dllimport) int PyDict_ClearFreeList(void);


/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
__declspec(dllimport) int PyDict_Update(PyObject *mp, PyObject *other);

/* PyDict_Merge updates/merges from a mapping object (an object that
   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
   the last occurrence of a key wins, else the first.  The Python
   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
*/
__declspec(dllimport) int PyDict_Merge(PyObject *mp,
                                   PyObject *other,
                                   int override);


/* Like PyDict_Merge, but override can be 0, 1 or 2.  If override is 0,
   the first occurrence of a key wins, if override is 1, the last occurrence
   of a key wins, if override is 2, a KeyError with conflicting key as
   argument is raised.
*/
__declspec(dllimport) int _PyDict_MergeEx(PyObject *mp, PyObject *other, int override);
__declspec(dllimport) PyObject * _PyDictView_Intersect(PyObject* self, PyObject *other);


/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
   iterable objects of length 2.  If override is true, the last occurrence
   of a key wins, else the first.  The Python dict constructor dict(seq2)
   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
*/
__declspec(dllimport) int PyDict_MergeFromSeq2(PyObject *d,
                                           PyObject *seq2,
                                           int override);

__declspec(dllimport) PyObject * PyDict_GetItemString(PyObject *dp, const char *key);

__declspec(dllimport) PyObject * _PyDict_GetItemId(PyObject *dp, struct _Py_Identifier *key);

__declspec(dllimport) int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);

__declspec(dllimport) int _PyDict_SetItemId(PyObject *dp, struct _Py_Identifier *key, PyObject *item);

__declspec(dllimport) int PyDict_DelItemString(PyObject *dp, const char *key);


__declspec(dllimport) int _PyDict_DelItemId(PyObject *mp, struct _Py_Identifier *key);
__declspec(dllimport) void _PyDict_DebugMallocStats(FILE *out);

int _PyObjectDict_SetItem(PyTypeObject *tp, PyObject **dictptr, PyObject *name, PyObject *value);
PyObject *_PyDict_LoadGlobal(PyDictObject *, PyDictObject *, PyObject *);















/* OrderedDict */
/* This API is optional and mostly redundant. */



typedef struct _odictobject PyODictObject;

extern __declspec(dllimport) PyTypeObject PyODict_Type;
extern __declspec(dllimport) PyTypeObject PyODictIter_Type;
extern __declspec(dllimport) PyTypeObject PyODictKeys_Type;
extern __declspec(dllimport) PyTypeObject PyODictItems_Type;
extern __declspec(dllimport) PyTypeObject PyODictValues_Type;





__declspec(dllimport) PyObject * PyODict_New(void);
__declspec(dllimport) int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item);
__declspec(dllimport) int PyODict_DelItem(PyObject *od, PyObject *key);

/* wrappers around PyDict* functions */



















/* Enumerate Object */





extern __declspec(dllimport) PyTypeObject PyEnum_Type;
extern __declspec(dllimport) PyTypeObject PyReversed_Type;








/* Set object interface */









/* There are three kinds of entries in the table:

1. Unused:  key == NULL and hash == 0
2. Dummy:   key == dummy and hash == -1
3. Active:  key != NULL and key != dummy and hash != -1

The hash field of Unused slots is always zero.

The hash field of Dummy slots are set to -1
meaning that dummy entries can be detected by
either entry->key==dummy or by entry->hash==-1.
*/



typedef struct {
    PyObject *key;
    Py_hash_t hash;             /* Cached hash code of the key */
} setentry;

/* The SetObject data structure is shared by set and frozenset objects.

Invariant for sets:
 - hash is -1

Invariants for frozensets:
 - data is immutable.
 - hash is the hash of the frozenset or -1 if not computed yet.

*/

typedef struct {
    PyObject ob_base;

    Py_ssize_t fill;            /* Number active and dummy entries*/
    Py_ssize_t used;            /* Number active entries */

    /* The table contains mask + 1 slots, and that's a power of 2.
     * We store the mask instead of the size because the mask is more
     * frequently needed.
     */
    Py_ssize_t mask;

    /* The table points to a fixed-size smalltable for small tables
     * or to additional malloc'ed memory for bigger tables.
     * The table pointer is never NULL which saves us from repeated
     * runtime null-tests.
     */
    setentry *table;
    Py_hash_t hash;             /* Only used by frozenset objects */
    Py_ssize_t finger;          /* Search finger for pop() */

    setentry smalltable[8];
    PyObject *weakreflist;      /* List of weak references */
} PySetObject;



extern __declspec(dllimport) PyObject * _PySet_Dummy;

__declspec(dllimport) int _PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, Py_hash_t *hash);
__declspec(dllimport) int _PySet_Update(PyObject *set, PyObject *iterable);
__declspec(dllimport) int PySet_ClearFreeList(void);



extern __declspec(dllimport) PyTypeObject PySet_Type;
extern __declspec(dllimport) PyTypeObject PyFrozenSet_Type;
extern __declspec(dllimport) PyTypeObject PySetIter_Type;

__declspec(dllimport) PyObject * PySet_New(PyObject *);
__declspec(dllimport) PyObject * PyFrozenSet_New(PyObject *);

__declspec(dllimport) int PySet_Add(PyObject *set, PyObject *key);
__declspec(dllimport) int PySet_Clear(PyObject *set);
__declspec(dllimport) int PySet_Contains(PyObject *anyset, PyObject *key);
__declspec(dllimport) int PySet_Discard(PyObject *set, PyObject *key);
__declspec(dllimport) PyObject * PySet_Pop(PyObject *set);
__declspec(dllimport) Py_ssize_t PySet_Size(PyObject *anyset);






















/* Method object interface */







/* This is about the type 'builtin_function_or_method',
   not Python methods in user-defined classes.  See classobject.h
   for the latter. */

extern __declspec(dllimport) PyTypeObject PyCFunction_Type;



typedef PyObject *(*PyCFunction)(PyObject *, PyObject *);
typedef PyObject *(*_PyCFunctionFast) (PyObject *, PyObject *const *, Py_ssize_t);
typedef PyObject *(*PyCFunctionWithKeywords)(PyObject *, PyObject *,
                                             PyObject *);
typedef PyObject *(*_PyCFunctionFastWithKeywords) (PyObject *,
                                                   PyObject *const *, Py_ssize_t,
                                                   PyObject *);
typedef PyObject *(*PyNoArgsFunction)(PyObject *);

__declspec(dllimport) PyCFunction PyCFunction_GetFunction(PyObject *);
__declspec(dllimport) PyObject * PyCFunction_GetSelf(PyObject *);
__declspec(dllimport) int PyCFunction_GetFlags(PyObject *);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */









__declspec(dllimport) PyObject * PyCFunction_Call(PyObject *, PyObject *, PyObject *);


__declspec(dllimport) PyObject * _PyCFunction_FastCallDict(PyObject *func,
    PyObject *const *args,
    Py_ssize_t nargs,
    PyObject *kwargs);

__declspec(dllimport) PyObject * _PyCFunction_FastCallKeywords(PyObject *func,
    PyObject *const *stack,
    Py_ssize_t nargs,
    PyObject *kwnames);


struct PyMethodDef {
    const char  *ml_name;   /* The name of the built-in function/method */
    PyCFunction ml_meth;    /* The C function that implements it */
    int         ml_flags;   /* Combination of METH_xxx flags, which mostly
                               describe the args expected by the C func */
    const char  *ml_doc;    /* The __doc__ attribute, or NULL */
};
typedef struct PyMethodDef PyMethodDef;


__declspec(dllimport) PyObject * PyCFunction_NewEx(PyMethodDef *, PyObject *,
                                         PyObject *);

/* Flag passed to newmethodobject */
/* #define METH_OLDARGS  0x0000   -- unsupported now */


/* METH_NOARGS and METH_O must not be combined with the flags above. */



/* METH_CLASS and METH_STATIC are a little different; these control
   the construction of methods for a class.  These cannot be used for
   functions in modules. */



/* METH_COEXIST allows a method to be entered even though a slot has
   already filled the entry.  When defined, the flag allows a separate
   method, "__contains__" for example, to coexist with a defined
   slot like sq_contains. */







/* This bit is preserved for Stackless Python */







typedef struct {
    PyObject ob_base;
    PyMethodDef *m_ml; /* Description of the C function to call */
    PyObject    *m_self; /* Passed as 'self' arg to the C func, can be NULL */
    PyObject    *m_module; /* The __module__ attribute, can be anything */
    PyObject    *m_weakreflist; /* List of weak references */
} PyCFunctionObject;

__declspec(dllimport) PyObject * _PyMethodDef_RawFastCallDict(
    PyMethodDef *method,
    PyObject *self,
    PyObject *const *args,
    Py_ssize_t nargs,
    PyObject *kwargs);

__declspec(dllimport) PyObject * _PyMethodDef_RawFastCallKeywords(
    PyMethodDef *method,
    PyObject *self,
    PyObject *const *args,
    Py_ssize_t nargs,
    PyObject *kwnames);


__declspec(dllimport) int PyCFunction_ClearFreeList(void);


__declspec(dllimport) void _PyCFunction_DebugMallocStats(FILE *out);
__declspec(dllimport) void _PyMethod_DebugMallocStats(FILE *out);









/* Module object interface */







extern __declspec(dllimport) PyTypeObject PyModule_Type;





__declspec(dllimport) PyObject * PyModule_NewObject(
    PyObject *name
    );

__declspec(dllimport) PyObject * PyModule_New(
    const char *name            /* UTF-8 encoded string */
    );
__declspec(dllimport) PyObject * PyModule_GetDict(PyObject *);

__declspec(dllimport) PyObject * PyModule_GetNameObject(PyObject *);

__declspec(dllimport) const char * PyModule_GetName(PyObject *);
__declspec(dllimport) const char * PyModule_GetFilename(PyObject *) ;
__declspec(dllimport) PyObject * PyModule_GetFilenameObject(PyObject *);

__declspec(dllimport) void _PyModule_Clear(PyObject *);
__declspec(dllimport) void _PyModule_ClearDict(PyObject *);

__declspec(dllimport) struct PyModuleDef* PyModule_GetDef(PyObject*);
__declspec(dllimport) void* PyModule_GetState(PyObject*);


/* New in 3.5 */
__declspec(dllimport) PyObject * PyModuleDef_Init(struct PyModuleDef*);
extern __declspec(dllimport) PyTypeObject PyModuleDef_Type;


typedef struct PyModuleDef_Base {
  PyObject ob_base;
  PyObject* (*m_init)(void);
  Py_ssize_t m_index;
  PyObject* m_copy;
} PyModuleDef_Base;








struct PyModuleDef_Slot;

/* New in 3.5 */
typedef struct PyModuleDef_Slot{
    int slot;
    void *value;
} PyModuleDef_Slot;










typedef struct PyModuleDef{
  PyModuleDef_Base m_base;
  const char* m_name;
  const char* m_doc;
  Py_ssize_t m_size;
  PyMethodDef *m_methods;
  struct PyModuleDef_Slot* m_slots;
  traverseproc m_traverse;
  inquiry m_clear;
  freefunc m_free;
} PyModuleDef;








/* Function object interface */







/* Function objects and code objects should not be confused with each other:
 *
 * Function objects are created by the execution of the 'def' statement.
 * They reference a code object in their __code__ attribute, which is a
 * purely syntactic object, i.e. nothing more than a compiled version of some
 * source code lines.  There is one code object per source code "fragment",
 * but each code object can be referenced by zero or many function objects
 * depending only on how many times the 'def' statement in the source was
 * executed so far.
 */

typedef struct {
    PyObject ob_base;
    PyObject *func_code;        /* A code object, the __code__ attribute */
    PyObject *func_globals;     /* A dictionary (other mappings won't do) */
    PyObject *func_defaults;    /* NULL or a tuple */
    PyObject *func_kwdefaults;  /* NULL or a dict */
    PyObject *func_closure;     /* NULL or a tuple of cell objects */
    PyObject *func_doc;         /* The __doc__ attribute, can be anything */
    PyObject *func_name;        /* The __name__ attribute, a string object */
    PyObject *func_dict;        /* The __dict__ attribute, a dict or NULL */
    PyObject *func_weakreflist; /* List of weak references */
    PyObject *func_module;      /* The __module__ attribute, can be anything */
    PyObject *func_annotations; /* Annotations, a dict or NULL */
    PyObject *func_qualname;    /* The qualified name */

    /* Invariant:
     *     func_closure contains the bindings for func_code->co_freevars, so
     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)
     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).
     */
} PyFunctionObject;

extern __declspec(dllimport) PyTypeObject PyFunction_Type;



__declspec(dllimport) PyObject * PyFunction_New(PyObject *, PyObject *);
__declspec(dllimport) PyObject * PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *);
__declspec(dllimport) PyObject * PyFunction_GetCode(PyObject *);
__declspec(dllimport) PyObject * PyFunction_GetGlobals(PyObject *);
__declspec(dllimport) PyObject * PyFunction_GetModule(PyObject *);
__declspec(dllimport) PyObject * PyFunction_GetDefaults(PyObject *);
__declspec(dllimport) int PyFunction_SetDefaults(PyObject *, PyObject *);
__declspec(dllimport) PyObject * PyFunction_GetKwDefaults(PyObject *);
__declspec(dllimport) int PyFunction_SetKwDefaults(PyObject *, PyObject *);
__declspec(dllimport) PyObject * PyFunction_GetClosure(PyObject *);
__declspec(dllimport) int PyFunction_SetClosure(PyObject *, PyObject *);
__declspec(dllimport) PyObject * PyFunction_GetAnnotations(PyObject *);
__declspec(dllimport) int PyFunction_SetAnnotations(PyObject *, PyObject *);


__declspec(dllimport) PyObject * _PyFunction_FastCallDict(
    PyObject *func,
    PyObject *const *args,
    Py_ssize_t nargs,
    PyObject *kwargs);

__declspec(dllimport) PyObject * _PyFunction_FastCallKeywords(
    PyObject *func,
    PyObject *const *stack,
    Py_ssize_t nargs,
    PyObject *kwnames);


/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */















/* The classmethod and staticmethod types lives here, too */
extern __declspec(dllimport) PyTypeObject PyClassMethod_Type;
extern __declspec(dllimport) PyTypeObject PyStaticMethod_Type;

__declspec(dllimport) PyObject * PyClassMethod_New(PyObject *);
__declspec(dllimport) PyObject * PyStaticMethod_New(PyObject *);








/* Former class object interface -- now only bound methods are here  */

/* Revealing some structures (not for general use) */








typedef struct {
    PyObject ob_base;
    PyObject *im_func;   /* The callable object implementing the method */
    PyObject *im_self;   /* The instance it is bound to */
    PyObject *im_weakreflist; /* List of weak references */
} PyMethodObject;

extern __declspec(dllimport) PyTypeObject PyMethod_Type;



__declspec(dllimport) PyObject * PyMethod_New(PyObject *, PyObject *);

__declspec(dllimport) PyObject * PyMethod_Function(PyObject *);
__declspec(dllimport) PyObject * PyMethod_Self(PyObject *);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */





__declspec(dllimport) int PyMethod_ClearFreeList(void);

typedef struct {
    PyObject ob_base;
    PyObject *func;
} PyInstanceMethodObject;

extern __declspec(dllimport) PyTypeObject PyInstanceMethod_Type;



__declspec(dllimport) PyObject * PyInstanceMethod_New(PyObject *);
__declspec(dllimport) PyObject * PyInstanceMethod_Function(PyObject *);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */










/* File object interface (what's left of it -- see io.py) */









__declspec(dllimport) PyObject * PyFile_FromFd(int, const char *, const char *, int,
                                     const char *, const char *,
                                     const char *, int);
__declspec(dllimport) PyObject * PyFile_GetLine(PyObject *, int);
__declspec(dllimport) int PyFile_WriteObject(PyObject *, PyObject *, int);
__declspec(dllimport) int PyFile_WriteString(const char *, PyObject *);
__declspec(dllimport) int PyObject_AsFileDescriptor(PyObject *);

__declspec(dllimport) char * Py_UniversalNewlineFgets(char *, int, FILE*, PyObject *);


/* The default encoding used by the platform file system APIs
   If non-NULL, this is different than the default encoding for strings
*/
extern __declspec(dllimport) const char * Py_FileSystemDefaultEncoding;

extern __declspec(dllimport) const char * Py_FileSystemDefaultEncodeErrors;

extern __declspec(dllimport) int Py_HasFileSystemDefaultEncoding;


extern __declspec(dllimport) int Py_UTF8Mode;


/* Internal API

   The std printer acts as a preliminary sys.stderr until the new io
   infrastructure is in place. */

__declspec(dllimport) PyObject * PyFile_NewStdPrinter(int);
extern __declspec(dllimport) PyTypeObject PyStdPrinter_Type;


/* A routine to check if a file descriptor can be select()-ed. */

    /* On Windows, any socket fd can be select()-ed, no matter how high */
    











/* Capsule objects let you wrap a C "void *" pointer in a Python
   object.  They're a way of passing data through the Python interpreter
   without creating your own custom type.

   Capsules are used for communication between extension modules.
   They provide a way for an extension module to export a C interface
   to other extension modules, so that extension modules can use the
   Python import mechanism to link to one another.

   For more information, please see "c-api/capsule.html" in the
   documentation.
*/







extern __declspec(dllimport) PyTypeObject PyCapsule_Type;

typedef void (*PyCapsule_Destructor)(PyObject *);




__declspec(dllimport) PyObject * PyCapsule_New(
    void *pointer,
    const char *name,
    PyCapsule_Destructor destructor);

__declspec(dllimport) void * PyCapsule_GetPointer(PyObject *capsule, const char *name);

__declspec(dllimport) PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule);

__declspec(dllimport) const char * PyCapsule_GetName(PyObject *capsule);

__declspec(dllimport) void * PyCapsule_GetContext(PyObject *capsule);

__declspec(dllimport) int PyCapsule_IsValid(PyObject *capsule, const char *name);

__declspec(dllimport) int PyCapsule_SetPointer(PyObject *capsule, void *pointer);

__declspec(dllimport) int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor);

__declspec(dllimport) int PyCapsule_SetName(PyObject *capsule, const char *name);

__declspec(dllimport) int PyCapsule_SetContext(PyObject *capsule, void *context);

__declspec(dllimport) void * PyCapsule_Import(
    const char *name,           /* UTF-8 encoded string */
    int no_block);

















/* Thread and interpreter state structures and their interfaces */













typedef void *PyThread_type_lock;
typedef void *PyThread_type_sema;





/* Return status codes for Python lock acquisition.  Chosen for maximum
 * backwards compatibility, ie failure -> 0, success -> 1.  */
typedef enum PyLockStatus {
    PY_LOCK_FAILURE = 0,
    PY_LOCK_ACQUIRED = 1,
    PY_LOCK_INTR
} PyLockStatus;





__declspec(dllimport) void PyThread_init_thread(void);
__declspec(dllimport) unsigned long PyThread_start_new_thread(void (*)(void *), void *);
__declspec(dllimport) void PyThread_exit_thread(void);
__declspec(dllimport) unsigned long PyThread_get_thread_ident(void);

__declspec(dllimport) PyThread_type_lock PyThread_allocate_lock(void);
__declspec(dllimport) void PyThread_free_lock(PyThread_type_lock);
__declspec(dllimport) int PyThread_acquire_lock(PyThread_type_lock, int);



/* PY_TIMEOUT_T is the integral type used to specify timeouts when waiting
   on a lock (see PyThread_acquire_lock_timed() below).
   PY_TIMEOUT_MAX is the highest usable value (in microseconds) of that
   type, and depends on the system threading API.

   NOTE: this isn't the same value as `_thread.TIMEOUT_MAX`.  The _thread
   module exposes a higher-level API, with timeouts expressed in seconds
   and floating-point numbers allowed.
*/







   /* In the NT API, the timeout is a DWORD and is expressed in milliseconds */










/* If microseconds == 0, the call is non-blocking: it returns immediately
   even when the lock can't be acquired.
   If microseconds > 0, the call waits up to the specified duration.
   If microseconds < 0, the call waits until success (or abnormal failure)

   microseconds must be less than PY_TIMEOUT_MAX. Behaviour otherwise is
   undefined.

   If intr_flag is true and the acquire is interrupted by a signal, then the
   call will return PY_LOCK_INTR.  The caller may reattempt to acquire the
   lock.
*/
__declspec(dllimport) PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock,
                                                     long long microseconds,
                                                     int intr_flag);

__declspec(dllimport) void PyThread_release_lock(PyThread_type_lock);

__declspec(dllimport) size_t PyThread_get_stacksize(void);
__declspec(dllimport) int PyThread_set_stacksize(size_t);


__declspec(dllimport) PyObject* PyThread_GetInfo(void);



/* Thread Local Storage (TLS) API
   TLS API is DEPRECATED.  Use Thread Specific Storage (TSS) API.

   The existing TLS API has used int to represent TLS keys across all
   platforms, but it is not POSIX-compliant.  Therefore, the new TSS API uses
   opaque data type to represent TSS keys to be compatible (see PEP 539).
*/
__declspec(dllimport) int PyThread_create_key(void) ;
__declspec(dllimport) void PyThread_delete_key(int key) ;
__declspec(dllimport) int PyThread_set_key_value(int key, void *value) ;
__declspec(dllimport) void * PyThread_get_key_value(int key) ;
__declspec(dllimport) void PyThread_delete_key_value(int key) ;

/* Cleanup after a fork */
__declspec(dllimport) void PyThread_ReInitTLS(void) ;



/* New in 3.7 */
/* Thread Specific Storage (TSS) API */

typedef struct _Py_tss_t Py_tss_t;  /* opaque */







    /* In Windows, native TSS key type is DWORD,
       but hardcode the unsigned long to avoid errors for include directive.
    */





/* When Py_LIMITED_API is not defined, the type layout of Py_tss_t is
   exposed to allow static allocation in the API clients.  Even in this case,
   you must handle TSS keys through API functions due to compatibility.
*/
struct _Py_tss_t {
    int _is_initialized;
    unsigned long _key;
};



/* When static allocation, you must initialize with Py_tss_NEEDS_INIT. */



__declspec(dllimport) Py_tss_t * PyThread_tss_alloc(void);
__declspec(dllimport) void PyThread_tss_free(Py_tss_t *key);

/* The parameter key must not be NULL. */
__declspec(dllimport) int PyThread_tss_is_created(Py_tss_t *key);
__declspec(dllimport) int PyThread_tss_create(Py_tss_t *key);
__declspec(dllimport) void PyThread_tss_delete(Py_tss_t *key);
__declspec(dllimport) int PyThread_tss_set(Py_tss_t *key, void *value);
__declspec(dllimport) void * PyThread_tss_get(Py_tss_t *key);









/* This limitation is for performance and simplicity. If needed it can be
removed (with effort). */


/* State shared between threads */

struct _ts; /* Forward */
struct _is; /* Forward */
struct _frame; /* Forward declaration for PyFrameObject. */




typedef PyObject* (*_PyFrameEvalFunction)(struct _frame *, int);


typedef struct {
    int install_signal_handlers;  /* Install signal handlers? -1 means unset */

    int ignore_environment; /* -E, Py_IgnoreEnvironmentFlag */
    int use_hash_seed;      /* PYTHONHASHSEED=x */
    unsigned long hash_seed;
    const char *allocator;  /* Memory allocator: _PyMem_SetupAllocators() */
    int dev_mode;           /* PYTHONDEVMODE, -X dev */
    int faulthandler;       /* PYTHONFAULTHANDLER, -X faulthandler */
    int tracemalloc;        /* PYTHONTRACEMALLOC, -X tracemalloc=N */
    int import_time;        /* PYTHONPROFILEIMPORTTIME, -X importtime */
    int show_ref_count;     /* -X showrefcount */
    int show_alloc_count;   /* -X showalloccount */
    int dump_refs;          /* PYTHONDUMPREFS */
    int malloc_stats;       /* PYTHONMALLOCSTATS */
    int coerce_c_locale;    /* PYTHONCOERCECLOCALE, -1 means unknown */
    int coerce_c_locale_warn; /* PYTHONCOERCECLOCALE=warn */
    int utf8_mode;          /* PYTHONUTF8, -X utf8; -1 means unknown */

    wchar_t *program_name;  /* Program name, see also Py_GetProgramName() */
    int argc;               /* Number of command line arguments,
                               -1 means unset */
    wchar_t **argv;         /* Command line arguments */
    wchar_t *program;       /* argv[0] or "" */

    int nxoption;           /* Number of -X options */
    wchar_t **xoptions;     /* -X options */

    int nwarnoption;        /* Number of warnings options */
    wchar_t **warnoptions;  /* Warnings options */

    /* Path configuration inputs */
    wchar_t *module_search_path_env; /* PYTHONPATH environment variable */
    wchar_t *home;          /* PYTHONHOME environment variable,
                               see also Py_SetPythonHome(). */

    /* Path configuration outputs */
    int nmodule_search_path;        /* Number of sys.path paths,
                                       -1 means unset */
    wchar_t **module_search_paths;  /* sys.path paths */
    wchar_t *executable;    /* sys.executable */
    wchar_t *prefix;        /* sys.prefix */
    wchar_t *base_prefix;   /* sys.base_prefix */
    wchar_t *exec_prefix;   /* sys.exec_prefix */
    wchar_t *base_exec_prefix;  /* sys.base_exec_prefix */

    /* Private fields */
    int _disable_importlib; /* Needed by freeze_importlib */
} _PyCoreConfig;









/* Note: _PyCoreConfig_INIT sets other fields to 0/NULL */

/* Placeholders while working on the new configuration API
 *
 * See PEP 432 for final anticipated contents
 */
typedef struct {
    int install_signal_handlers;   /* Install signal handlers? -1 means unset */
    PyObject *argv;                /* sys.argv list, can be NULL */
    PyObject *executable;          /* sys.executable str */
    PyObject *prefix;              /* sys.prefix str */
    PyObject *base_prefix;         /* sys.base_prefix str, can be NULL */
    PyObject *exec_prefix;         /* sys.exec_prefix str */
    PyObject *base_exec_prefix;    /* sys.base_exec_prefix str, can be NULL */
    PyObject *warnoptions;         /* sys.warnoptions list, can be NULL */
    PyObject *xoptions;            /* sys._xoptions dict, can be NULL */
    PyObject *module_search_path;  /* sys.path list */
} _PyMainInterpreterConfig;



/* Note: _PyMainInterpreterConfig_INIT sets other fields to 0/NULL */

typedef struct _is {

    struct _is *next;
    struct _ts *tstate_head;

    int64_t id;
    int64_t id_refcount;
    PyThread_type_lock id_mutex;

    PyObject *modules;
    PyObject *modules_by_index;
    PyObject *sysdict;
    PyObject *builtins;
    PyObject *importlib;

    /* Used in Python/sysmodule.c. */
    int check_interval;

    /* Used in Modules/_threadmodule.c. */
    long num_threads;
    /* Support for runtime thread stack size tuning.
       A value of 0 means using the platform's default stack size
       or the size specified by the THREAD_STACK_SIZE macro. */
    /* Used in Python/thread.c. */
    size_t pythread_stacksize;

    PyObject *codec_search_path;
    PyObject *codec_search_cache;
    PyObject *codec_error_registry;
    int codecs_initialized;
    int fscodec_initialized;

    _PyCoreConfig core_config;
    _PyMainInterpreterConfig config;




    PyObject *builtins_copy;
    PyObject *import_func;
    /* Initialized to PyEval_EvalFrameDefault(). */
    _PyFrameEvalFunction eval_frame;

    Py_ssize_t co_extra_user_count;
    freefunc co_extra_freefuncs[255];






    /* AtExit module */
    void (*pyexitfunc)(PyObject *);
    PyObject *pyexitmodule;

    uint64_t tstate_next_unique_id;
} PyInterpreterState;



/* State unique per thread */


/* Py_tracefunc return -1 when raising an exception, or 0 for success. */
typedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);

/* The following values are used for 'what' for tracefunc functions
 *
 * To add a new kind of trace event, also update "trace_init" in
 * Python/sysmodule.c to define the Python level event name
 */














typedef struct _err_stackitem {
    /* This struct represents an entry on the exception stack, which is a
     * per-coroutine state. (Coroutine in the computer science sense,
     * including the thread and generators).
     * This ensures that the exception state is not impacted by "yields"
     * from an except handler.
     */
    PyObject *exc_type, *exc_value, *exc_traceback;

    struct _err_stackitem *previous_item;

} _PyErr_StackItem;


typedef struct _ts {
    /* See Python/ceval.c for comments explaining most fields */

    struct _ts *prev;
    struct _ts *next;
    PyInterpreterState *interp;

    struct _frame *frame;
    int recursion_depth;
    char overflowed; /* The stack has overflowed. Allow 50 more calls
                        to handle the runtime error. */
    char recursion_critical; /* The current calls must not cause
                                a stack overflow. */
    int stackcheck_counter;

    /* 'tracing' keeps track of the execution depth when tracing/profiling.
       This is to prevent the actual trace/profile code from being recorded in
       the trace/profile. */
    int tracing;
    int use_tracing;

    Py_tracefunc c_profilefunc;
    Py_tracefunc c_tracefunc;
    PyObject *c_profileobj;
    PyObject *c_traceobj;

    /* The exception currently being raised */
    PyObject *curexc_type;
    PyObject *curexc_value;
    PyObject *curexc_traceback;

    /* The exception currently being handled, if no coroutines/generators
     * are present. Always last element on the stack referred to be exc_info.
     */
    _PyErr_StackItem exc_state;

    /* Pointer to the top of the stack of the exceptions currently
     * being handled */
    _PyErr_StackItem *exc_info;

    PyObject *dict;  /* Stores per-thread state */

    int gilstate_counter;

    PyObject *async_exc; /* Asynchronous exception to raise */
    unsigned long thread_id; /* Thread id where this tstate was created */

    int trash_delete_nesting;
    PyObject *trash_delete_later;

    /* Called when a thread state is deleted normally, but not when it
     * is destroyed after fork().
     * Pain:  to prevent rare but fatal shutdown errors (issue 18808),
     * Thread.join() must wait for the join'ed thread's tstate to be unlinked
     * from the tstate chain.  That happens at the end of a thread's life,
     * in pystate.c.
     * The obvious way doesn't quite work:  create a lock which the tstate
     * unlinking code releases, and have Thread.join() wait to acquire that
     * lock.  The problem is that we _are_ at the end of the thread's life:
     * if the thread holds the last reference to the lock, decref'ing the
     * lock will delete the lock, and that may trigger arbitrary Python code
     * if there's a weakref, with a callback, to the lock.  But by this time
     * _PyThreadState_Current is already NULL, so only the simplest of C code
     * can be allowed to run (in particular it must not be possible to
     * release the GIL).
     * So instead of holding the lock directly, the tstate holds a weakref to
     * the lock:  that's the value of on_delete_data below.  Decref'ing a
     * weakref is harmless.
     * on_delete points to _threadmodule.c's static release_sentinel() function.
     * After the tstate is unlinked, release_sentinel is called with the
     * weakref-to-lock (on_delete_data) argument, and release_sentinel releases
     * the indirectly held lock.
     */
    void (*on_delete)(void *);
    void *on_delete_data;

    int coroutine_origin_tracking_depth;

    PyObject *coroutine_wrapper;
    int in_coroutine_wrapper;

    PyObject *async_gen_firstiter;
    PyObject *async_gen_finalizer;

    PyObject *context;
    uint64_t context_ver;

    /* Unique thread state id. */
    uint64_t id;

    /* XXX signal handlers should also be here */

} PyThreadState;



__declspec(dllimport) PyInterpreterState * PyInterpreterState_New(void);
__declspec(dllimport) void PyInterpreterState_Clear(PyInterpreterState *);
__declspec(dllimport) void PyInterpreterState_Delete(PyInterpreterState *);

/* New in 3.7 */
__declspec(dllimport) int64_t PyInterpreterState_GetID(PyInterpreterState *);


__declspec(dllimport) int _PyState_AddModule(PyObject*, struct PyModuleDef*);


/* New in 3.3 */
__declspec(dllimport) int PyState_AddModule(PyObject*, struct PyModuleDef*);
__declspec(dllimport) int PyState_RemoveModule(struct PyModuleDef*);

__declspec(dllimport) PyObject* PyState_FindModule(struct PyModuleDef*);

__declspec(dllimport) void _PyState_ClearModules(void);


__declspec(dllimport) PyThreadState * PyThreadState_New(PyInterpreterState *);

__declspec(dllimport) PyThreadState * _PyThreadState_Prealloc(PyInterpreterState *);
__declspec(dllimport) void _PyThreadState_Init(PyThreadState *);

__declspec(dllimport) void PyThreadState_Clear(PyThreadState *);
__declspec(dllimport) void PyThreadState_Delete(PyThreadState *);

__declspec(dllimport) void _PyThreadState_DeleteExcept(PyThreadState *tstate);

__declspec(dllimport) void PyThreadState_DeleteCurrent(void);

__declspec(dllimport) void _PyGILState_Reinit(void);


/* Return the current thread state. The global interpreter lock must be held.
 * When the current thread state is NULL, this issues a fatal error (so that
 * the caller needn't check for NULL). */
__declspec(dllimport) PyThreadState * PyThreadState_Get(void);


/* Similar to PyThreadState_Get(), but don't issue a fatal error
 * if it is NULL. */
__declspec(dllimport) PyThreadState * _PyThreadState_UncheckedGet(void);


__declspec(dllimport) PyThreadState * PyThreadState_Swap(PyThreadState *);
__declspec(dllimport) PyObject * PyThreadState_GetDict(void);
__declspec(dllimport) int PyThreadState_SetAsyncExc(unsigned long, PyObject *);


/* Variable and macro for in-line access to current thread state */

/* Assuming the current thread holds the GIL, this is the
   PyThreadState for the current thread. */








typedef
    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}
        PyGILState_STATE;


/* Ensure that the current thread is ready to call the Python
   C API, regardless of the current state of Python, or of its
   thread lock.  This may be called as many times as desired
   by a thread so long as each call is matched with a call to
   PyGILState_Release().  In general, other thread-state APIs may
   be used between _Ensure() and _Release() calls, so long as the
   thread-state is restored to its previous state before the Release().
   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
   Py_END_ALLOW_THREADS macros are acceptable.

   The return value is an opaque "handle" to the thread state when
   PyGILState_Ensure() was called, and must be passed to
   PyGILState_Release() to ensure Python is left in the same state. Even
   though recursive calls are allowed, these handles can *not* be shared -
   each unique call to PyGILState_Ensure must save the handle for its
   call to PyGILState_Release.

   When the function returns, the current thread will hold the GIL.

   Failure is a fatal error.
*/
__declspec(dllimport) PyGILState_STATE PyGILState_Ensure(void);

/* Release any resources previously acquired.  After this call, Python's
   state will be the same as it was prior to the corresponding
   PyGILState_Ensure() call (but generally this state will be unknown to
   the caller, hence the use of the GILState API.)

   Every call to PyGILState_Ensure must be matched by a call to
   PyGILState_Release on the same thread.
*/
__declspec(dllimport) void PyGILState_Release(PyGILState_STATE);

/* Helper/diagnostic function - get the current thread state for
   this thread.  May return NULL if no GILState API has been used
   on the current thread.  Note that the main thread always has such a
   thread-state, even if no auto-thread-state call has been made
   on the main thread.
*/
__declspec(dllimport) PyThreadState * PyGILState_GetThisThreadState(void);


/* Helper/diagnostic function - return 1 if the current thread
   currently holds the GIL, 0 otherwise.

   The function returns 1 if _PyGILState_check_enabled is non-zero. */
__declspec(dllimport) int PyGILState_Check(void);

/* Unsafe function to get the single PyInterpreterState used by this process'
   GILState implementation.

   Return NULL before _PyGILState_Init() is called and after _PyGILState_Fini()
   is called. */
__declspec(dllimport) PyInterpreterState * _PyGILState_GetInterpreterStateUnsafe(void);



/* The implementation of sys._current_frames()  Returns a dict mapping
   thread id to that thread's current frame.
*/

__declspec(dllimport) PyObject * _PyThread_CurrentFrames(void);


/* Routines for advanced debuggers, requested by David Beazley.
   Don't use unless you know what you are doing! */

__declspec(dllimport) PyInterpreterState * PyInterpreterState_Main(void);
__declspec(dllimport) PyInterpreterState * PyInterpreterState_Head(void);
__declspec(dllimport) PyInterpreterState * PyInterpreterState_Next(PyInterpreterState *);
__declspec(dllimport) PyThreadState * PyInterpreterState_ThreadHead(PyInterpreterState *);
__declspec(dllimport) PyThreadState * PyThreadState_Next(PyThreadState *);

typedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);








struct _frame;

/* Traceback interface */

typedef struct _traceback {
    PyObject ob_base;
    struct _traceback *tb_next;
    struct _frame *tb_frame;
    int tb_lasti;
    int tb_lineno;
} PyTracebackObject;


__declspec(dllimport) int PyTraceBack_Here(struct _frame *);
__declspec(dllimport) int PyTraceBack_Print(PyObject *, PyObject *);

__declspec(dllimport) int _Py_DisplaySourceLine(PyObject *, PyObject *, int, int);
__declspec(dllimport) void _PyTraceback_Add(const char *, const char *, int);


/* Reveal traceback type so we can typecheck traceback objects */
extern __declspec(dllimport) PyTypeObject PyTraceBack_Type;



/* Write the Python traceback into the file 'fd'. For example:

       Traceback (most recent call first):
         File "xxx", line xxx in <xxx>
         File "xxx", line xxx in <xxx>
         ...
         File "xxx", line xxx in <xxx>

   This function is written for debug purpose only, to dump the traceback in
   the worst case: after a segmentation fault, at fatal error, etc. That's why,
   it is very limited. Strings are truncated to 100 characters and encoded to
   ASCII with backslashreplace. It doesn't write the source code, only the
   function name, filename and line number of each frame. Write only the first
   100 frames: if the traceback is truncated, write the line " ...".

   This function is signal safe. */

__declspec(dllimport) void _Py_DumpTraceback(
    int fd,
    PyThreadState *tstate);

/* Write the traceback of all threads into the file 'fd'. current_thread can be
   NULL.

   Return NULL on success, or an error message on error.

   This function is written for debug purpose only. It calls
   _Py_DumpTraceback() for each thread, and so has the same limitations. It
   only write the traceback of the first 100 threads: write "..." if there are
   more threads.

   If current_tstate is NULL, the function tries to get the Python thread state
   of the current thread. It is not an error if the function is unable to get
   the current Python thread state.

   If interp is NULL, the function tries to get the interpreter state from
   the current Python thread state, or from
   _PyGILState_GetInterpreterStateUnsafe() in last resort.

   It is better to pass NULL to interp and current_tstate, the function tries
   different options to retrieve these informations.

   This function is signal safe. */

__declspec(dllimport) const char* _Py_DumpTracebackThreads(
    int fd,
    PyInterpreterState *interp,
    PyThreadState *current_tstate);




/* Write a Unicode object into the file descriptor fd. Encode the string to
   ASCII using the backslashreplace error handler.

   Do nothing if text is not a Unicode object. The function accepts Unicode
   string which is not ready (PyUnicode_WCHAR_KIND).

   This function is signal safe. */
__declspec(dllimport) void _Py_DumpASCII(int fd, PyObject *text);

/* Format an integer as decimal into the file descriptor fd.

   This function is signal safe. */
__declspec(dllimport) void _Py_DumpDecimal(
    int fd,
    unsigned long value);

/* Format an integer as hexadecimal into the file descriptor fd with at least
   width digits.

   The maximum width is sizeof(unsigned long)*2 digits.

   This function is signal safe. */
__declspec(dllimport) void _Py_DumpHexadecimal(
    int fd,
    unsigned long value,
    Py_ssize_t width);















/* The unique ellipsis object "..." */

extern __declspec(dllimport) PyObject _Py_EllipsisObject; /* Don't use this directly */



/* Slice object interface */

/*

A slice object containing start, stop, and step data members (the
names are from range).  After much talk with Guido, it was decided to
let these be any arbitrary python type.  Py_None stands for omitted values.
*/

typedef struct {
    PyObject ob_base;
    PyObject *start, *stop, *step;      /* not NULL */
} PySliceObject;


extern __declspec(dllimport) PyTypeObject PySlice_Type;
extern __declspec(dllimport) PyTypeObject PyEllipsis_Type;



__declspec(dllimport) PyObject * PySlice_New(PyObject* start, PyObject* stop,
                                  PyObject* step);

__declspec(dllimport) PyObject * _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
__declspec(dllimport) int _PySlice_GetLongIndices(PySliceObject *self, PyObject *length,
                                 PyObject **start_ptr, PyObject **stop_ptr,
                                 PyObject **step_ptr);

__declspec(dllimport) int PySlice_GetIndices(PyObject *r, Py_ssize_t length,
                                  Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step);
__declspec(dllimport) int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length,
                                     Py_ssize_t *start, Py_ssize_t *stop,
                                     Py_ssize_t *step, Py_ssize_t *slicelength) ;







__declspec(dllimport) int PySlice_Unpack(PyObject *slice,
                               Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step);
__declspec(dllimport) Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length,
                                             Py_ssize_t *start, Py_ssize_t *stop,
                                             Py_ssize_t step);








/* Cell object interface */







typedef struct {
    PyObject ob_base;
    PyObject *ob_ref;       /* Content of the cell or NULL when empty */
} PyCellObject;

extern __declspec(dllimport) PyTypeObject PyCell_Type;



__declspec(dllimport) PyObject * PyCell_New(PyObject *);
__declspec(dllimport) PyObject * PyCell_Get(PyObject *);
__declspec(dllimport) int PyCell_Set(PyObject *, PyObject *);













/* Iterators (the basic kind, over a sequence) */




extern __declspec(dllimport) PyTypeObject PySeqIter_Type;
extern __declspec(dllimport) PyTypeObject PyCallIter_Type;
extern __declspec(dllimport) PyTypeObject PyCmpWrapper_Type;



__declspec(dllimport) PyObject * PySeqIter_New(PyObject *);




__declspec(dllimport) PyObject * PyCallIter_New(PyObject *, PyObject *);









/* Generator object interface */








struct _frame; /* Avoid including frameobject.h */

/* _PyGenObject_HEAD defines the initial segment of generator
   and coroutine objects. */
















typedef struct {
    /* The gi_ prefix is intended to remind of generator-iterator. */
    PyObject ob_base; struct _frame *gi_frame; char gi_running; PyObject *gi_code; PyObject *gi_weakreflist; PyObject *gi_name; PyObject *gi_qualname; _PyErr_StackItem gi_exc_state;
} PyGenObject;

extern __declspec(dllimport) PyTypeObject PyGen_Type;




__declspec(dllimport) PyObject * PyGen_New(struct _frame *);
__declspec(dllimport) PyObject * PyGen_NewWithQualName(struct _frame *,
    PyObject *name, PyObject *qualname);
__declspec(dllimport) int PyGen_NeedsFinalizing(PyGenObject *);
__declspec(dllimport) int _PyGen_SetStopIterationValue(PyObject *);
__declspec(dllimport) int _PyGen_FetchStopIterationValue(PyObject **);
__declspec(dllimport) PyObject * _PyGen_Send(PyGenObject *, PyObject *);
PyObject *_PyGen_yf(PyGenObject *);
__declspec(dllimport) void _PyGen_Finalize(PyObject *self);


typedef struct {
    PyObject ob_base; struct _frame *cr_frame; char cr_running; PyObject *cr_code; PyObject *cr_weakreflist; PyObject *cr_name; PyObject *cr_qualname; _PyErr_StackItem cr_exc_state;
    PyObject *cr_origin;
} PyCoroObject;

extern __declspec(dllimport) PyTypeObject PyCoro_Type;
extern __declspec(dllimport) PyTypeObject _PyCoroWrapper_Type;

extern __declspec(dllimport) PyTypeObject _PyAIterWrapper_Type;


PyObject *_PyCoro_GetAwaitableIter(PyObject *o);
__declspec(dllimport) PyObject * PyCoro_New(struct _frame *,
    PyObject *name, PyObject *qualname);

/* Asynchronous Generators */

typedef struct {
    PyObject ob_base; struct _frame *ag_frame; char ag_running; PyObject *ag_code; PyObject *ag_weakreflist; PyObject *ag_name; PyObject *ag_qualname; _PyErr_StackItem ag_exc_state;
    PyObject *ag_finalizer;

    /* Flag is set to 1 when hooks set up by sys.set_asyncgen_hooks
       were called on the generator, to avoid calling them more
       than once. */
    int ag_hooks_inited;

    /* Flag is set to 1 when aclose() is called for the first time, or
       when a StopAsyncIteration exception is raised. */
    int ag_closed;
} PyAsyncGenObject;

extern __declspec(dllimport) PyTypeObject PyAsyncGen_Type;
extern __declspec(dllimport) PyTypeObject _PyAsyncGenASend_Type;
extern __declspec(dllimport) PyTypeObject _PyAsyncGenWrappedValue_Type;
extern __declspec(dllimport) PyTypeObject _PyAsyncGenAThrow_Type;

__declspec(dllimport) PyObject * PyAsyncGen_New(struct _frame *,
    PyObject *name, PyObject *qualname);



PyObject *_PyAsyncGenValueWrapperNew(PyObject *);

int PyAsyncGen_ClearFreeLists(void);












/* Descriptors */






typedef PyObject *(*getter)(PyObject *, void *);
typedef int (*setter)(PyObject *, PyObject *, void *);

typedef struct PyGetSetDef {
    const char *name;
    getter get;
    setter set;
    const char *doc;
    void *closure;
} PyGetSetDef;


typedef PyObject *(*wrapperfunc)(PyObject *self, PyObject *args,
                                 void *wrapped);

typedef PyObject *(*wrapperfunc_kwds)(PyObject *self, PyObject *args,
                                      void *wrapped, PyObject *kwds);

struct wrapperbase {
    const char *name;
    int offset;
    void *function;
    wrapperfunc wrapper;
    const char *doc;
    int flags;
    PyObject *name_strobj;
};

/* Flags for above struct */


/* Various kinds of descriptor objects */

typedef struct {
    PyObject ob_base;
    PyTypeObject *d_type;
    PyObject *d_name;
    PyObject *d_qualname;
} PyDescrObject;






typedef struct {
    PyDescrObject d_common;
    PyMethodDef *d_method;
} PyMethodDescrObject;

typedef struct {
    PyDescrObject d_common;
    struct PyMemberDef *d_member;
} PyMemberDescrObject;

typedef struct {
    PyDescrObject d_common;
    PyGetSetDef *d_getset;
} PyGetSetDescrObject;

typedef struct {
    PyDescrObject d_common;
    struct wrapperbase *d_base;
    void *d_wrapped; /* This can be any function pointer */
} PyWrapperDescrObject;


extern __declspec(dllimport) PyTypeObject PyClassMethodDescr_Type;
extern __declspec(dllimport) PyTypeObject PyGetSetDescr_Type;
extern __declspec(dllimport) PyTypeObject PyMemberDescr_Type;
extern __declspec(dllimport) PyTypeObject PyMethodDescr_Type;
extern __declspec(dllimport) PyTypeObject PyWrapperDescr_Type;
extern __declspec(dllimport) PyTypeObject PyDictProxy_Type;

extern __declspec(dllimport) PyTypeObject _PyMethodWrapper_Type;


__declspec(dllimport) PyObject * PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
__declspec(dllimport) PyObject * PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
struct PyMemberDef; /* forward declaration for following prototype */
__declspec(dllimport) PyObject * PyDescr_NewMember(PyTypeObject *,
                                               struct PyMemberDef *);
__declspec(dllimport) PyObject * PyDescr_NewGetSet(PyTypeObject *,
                                               struct PyGetSetDef *);


__declspec(dllimport) PyObject * _PyMethodDescr_FastCallKeywords(
        PyObject *descrobj, PyObject *const *stack, Py_ssize_t nargs, PyObject *kwnames);
__declspec(dllimport) PyObject * PyDescr_NewWrapper(PyTypeObject *,
                                                struct wrapperbase *, void *);



__declspec(dllimport) PyObject * PyDictProxy_New(PyObject *);
__declspec(dllimport) PyObject * PyWrapper_New(PyObject *, PyObject *);


extern __declspec(dllimport) PyTypeObject PyProperty_Type;














__declspec(dllimport) PyObject* _PyWarnings_Init(void);


__declspec(dllimport) int PyErr_WarnEx(
    PyObject *category,
    const char *message,        /* UTF-8 encoded string */
    Py_ssize_t stack_level);
__declspec(dllimport) int PyErr_WarnFormat(
    PyObject *category,
    Py_ssize_t stack_level,
    const char *format,         /* ASCII-encoded string  */
    ...);


/* Emit a ResourceWarning warning */
__declspec(dllimport) int PyErr_ResourceWarning(
    PyObject *source,
    Py_ssize_t stack_level,
    const char *format,         /* ASCII-encoded string  */
    ...);


__declspec(dllimport) int PyErr_WarnExplicitObject(
    PyObject *category,
    PyObject *message,
    PyObject *filename,
    int lineno,
    PyObject *module,
    PyObject *registry);

__declspec(dllimport) int PyErr_WarnExplicit(
    PyObject *category,
    const char *message,        /* UTF-8 encoded string */
    const char *filename,       /* decoded from the filesystem encoding */
    int lineno,
    const char *module,         /* UTF-8 encoded string */
    PyObject *registry);


__declspec(dllimport) int
PyErr_WarnExplicitFormat(PyObject *category,
                         const char *filename, int lineno,
                         const char *module, PyObject *registry,
                         const char *format, ...);


/* DEPRECATED: Use PyErr_WarnEx() instead. */





void _PyErr_WarnUnawaitedCoroutine(PyObject *coro);









/* Weak references objects for Python. */








typedef struct _PyWeakReference PyWeakReference;

/* PyWeakReference is the base struct for the Python ReferenceType, ProxyType,
 * and CallableProxyType.
 */

struct _PyWeakReference {
    PyObject ob_base;

    /* The object to which this is a weak reference, or Py_None if none.
     * Note that this is a stealth reference:  wr_object's refcount is
     * not incremented to reflect this pointer.
     */
    PyObject *wr_object;

    /* A callable to invoke when wr_object dies, or NULL if none. */
    PyObject *wr_callback;

    /* A cache for wr_object's hash code.  As usual for hashes, this is -1
     * if the hash code isn't known yet.
     */
    Py_hash_t hash;

    /* If wr_object is weakly referenced, wr_object has a doubly-linked NULL-
     * terminated list of weak references to it.  These are the list pointers.
     * If wr_object goes away, wr_object is set to Py_None, and these pointers
     * have no meaning then.
     */
    PyWeakReference *wr_prev;
    PyWeakReference *wr_next;
};


extern __declspec(dllimport) PyTypeObject _PyWeakref_RefType;
extern __declspec(dllimport) PyTypeObject _PyWeakref_ProxyType;
extern __declspec(dllimport) PyTypeObject _PyWeakref_CallableProxyType;












__declspec(dllimport) PyObject * PyWeakref_NewRef(PyObject *ob,
                                              PyObject *callback);
__declspec(dllimport) PyObject * PyWeakref_NewProxy(PyObject *ob,
                                                PyObject *callback);
__declspec(dllimport) PyObject * PyWeakref_GetObject(PyObject *ref);


__declspec(dllimport) Py_ssize_t _PyWeakref_GetWeakrefCount(PyWeakReference *head);

__declspec(dllimport) void _PyWeakref_ClearRef(PyWeakReference *self);


/* Explanation for the Py_REFCNT() check: when a weakref's target is part
   of a long chain of deallocations which triggers the trashcan mechanism,
   clearing the weakrefs can be delayed long after the target's refcount
   has dropped to zero.  In the meantime, code accessing the weakref will
   be able to "see" the target object even though it is supposed to be
   unreachable.  See issue #16602. */














/* Named tuple object interface */







typedef struct PyStructSequence_Field {
    const char *name;
    const char *doc;
} PyStructSequence_Field;

typedef struct PyStructSequence_Desc {
    const char *name;
    const char *doc;
    struct PyStructSequence_Field *fields;
    int n_in_sequence;
} PyStructSequence_Desc;

extern char* PyStructSequence_UnnamedField;


__declspec(dllimport) void PyStructSequence_InitType(PyTypeObject *type,
                                           PyStructSequence_Desc *desc);
__declspec(dllimport) int PyStructSequence_InitType2(PyTypeObject *type,
                                           PyStructSequence_Desc *desc);

__declspec(dllimport) PyTypeObject* PyStructSequence_NewType(PyStructSequence_Desc *desc);

__declspec(dllimport) PyObject * PyStructSequence_New(PyTypeObject* type);


typedef PyTupleObject PyStructSequence;

/* Macro, *only* to be used to fill in brand new objects */





__declspec(dllimport) void PyStructSequence_SetItem(PyObject*, Py_ssize_t, PyObject*);
__declspec(dllimport) PyObject* PyStructSequence_GetItem(PyObject*, Py_ssize_t);








/* simple namespace object interface */








extern __declspec(dllimport) PyTypeObject _PyNamespace_Type;

__declspec(dllimport) PyObject * _PyNamespace_New(PyObject *kwds);















/* ------------------------------------------------------------------------

   Python Codec Registry and support functions


Written by Marc-Andre Lemburg (mal@lemburg.com).

Copyright (c) Corporation for National Research Initiatives.

   ------------------------------------------------------------------------ */

/* Register a new codec search function.

   As side effect, this tries to load the encodings package, if not
   yet done, to make sure that it is always first in the list of
   search functions.

   The search_function's refcount is incremented by this function. */

__declspec(dllimport) int PyCodec_Register(
       PyObject *search_function
       );

/* Codec registry lookup API.

   Looks up the given encoding and returns a CodecInfo object with
   function attributes which implement the different aspects of
   processing the encoding.

   The encoding string is looked up converted to all lower-case
   characters. This makes encodings looked up through this mechanism
   effectively case-insensitive.

   If no codec is found, a KeyError is set and NULL returned.

   As side effect, this tries to load the encodings package, if not
   yet done. This is part of the lazy load strategy for the encodings
   package.

 */


__declspec(dllimport) PyObject * _PyCodec_Lookup(
       const char *encoding
       );

__declspec(dllimport) int _PyCodec_Forget(
       const char *encoding
       );


/* Codec registry encoding check API.

   Returns 1/0 depending on whether there is a registered codec for
   the given encoding.

*/

__declspec(dllimport) int PyCodec_KnownEncoding(
       const char *encoding
       );

/* Generic codec based encoding API.

   object is passed through the encoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.

   Raises a LookupError in case no encoder can be found.

 */

__declspec(dllimport) PyObject * PyCodec_Encode(
       PyObject *object,
       const char *encoding,
       const char *errors
       );

/* Generic codec based decoding API.

   object is passed through the decoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.

   Raises a LookupError in case no encoder can be found.

 */

__declspec(dllimport) PyObject * PyCodec_Decode(
       PyObject *object,
       const char *encoding,
       const char *errors
       );


/* Text codec specific encoding and decoding API.

   Checks the encoding against a list of codecs which do not
   implement a str<->bytes encoding before attempting the
   operation.

   Please note that these APIs are internal and should not
   be used in Python C extensions.

   XXX (ncoghlan): should we make these, or something like them, public
   in Python 3.5+?

 */
__declspec(dllimport) PyObject * _PyCodec_LookupTextEncoding(
       const char *encoding,
       const char *alternate_command
       );

__declspec(dllimport) PyObject * _PyCodec_EncodeText(
       PyObject *object,
       const char *encoding,
       const char *errors
       );

__declspec(dllimport) PyObject * _PyCodec_DecodeText(
       PyObject *object,
       const char *encoding,
       const char *errors
       );

/* These two aren't actually text encoding specific, but _io.TextIOWrapper
 * is the only current API consumer.
 */
__declspec(dllimport) PyObject * _PyCodecInfo_GetIncrementalDecoder(
       PyObject *codec_info,
       const char *errors
       );

__declspec(dllimport) PyObject * _PyCodecInfo_GetIncrementalEncoder(
       PyObject *codec_info,
       const char *errors
       );




/* --- Codec Lookup APIs --------------------------------------------------

   All APIs return a codec object with incremented refcount and are
   based on _PyCodec_Lookup().  The same comments w/r to the encoding
   name also apply to these APIs.

*/

/* Get an encoder function for the given encoding. */

__declspec(dllimport) PyObject * PyCodec_Encoder(
       const char *encoding
       );

/* Get a decoder function for the given encoding. */

__declspec(dllimport) PyObject * PyCodec_Decoder(
       const char *encoding
       );

/* Get an IncrementalEncoder object for the given encoding. */

__declspec(dllimport) PyObject * PyCodec_IncrementalEncoder(
       const char *encoding,
       const char *errors
       );

/* Get an IncrementalDecoder object function for the given encoding. */

__declspec(dllimport) PyObject * PyCodec_IncrementalDecoder(
       const char *encoding,
       const char *errors
       );

/* Get a StreamReader factory function for the given encoding. */

__declspec(dllimport) PyObject * PyCodec_StreamReader(
       const char *encoding,
       PyObject *stream,
       const char *errors
       );

/* Get a StreamWriter factory function for the given encoding. */

__declspec(dllimport) PyObject * PyCodec_StreamWriter(
       const char *encoding,
       PyObject *stream,
       const char *errors
       );

/* Unicode encoding error handling callback registry API */

/* Register the error handling callback function error under the given
   name. This function will be called by the codec when it encounters
   unencodable characters/undecodable bytes and doesn't know the
   callback name, when name is specified as the error parameter
   in the call to the encode/decode function.
   Return 0 on success, -1 on error */
__declspec(dllimport) int PyCodec_RegisterError(const char *name, PyObject *error);

/* Lookup the error handling callback function registered under the given
   name. As a special case NULL can be passed, in which case
   the error handling callback for "strict" will be returned. */
__declspec(dllimport) PyObject * PyCodec_LookupError(const char *name);

/* raise exc as an exception */
__declspec(dllimport) PyObject * PyCodec_StrictErrors(PyObject *exc);

/* ignore the unicode error, skipping the faulty input */
__declspec(dllimport) PyObject * PyCodec_IgnoreErrors(PyObject *exc);

/* replace the unicode encode error with ? or U+FFFD */
__declspec(dllimport) PyObject * PyCodec_ReplaceErrors(PyObject *exc);

/* replace the unicode encode error with XML character references */
__declspec(dllimport) PyObject * PyCodec_XMLCharRefReplaceErrors(PyObject *exc);

/* replace the unicode encode error with backslash escapes (\x, \u and \U) */
__declspec(dllimport) PyObject * PyCodec_BackslashReplaceErrors(PyObject *exc);


/* replace the unicode encode error with backslash escapes (\N, \x, \u and \U) */
__declspec(dllimport) PyObject * PyCodec_NameReplaceErrors(PyObject *exc);



extern __declspec(dllimport) const char * Py_hexdigits;














/* Error objects */


/* PyException_HEAD defines the initial segment of every exception class. */





typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
} PyBaseExceptionObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *msg;
    PyObject *filename;
    PyObject *lineno;
    PyObject *offset;
    PyObject *text;
    PyObject *print_file_and_line;
} PySyntaxErrorObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *msg;
    PyObject *name;
    PyObject *path;
} PyImportErrorObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *encoding;
    PyObject *object;
    Py_ssize_t start;
    Py_ssize_t end;
    PyObject *reason;
} PyUnicodeErrorObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *code;
} PySystemExitObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *myerrno;
    PyObject *strerror;
    PyObject *filename;
    PyObject *filename2;

    PyObject *winerror;

    Py_ssize_t written;   /* only for BlockingIOError, -1 otherwise */
} PyOSErrorObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *value;
} PyStopIterationObject;

/* Compatibility typedefs */
typedef PyOSErrorObject PyEnvironmentErrorObject;

typedef PyOSErrorObject PyWindowsErrorObject;



/* Error handling definitions */

__declspec(dllimport) void PyErr_SetNone(PyObject *);
__declspec(dllimport) void PyErr_SetObject(PyObject *, PyObject *);

__declspec(dllimport) void _PyErr_SetKeyError(PyObject *);
_PyErr_StackItem *_PyErr_GetTopmostException(PyThreadState *tstate);

__declspec(dllimport) void PyErr_SetString(
    PyObject *exception,
    const char *string   /* decoded from utf-8 */
    );
__declspec(dllimport) PyObject * PyErr_Occurred(void);
__declspec(dllimport) void PyErr_Clear(void);
__declspec(dllimport) void PyErr_Fetch(PyObject **, PyObject **, PyObject **);
__declspec(dllimport) void PyErr_Restore(PyObject *, PyObject *, PyObject *);

__declspec(dllimport) void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **);
__declspec(dllimport) void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *);








/* Defined in Python/pylifecycle.c */
__declspec(dllimport) void Py_FatalError(const char *message) ;







/* Error testing and normalization */
__declspec(dllimport) int PyErr_GivenExceptionMatches(PyObject *, PyObject *);
__declspec(dllimport) int PyErr_ExceptionMatches(PyObject *);
__declspec(dllimport) void PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);

/* Traceback manipulation (PEP 3134) */
__declspec(dllimport) int PyException_SetTraceback(PyObject *, PyObject *);
__declspec(dllimport) PyObject * PyException_GetTraceback(PyObject *);

/* Cause manipulation (PEP 3134) */
__declspec(dllimport) PyObject * PyException_GetCause(PyObject *);
__declspec(dllimport) void PyException_SetCause(PyObject *, PyObject *);

/* Context manipulation (PEP 3134) */
__declspec(dllimport) PyObject * PyException_GetContext(PyObject *);
__declspec(dllimport) void PyException_SetContext(PyObject *, PyObject *);

__declspec(dllimport) void _PyErr_ChainExceptions(PyObject *, PyObject *, PyObject *);


/* */














/* Predefined exceptions */

extern __declspec(dllimport) PyObject * PyExc_BaseException;
extern __declspec(dllimport) PyObject * PyExc_Exception;

extern __declspec(dllimport) PyObject * PyExc_StopAsyncIteration;

extern __declspec(dllimport) PyObject * PyExc_StopIteration;
extern __declspec(dllimport) PyObject * PyExc_GeneratorExit;
extern __declspec(dllimport) PyObject * PyExc_ArithmeticError;
extern __declspec(dllimport) PyObject * PyExc_LookupError;

extern __declspec(dllimport) PyObject * PyExc_AssertionError;
extern __declspec(dllimport) PyObject * PyExc_AttributeError;
extern __declspec(dllimport) PyObject * PyExc_BufferError;
extern __declspec(dllimport) PyObject * PyExc_EOFError;
extern __declspec(dllimport) PyObject * PyExc_FloatingPointError;
extern __declspec(dllimport) PyObject * PyExc_OSError;
extern __declspec(dllimport) PyObject * PyExc_ImportError;

extern __declspec(dllimport) PyObject * PyExc_ModuleNotFoundError;

extern __declspec(dllimport) PyObject * PyExc_IndexError;
extern __declspec(dllimport) PyObject * PyExc_KeyError;
extern __declspec(dllimport) PyObject * PyExc_KeyboardInterrupt;
extern __declspec(dllimport) PyObject * PyExc_MemoryError;
extern __declspec(dllimport) PyObject * PyExc_NameError;
extern __declspec(dllimport) PyObject * PyExc_OverflowError;
extern __declspec(dllimport) PyObject * PyExc_RuntimeError;

extern __declspec(dllimport) PyObject * PyExc_RecursionError;

extern __declspec(dllimport) PyObject * PyExc_NotImplementedError;
extern __declspec(dllimport) PyObject * PyExc_SyntaxError;
extern __declspec(dllimport) PyObject * PyExc_IndentationError;
extern __declspec(dllimport) PyObject * PyExc_TabError;
extern __declspec(dllimport) PyObject * PyExc_ReferenceError;
extern __declspec(dllimport) PyObject * PyExc_SystemError;
extern __declspec(dllimport) PyObject * PyExc_SystemExit;
extern __declspec(dllimport) PyObject * PyExc_TypeError;
extern __declspec(dllimport) PyObject * PyExc_UnboundLocalError;
extern __declspec(dllimport) PyObject * PyExc_UnicodeError;
extern __declspec(dllimport) PyObject * PyExc_UnicodeEncodeError;
extern __declspec(dllimport) PyObject * PyExc_UnicodeDecodeError;
extern __declspec(dllimport) PyObject * PyExc_UnicodeTranslateError;
extern __declspec(dllimport) PyObject * PyExc_ValueError;
extern __declspec(dllimport) PyObject * PyExc_ZeroDivisionError;


extern __declspec(dllimport) PyObject * PyExc_BlockingIOError;
extern __declspec(dllimport) PyObject * PyExc_BrokenPipeError;
extern __declspec(dllimport) PyObject * PyExc_ChildProcessError;
extern __declspec(dllimport) PyObject * PyExc_ConnectionError;
extern __declspec(dllimport) PyObject * PyExc_ConnectionAbortedError;
extern __declspec(dllimport) PyObject * PyExc_ConnectionRefusedError;
extern __declspec(dllimport) PyObject * PyExc_ConnectionResetError;
extern __declspec(dllimport) PyObject * PyExc_FileExistsError;
extern __declspec(dllimport) PyObject * PyExc_FileNotFoundError;
extern __declspec(dllimport) PyObject * PyExc_InterruptedError;
extern __declspec(dllimport) PyObject * PyExc_IsADirectoryError;
extern __declspec(dllimport) PyObject * PyExc_NotADirectoryError;
extern __declspec(dllimport) PyObject * PyExc_PermissionError;
extern __declspec(dllimport) PyObject * PyExc_ProcessLookupError;
extern __declspec(dllimport) PyObject * PyExc_TimeoutError;



/* Compatibility aliases */
extern __declspec(dllimport) PyObject * PyExc_EnvironmentError;
extern __declspec(dllimport) PyObject * PyExc_IOError;

extern __declspec(dllimport) PyObject * PyExc_WindowsError;


/* Predefined warning categories */
extern __declspec(dllimport) PyObject * PyExc_Warning;
extern __declspec(dllimport) PyObject * PyExc_UserWarning;
extern __declspec(dllimport) PyObject * PyExc_DeprecationWarning;
extern __declspec(dllimport) PyObject * PyExc_PendingDeprecationWarning;
extern __declspec(dllimport) PyObject * PyExc_SyntaxWarning;
extern __declspec(dllimport) PyObject * PyExc_RuntimeWarning;
extern __declspec(dllimport) PyObject * PyExc_FutureWarning;
extern __declspec(dllimport) PyObject * PyExc_ImportWarning;
extern __declspec(dllimport) PyObject * PyExc_UnicodeWarning;
extern __declspec(dllimport) PyObject * PyExc_BytesWarning;
extern __declspec(dllimport) PyObject * PyExc_ResourceWarning;


/* Convenience functions */

__declspec(dllimport) int PyErr_BadArgument(void);
__declspec(dllimport) PyObject * PyErr_NoMemory(void);
__declspec(dllimport) PyObject * PyErr_SetFromErrno(PyObject *);
__declspec(dllimport) PyObject * PyErr_SetFromErrnoWithFilenameObject(
    PyObject *, PyObject *);

__declspec(dllimport) PyObject * PyErr_SetFromErrnoWithFilenameObjects(
    PyObject *, PyObject *, PyObject *);

__declspec(dllimport) PyObject * PyErr_SetFromErrnoWithFilename(
    PyObject *exc,
    const char *filename   /* decoded from the filesystem encoding */
    );

__declspec(dllimport) PyObject * PyErr_SetFromErrnoWithUnicodeFilename(
    PyObject *, const Py_UNICODE *) ;


__declspec(dllimport) PyObject * PyErr_Format(
    PyObject *exception,
    const char *format,   /* ASCII-encoded string  */
    ...
    );

__declspec(dllimport) PyObject * PyErr_FormatV(
    PyObject *exception,
    const char *format,
    va_list vargs);



/* Like PyErr_Format(), but saves current exception as __context__ and
   __cause__.
 */
__declspec(dllimport) PyObject * _PyErr_FormatFromCause(
    PyObject *exception,
    const char *format,   /* ASCII-encoded string  */
    ...
    );



__declspec(dllimport) PyObject * PyErr_SetFromWindowsErrWithFilename(
    int ierr,
    const char *filename        /* decoded from the filesystem encoding */
    );

/* XXX redeclare to use WSTRING */
__declspec(dllimport) PyObject * PyErr_SetFromWindowsErrWithUnicodeFilename(
    int, const Py_UNICODE *) ;

__declspec(dllimport) PyObject * PyErr_SetFromWindowsErr(int);
__declspec(dllimport) PyObject * PyErr_SetExcFromWindowsErrWithFilenameObject(
    PyObject *,int, PyObject *);

__declspec(dllimport) PyObject * PyErr_SetExcFromWindowsErrWithFilenameObjects(
    PyObject *,int, PyObject *, PyObject *);

__declspec(dllimport) PyObject * PyErr_SetExcFromWindowsErrWithFilename(
    PyObject *exc,
    int ierr,
    const char *filename        /* decoded from the filesystem encoding */
    );

__declspec(dllimport) PyObject * PyErr_SetExcFromWindowsErrWithUnicodeFilename(
    PyObject *,int, const Py_UNICODE *) ;

__declspec(dllimport) PyObject * PyErr_SetExcFromWindowsErr(PyObject *, int);



__declspec(dllimport) PyObject * PyErr_SetImportErrorSubclass(PyObject *, PyObject *,
    PyObject *, PyObject *);


__declspec(dllimport) PyObject * PyErr_SetImportError(PyObject *, PyObject *,
    PyObject *);


/* Export the old function so that the existing API remains available: */
__declspec(dllimport) void PyErr_BadInternalCall(void);
__declspec(dllimport) void _PyErr_BadInternalCall(const char *filename, int lineno);
/* Mask the old API with a call to the new API for code compiled under
   Python 2.0: */


/* Function to create a new exception */
__declspec(dllimport) PyObject * PyErr_NewException(
    const char *name, PyObject *base, PyObject *dict);
__declspec(dllimport) PyObject * PyErr_NewExceptionWithDoc(
    const char *name, const char *doc, PyObject *base, PyObject *dict);
__declspec(dllimport) void PyErr_WriteUnraisable(PyObject *);

/* In exceptions.c */

/* Helper that attempts to replace the current exception with one of the
 * same type but with a prefix added to the exception text. The resulting
 * exception description looks like:
 *
 *     prefix (exc_type: original_exc_str)
 *
 * Only some exceptions can be safely replaced. If the function determines
 * it isn't safe to perform the replacement, it will leave the original
 * unmodified exception in place.
 *
 * Returns a borrowed reference to the new exception (if any), NULL if the
 * existing exception was left in place.
 */
__declspec(dllimport) PyObject * _PyErr_TrySetFromCause(
    const char *prefix_format,   /* ASCII-encoded string  */
    ...
    );



/* In signalmodule.c */
__declspec(dllimport) int PyErr_CheckSignals(void);
__declspec(dllimport) void PyErr_SetInterrupt(void);

/* In signalmodule.c */

int PySignal_SetWakeupFd(int fd);


/* Support for adding program text to SyntaxErrors */
__declspec(dllimport) void PyErr_SyntaxLocation(
    const char *filename,       /* decoded from the filesystem encoding */
    int lineno);
__declspec(dllimport) void PyErr_SyntaxLocationEx(
    const char *filename,       /* decoded from the filesystem encoding */
    int lineno,
    int col_offset);

__declspec(dllimport) void PyErr_SyntaxLocationObject(
    PyObject *filename,
    int lineno,
    int col_offset);

__declspec(dllimport) PyObject * PyErr_ProgramText(
    const char *filename,       /* decoded from the filesystem encoding */
    int lineno);

__declspec(dllimport) PyObject * PyErr_ProgramTextObject(
    PyObject *filename,
    int lineno);


/* The following functions are used to create and modify unicode
   exceptions from C */

/* create a UnicodeDecodeError object */
__declspec(dllimport) PyObject * PyUnicodeDecodeError_Create(
    const char *encoding,       /* UTF-8 encoded string */
    const char *object,
    Py_ssize_t length,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason          /* UTF-8 encoded string */
    );

/* create a UnicodeEncodeError object */

__declspec(dllimport) PyObject * PyUnicodeEncodeError_Create(
    const char *encoding,       /* UTF-8 encoded string */
    const Py_UNICODE *object,
    Py_ssize_t length,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason          /* UTF-8 encoded string */
    ) ;


/* create a UnicodeTranslateError object */

__declspec(dllimport) PyObject * PyUnicodeTranslateError_Create(
    const Py_UNICODE *object,
    Py_ssize_t length,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason          /* UTF-8 encoded string */
    ) ;
__declspec(dllimport) PyObject * _PyUnicodeTranslateError_Create(
    PyObject *object,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason          /* UTF-8 encoded string */
    );


/* get the encoding attribute */
__declspec(dllimport) PyObject * PyUnicodeEncodeError_GetEncoding(PyObject *);
__declspec(dllimport) PyObject * PyUnicodeDecodeError_GetEncoding(PyObject *);

/* get the object attribute */
__declspec(dllimport) PyObject * PyUnicodeEncodeError_GetObject(PyObject *);
__declspec(dllimport) PyObject * PyUnicodeDecodeError_GetObject(PyObject *);
__declspec(dllimport) PyObject * PyUnicodeTranslateError_GetObject(PyObject *);

/* get the value of the start attribute (the int * may not be NULL)
   return 0 on success, -1 on failure */
__declspec(dllimport) int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *);
__declspec(dllimport) int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *);
__declspec(dllimport) int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *);

/* assign a new value to the start attribute
   return 0 on success, -1 on failure */
__declspec(dllimport) int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t);
__declspec(dllimport) int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t);
__declspec(dllimport) int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t);

/* get the value of the end attribute (the int *may not be NULL)
 return 0 on success, -1 on failure */
__declspec(dllimport) int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *);
__declspec(dllimport) int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *);
__declspec(dllimport) int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *);

/* assign a new value to the end attribute
   return 0 on success, -1 on failure */
__declspec(dllimport) int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t);
__declspec(dllimport) int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t);
__declspec(dllimport) int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t);

/* get the value of the reason attribute */
__declspec(dllimport) PyObject * PyUnicodeEncodeError_GetReason(PyObject *);
__declspec(dllimport) PyObject * PyUnicodeDecodeError_GetReason(PyObject *);
__declspec(dllimport) PyObject * PyUnicodeTranslateError_GetReason(PyObject *);

/* assign a new value to the reason attribute
   return 0 on success, -1 on failure */
__declspec(dllimport) int PyUnicodeEncodeError_SetReason(
    PyObject *exc,
    const char *reason          /* UTF-8 encoded string */
    );
__declspec(dllimport) int PyUnicodeDecodeError_SetReason(
    PyObject *exc,
    const char *reason          /* UTF-8 encoded string */
    );
__declspec(dllimport) int PyUnicodeTranslateError_SetReason(
    PyObject *exc,
    const char *reason          /* UTF-8 encoded string */
    );

/* These APIs aren't really part of the error implementation, but
   often needed to format error messages; the native C lib APIs are
   not available on all platforms, which is why we provide emulations
   for those platforms in Python/mysnprintf.c,
   WARNING:  The return value of snprintf varies across platforms; do
   not rely on any particular behavior; eventually the C99 defn may
   be reliable.
*/







__declspec(dllimport) int PyOS_snprintf(char *str, size_t size, const char  *format, ...)
                        ;
__declspec(dllimport) int PyOS_vsnprintf(char *str, size_t size, const char  *format, va_list va)
                        ;


















extern __declspec(dllimport) PyTypeObject PyContext_Type;
typedef struct _pycontextobject PyContext;

extern __declspec(dllimport) PyTypeObject PyContextVar_Type;
typedef struct _pycontextvarobject PyContextVar;

extern __declspec(dllimport) PyTypeObject PyContextToken_Type;
typedef struct _pycontexttokenobject PyContextToken;







__declspec(dllimport) PyContext * PyContext_New(void);
__declspec(dllimport) PyContext * PyContext_Copy(PyContext *);
__declspec(dllimport) PyContext * PyContext_CopyCurrent(void);

__declspec(dllimport) int PyContext_Enter(PyContext *);
__declspec(dllimport) int PyContext_Exit(PyContext *);


/* Create a new context variable.

   default_value can be NULL.
*/
__declspec(dllimport) PyContextVar * PyContextVar_New(
    const char *name, PyObject *default_value);


/* Get a value for the variable.

   Returns -1 if an error occurred during lookup.

   Returns 0 if value either was or was not found.

   If value was found, *value will point to it.
   If not, it will point to:

   - default_value, if not NULL;
   - the default value of "var", if not NULL;
   - NULL.

   '*value' will be a new ref, if not NULL.
*/
__declspec(dllimport) int PyContextVar_Get(
    PyContextVar *var, PyObject *default_value, PyObject **value);


/* Set a new value for the variable.
   Returns NULL if an error occurs.
*/
__declspec(dllimport) PyContextToken * PyContextVar_Set(
    PyContextVar *var, PyObject *value);


/* Reset a variable to its previous value.
   Returns 0 on success, -1 on error.
*/
__declspec(dllimport) int PyContextVar_Reset(
    PyContextVar *var, PyContextToken *token);


/* This method is exposed only for CPython tests. Don not use it. */
__declspec(dllimport) PyObject * _PyContext_NewHamtForTests(void);


__declspec(dllimport) int PyContext_ClearFreeList(void);











/* An arena-like memory interface for the compiler.
 */









  typedef struct _arena PyArena;

  /* PyArena_New() and PyArena_Free() create a new arena and free it,
     respectively.  Once an arena has been created, it can be used
     to allocate memory via PyArena_Malloc().  Pointers to PyObject can
     also be registered with the arena via PyArena_AddPyObject(), and the
     arena will ensure that the PyObjects stay alive at least until
     PyArena_Free() is called.  When an arena is freed, all the memory it
     allocated is freed, the arena releases internal references to registered
     PyObject*, and none of its pointers are valid.
     XXX (tim) What does "none of its pointers are valid" mean?  Does it
     XXX mean that pointers previously obtained via PyArena_Malloc() are
     XXX no longer valid?  (That's clearly true, but not sure that's what
     XXX the text is trying to say.)

     PyArena_New() returns an arena pointer.  On error, it
     returns a negative number and sets an exception.
     XXX (tim):  Not true.  On error, PyArena_New() actually returns NULL,
     XXX and looks like it may or may not set an exception (e.g., if the
     XXX internal PyList_New(0) returns NULL, PyArena_New() passes that on
     XXX and an exception is set; OTOH, if the internal
     XXX block_new(DEFAULT_BLOCK_SIZE) returns NULL, that's passed on but
     XXX an exception is not set in that case).
  */
  __declspec(dllimport) PyArena * PyArena_New(void);
  __declspec(dllimport) void PyArena_Free(PyArena *);

  /* Mostly like malloc(), return the address of a block of memory spanning
   * `size` bytes, or return NULL (without setting an exception) if enough
   * new memory can't be obtained.  Unlike malloc(0), PyArena_Malloc() with
   * size=0 does not guarantee to return a unique pointer (the pointer
   * returned may equal one or more other pointers obtained from
   * PyArena_Malloc()).
   * Note that pointers obtained via PyArena_Malloc() must never be passed to
   * the system free() or realloc(), or to any of Python's similar memory-
   * management functions.  PyArena_Malloc()-obtained pointers remain valid
   * until PyArena_Free(ar) is called, at which point all pointers obtained
   * from the arena `ar` become invalid simultaneously.
   */
  __declspec(dllimport) void * PyArena_Malloc(PyArena *, size_t size);

  /* This routine isn't a proper arena allocation routine.  It takes
   * a PyObject* and records it so that it can be DECREFed when the
   * arena is freed.
   */
  __declspec(dllimport) int PyArena_AddPyObject(PyArena *, PyObject *);
















/* Module support interface */



/* If PY_SSIZE_T_CLEAN is defined, each functions treats #-specifier
   to mean Py_ssize_t */













__declspec(dllimport) PyObject * _Py_VaBuildValue_SizeT(const char *, va_list);
__declspec(dllimport) PyObject ** _Py_VaBuildStack_SizeT(
    PyObject **small_stack,
    Py_ssize_t small_stack_len,
    const char *format,
    va_list va,
    Py_ssize_t *p_nargs);



/* Due to a glitch in 3.2, the _SizeT versions weren't exported from the DLL. */

__declspec(dllimport) int PyArg_Parse(PyObject *, const char *, ...);
__declspec(dllimport) int PyArg_ParseTuple(PyObject *, const char *, ...);
__declspec(dllimport) int PyArg_ParseTupleAndKeywords(PyObject *, PyObject *,
                                                  const char *, char **, ...);
__declspec(dllimport) int PyArg_VaParse(PyObject *, const char *, va_list);
__declspec(dllimport) int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *,
                                                  const char *, char **, va_list);

__declspec(dllimport) int PyArg_ValidateKeywordArguments(PyObject *);
__declspec(dllimport) int PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...);
__declspec(dllimport) PyObject * Py_BuildValue(const char *, ...);
__declspec(dllimport) PyObject * _Py_BuildValue_SizeT(const char *, ...);



__declspec(dllimport) int _PyArg_UnpackStack(
    PyObject *const *args,
    Py_ssize_t nargs,
    const char *name,
    Py_ssize_t min,
    Py_ssize_t max,
    ...);

__declspec(dllimport) int _PyArg_NoKeywords(const char *funcname, PyObject *kwargs);
__declspec(dllimport) int _PyArg_NoPositional(const char *funcname, PyObject *args);







__declspec(dllimport) PyObject * Py_VaBuildValue(const char *, va_list);

__declspec(dllimport) PyObject ** _Py_VaBuildStack(
    PyObject **small_stack,
    Py_ssize_t small_stack_len,
    const char *format,
    va_list va,
    Py_ssize_t *p_nargs);



typedef struct _PyArg_Parser {
    const char *format;
    const char * const *keywords;
    const char *fname;
    const char *custom_msg;
    int pos;            /* number of positional-only arguments */
    int min;            /* minimal number of arguments */
    int max;            /* maximal number of positional arguments */
    PyObject *kwtuple;  /* tuple of keyword parameter names */
    struct _PyArg_Parser *next;
} _PyArg_Parser;






__declspec(dllimport) int _PyArg_ParseTupleAndKeywordsFast(PyObject *, PyObject *,
                                                 struct _PyArg_Parser *, ...);
__declspec(dllimport) int _PyArg_ParseStack(
    PyObject *const *args,
    Py_ssize_t nargs,
    const char *format,
    ...);
__declspec(dllimport) int _PyArg_ParseStackAndKeywords(
    PyObject *const *args,
    Py_ssize_t nargs,
    PyObject *kwnames,
    struct _PyArg_Parser *,
    ...);
__declspec(dllimport) int _PyArg_VaParseTupleAndKeywordsFast(PyObject *, PyObject *,
                                                   struct _PyArg_Parser *, va_list);
void _PyArg_Fini(void);


__declspec(dllimport) int PyModule_AddObject(PyObject *, const char *, PyObject *);
__declspec(dllimport) int PyModule_AddIntConstant(PyObject *, const char *, long);
__declspec(dllimport) int PyModule_AddStringConstant(PyObject *, const char *, const char *);




/* New in 3.5 */
__declspec(dllimport) int PyModule_SetDocString(PyObject *, const char *);
__declspec(dllimport) int PyModule_AddFunctions(PyObject *, PyMethodDef *);
__declspec(dllimport) int PyModule_ExecDef(PyObject *module, PyModuleDef *def);






/* The API version is maintained (independently from the Python version)
   so we can detect mismatches between the interpreter and dynamically
   loaded modules.  These are diagnosed by an error message but
   the module is still loaded (because the mismatch can only be tested
   after loading the module).  The error message is intended to
   explain the core dump a few seconds later.

   The symbol PYTHON_API_STRING defines the same value as a string
   literal.  *** PLEASE MAKE SURE THE DEFINITIONS MATCH. ***

   Please add a line or two to the top of this log for each API
   version change:

   22-Feb-2006  MvL     1013    PEP 353 - long indices for sequence lengths

   19-Aug-2002  GvR     1012    Changes to string object struct for
                                interning changes, saving 3 bytes.

   17-Jul-2001  GvR     1011    Descr-branch, just to be on the safe side

   25-Jan-2001  FLD     1010    Parameters added to PyCode_New() and
                                PyFrame_New(); Python 2.1a2

   14-Mar-2000  GvR     1009    Unicode API added

   3-Jan-1999   GvR     1007    Decided to change back!  (Don't reuse 1008!)

   3-Dec-1998   GvR     1008    Python 1.5.2b1

   18-Jan-1997  GvR     1007    string interning and other speedups

   11-Oct-1996  GvR     renamed Py_Ellipses to Py_Ellipsis :-(

   30-Jul-1996  GvR     Slice and ellipses syntax added

   23-Jul-1996  GvR     For 1.4 -- better safe than sorry this time :-)

   7-Nov-1995   GvR     Keyword arguments (should've been done at 1.3 :-( )

   10-Jan-1995  GvR     Renamed globals to new naming scheme

   9-Jan-1995   GvR     Initial version (incompatible with older API)
*/

/* The PYTHON_ABI_VERSION is introduced in PEP 384. For the lifetime of
   Python 3, it will stay at the value of 3; changes to the limited API
   must be performed in a strictly backwards-compatible manner. */











__declspec(dllimport) PyObject * PyModule_Create2(struct PyModuleDef*,
                                     int apiver);

__declspec(dllimport) PyObject * _PyModule_CreateInitialized(struct PyModuleDef*,
                                                   int apiver);











/* New in 3.5 */
__declspec(dllimport) PyObject * PyModule_FromDefAndSpec2(PyModuleDef *def,
                                                PyObject *spec,
                                                int module_api_version);











extern __declspec(dllimport) const char * _Py_PackageContext;













/* Definitions for bytecode */








typedef uint16_t _Py_CODEUNIT;









/* Bytecode object */
typedef struct {
    PyObject ob_base;
    int co_argcount;            /* #arguments, except *args */
    int co_kwonlyargcount;      /* #keyword only arguments */
    int co_nlocals;             /* #local variables */
    int co_stacksize;           /* #entries needed for evaluation stack */
    int co_flags;               /* CO_..., see below */
    int co_firstlineno;         /* first source line number */
    PyObject *co_code;          /* instruction opcodes */
    PyObject *co_consts;        /* list (constants used) */
    PyObject *co_names;         /* list of strings (names used) */
    PyObject *co_varnames;      /* tuple of strings (local variable names) */
    PyObject *co_freevars;      /* tuple of strings (free variable names) */
    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */
    /* The rest aren't used in either hash or comparisons, except for co_name,
       used in both. This is done to preserve the name and line number
       for tracebacks and debuggers; otherwise, constant de-duplication
       would collapse identical functions/lambdas defined on different lines.
    */
    Py_ssize_t *co_cell2arg;    /* Maps cell vars which are arguments. */
    PyObject *co_filename;      /* unicode (where it was loaded from) */
    PyObject *co_name;          /* unicode (name, for reference) */
    PyObject *co_lnotab;        /* string (encoding addr<->lineno mapping) See
                                   Objects/lnotab_notes.txt for details. */
    void *co_zombieframe;       /* for optimization only (see frameobject.c) */
    PyObject *co_weakreflist;   /* to support weakrefs to code objects */
    /* Scratch space for extra data relating to the code object.
       Type is a void* to keep the format private in codeobject.c to force
       people to go through the proper APIs. */
    void *co_extra;
} PyCodeObject;

/* Masks for co_flags above */






/* The CO_NOFREE flag is set if there are no free or cell variables.
   This information is redundant, but it allows a single flag test
   to determine whether there is any extra work to be done when the
   call frame it setup.
*/


/* The CO_COROUTINE flag is set for coroutine functions (defined with
   ``async def`` keywords) */




/* These are no longer used. */













/* This value is found in the co_cell2arg array when the associated cell
   variable does not correspond to an argument. */


/* This should be defined if a future statement modifies the syntax.
   For example, when a keyword is added.
*/




extern __declspec(dllimport) PyTypeObject PyCode_Type;




/* Public interface */
__declspec(dllimport) PyCodeObject * PyCode_New(
        int, int, int, int, int, PyObject *, PyObject *,
        PyObject *, PyObject *, PyObject *, PyObject *,
        PyObject *, PyObject *, int, PyObject *);
        /* same as struct above */

/* Creates a new empty code object with the specified source location. */
__declspec(dllimport) PyCodeObject *
PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno);

/* Return the line number associated with the specified bytecode index
   in this code object.  If you just need the line number of a frame,
   use PyFrame_GetLineNumber() instead. */
__declspec(dllimport) int PyCode_Addr2Line(PyCodeObject *, int);

/* for internal use only */
typedef struct _addr_pair {
        int ap_lower;
        int ap_upper;
} PyAddrPair;


/* Update *bounds to describe the first and one-past-the-last instructions in the
   same line as lasti.  Return the number of that line.
*/
__declspec(dllimport) int _PyCode_CheckLineNumber(PyCodeObject* co,
                                        int lasti, PyAddrPair *bounds);

/* Create a comparable key used to compare constants taking in account the
 * object type. It is used to make sure types are not coerced (e.g., float and
 * complex) _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms
 *
 * Return (type(obj), obj, ...): a tuple with variable size (at least 2 items)
 * depending on the type and the value. The type is the first item to not
 * compare bytes and str which can raise a BytesWarning exception. */
__declspec(dllimport) PyObject* _PyCode_ConstantKey(PyObject *obj);


__declspec(dllimport) PyObject* PyCode_Optimize(PyObject *code, PyObject* consts,
                                      PyObject *names, PyObject *lnotab);



__declspec(dllimport) int _PyCode_GetExtra(PyObject *code, Py_ssize_t index,
                                 void **extra);
__declspec(dllimport) int _PyCode_SetExtra(PyObject *code, Py_ssize_t index,
                                 void *extra);













/* Public interface */
struct _node; /* Declare the existence of this type */
__declspec(dllimport) PyCodeObject * PyNode_Compile(struct _node *, const char *);
/* XXX (ncoghlan): Unprefixed type name in a public API! */












typedef struct {
    int cf_flags;  /* bitmask of CO_xxx flags relevant to future */
} PyCompilerFlags;


/* Future feature support */

typedef struct {
    int ff_features;      /* flags set by future statements */
    int ff_lineno;        /* line number of last future statement */
} PyFutureFeatures;












struct _mod; /* Declare the existence of this type */

__declspec(dllimport) PyCodeObject * PyAST_CompileEx(
    struct _mod *mod,
    const char *filename,       /* decoded from the filesystem encoding */
    PyCompilerFlags *flags,
    int optimize,
    PyArena *arena);
__declspec(dllimport) PyCodeObject * PyAST_CompileObject(
    struct _mod *mod,
    PyObject *filename,
    PyCompilerFlags *flags,
    int optimize,
    PyArena *arena);
__declspec(dllimport) PyFutureFeatures * PyFuture_FromAST(
    struct _mod * mod,
    const char *filename        /* decoded from the filesystem encoding */
    );
__declspec(dllimport) PyFutureFeatures * PyFuture_FromASTObject(
    struct _mod * mod,
    PyObject *filename
    );

/* _Py_Mangle is defined in compile.c */
__declspec(dllimport) PyObject* _Py_Mangle(PyObject *p, PyObject *name);


__declspec(dllimport) int PyCompile_OpcodeStackEffect(int opcode, int oparg);

__declspec(dllimport) int _PyAST_Optimize(struct _mod *, PyArena *arena, int optimize);







/* These definitions must match corresponding definitions in graminit.h.
   There's code in compile.c that checks that they are the same. */








/* Interfaces to parse and execute pieces of python code */








__declspec(dllimport) int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *);
__declspec(dllimport) int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
__declspec(dllimport) int PyRun_AnyFileExFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    int closeit,
    PyCompilerFlags *flags);
__declspec(dllimport) int PyRun_SimpleFileExFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    int closeit,
    PyCompilerFlags *flags);
__declspec(dllimport) int PyRun_InteractiveOneFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    PyCompilerFlags *flags);
__declspec(dllimport) int PyRun_InteractiveOneObject(
    FILE *fp,
    PyObject *filename,
    PyCompilerFlags *flags);
__declspec(dllimport) int PyRun_InteractiveLoopFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    PyCompilerFlags *flags);

__declspec(dllimport) struct _mod * PyParser_ASTFromString(
    const char *s,
    const char *filename,       /* decoded from the filesystem encoding */
    int start,
    PyCompilerFlags *flags,
    PyArena *arena);
__declspec(dllimport) struct _mod * PyParser_ASTFromStringObject(
    const char *s,
    PyObject *filename,
    int start,
    PyCompilerFlags *flags,
    PyArena *arena);
__declspec(dllimport) struct _mod * PyParser_ASTFromFile(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    const char* enc,
    int start,
    const char *ps1,
    const char *ps2,
    PyCompilerFlags *flags,
    int *errcode,
    PyArena *arena);
__declspec(dllimport) struct _mod * PyParser_ASTFromFileObject(
    FILE *fp,
    PyObject *filename,
    const char* enc,
    int start,
    const char *ps1,
    const char *ps2,
    PyCompilerFlags *flags,
    int *errcode,
    PyArena *arena);








__declspec(dllimport) struct _node * PyParser_SimpleParseStringFlags(const char *, int,
                                                           int);

__declspec(dllimport) struct _node * PyParser_SimpleParseStringFlagsFilename(const char *,
                                                                   const char *,
                                                                   int, int);

__declspec(dllimport) struct _node * PyParser_SimpleParseFileFlags(FILE *, const char *,
                                                         int, int);


__declspec(dllimport) PyObject * PyRun_StringFlags(const char *, int, PyObject *,
                                         PyObject *, PyCompilerFlags *);

__declspec(dllimport) PyObject * PyRun_FileExFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    int start,
    PyObject *globals,
    PyObject *locals,
    int closeit,
    PyCompilerFlags *flags);







__declspec(dllimport) PyObject * Py_CompileStringExFlags(
    const char *str,
    const char *filename,       /* decoded from the filesystem encoding */
    int start,
    PyCompilerFlags *flags,
    int optimize);
__declspec(dllimport) PyObject * Py_CompileStringObject(
    const char *str,
    PyObject *filename, int start,
    PyCompilerFlags *flags,
    int optimize);

__declspec(dllimport) struct symtable * Py_SymtableString(
    const char *str,
    const char *filename,       /* decoded from the filesystem encoding */
    int start);

__declspec(dllimport) struct symtable * Py_SymtableStringObject(
    const char *str,
    PyObject *filename,
    int start);


__declspec(dllimport) void PyErr_Print(void);
__declspec(dllimport) void PyErr_PrintEx(int);
__declspec(dllimport) void PyErr_Display(PyObject *, PyObject *, PyObject *);


/* Use macros for a bunch of old variants */



















/* Stuff with no proper home (yet) */

__declspec(dllimport) char * PyOS_Readline(FILE *, FILE *, const char *);

extern __declspec(dllimport) int (*PyOS_InputHook)(void);
extern __declspec(dllimport) char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *);

extern __declspec(dllimport) PyThreadState* _PyOS_ReadlineTState;


/* Stack size, in "pointers" (so we get extra safety margins
   on 64-bit platforms).  On a 32-bit platform, this translates
   to an 8k margin. */



















/* Interfaces to configure, query, create & destroy the Python runtime */








typedef struct {
    const char *prefix;
    const char *msg;
    int user_err;
} _PyInitError;

/* Almost all errors causing Python initialization to fail */

   /* Visual Studio 2015 doesn't implement C99 __func__ in C */









/* Error that can be fixed by the user like invalid input parameter.
   Don't abort() the process on such error. */









__declspec(dllimport) void Py_SetProgramName(const wchar_t *);
__declspec(dllimport) wchar_t * Py_GetProgramName(void);

__declspec(dllimport) void Py_SetPythonHome(const wchar_t *);
__declspec(dllimport) wchar_t * Py_GetPythonHome(void);


/* Only used by applications that embed the interpreter and need to
 * override the standard encoding determination mechanism
 */
__declspec(dllimport) int Py_SetStandardStreamEncoding(const char *encoding,
                                             const char *errors);

/* PEP 432 Multi-phase initialization API (Private while provisional!) */
__declspec(dllimport) _PyInitError _Py_InitializeCore(const _PyCoreConfig *);
__declspec(dllimport) int _Py_IsCoreInitialized(void);

__declspec(dllimport) _PyInitError _PyCoreConfig_Read(_PyCoreConfig *);
__declspec(dllimport) void _PyCoreConfig_Clear(_PyCoreConfig *);
__declspec(dllimport) int _PyCoreConfig_Copy(
    _PyCoreConfig *config,
    const _PyCoreConfig *config2);

__declspec(dllimport) _PyInitError _PyMainInterpreterConfig_Read(
    _PyMainInterpreterConfig *config,
    const _PyCoreConfig *core_config);
__declspec(dllimport) void _PyMainInterpreterConfig_Clear(_PyMainInterpreterConfig *);
__declspec(dllimport) int _PyMainInterpreterConfig_Copy(
    _PyMainInterpreterConfig *config,
    const _PyMainInterpreterConfig *config2);

__declspec(dllimport) _PyInitError _Py_InitializeMainInterpreter(const _PyMainInterpreterConfig *);


/* Initialization and finalization */
__declspec(dllimport) void Py_Initialize(void);
__declspec(dllimport) void Py_InitializeEx(int);

__declspec(dllimport) _PyInitError _Py_InitializeEx_Private(int, int);
__declspec(dllimport) void _Py_FatalInitError(_PyInitError err) ;

__declspec(dllimport) void Py_Finalize(void);
__declspec(dllimport) int Py_FinalizeEx(void);
__declspec(dllimport) int Py_IsInitialized(void);

/* Subinterpreter support */
__declspec(dllimport) PyThreadState * Py_NewInterpreter(void);
__declspec(dllimport) void Py_EndInterpreter(PyThreadState *);


/* Py_PyAtExit is for the atexit module, Py_AtExit is for low-level
 * exit functions.
 */

__declspec(dllimport) void _Py_PyAtExit(void (*func)(PyObject *), PyObject *);

__declspec(dllimport) int Py_AtExit(void (*func)(void));

__declspec(dllimport) void Py_Exit(int) ;

/* Restore signals that the interpreter has called SIG_IGN on to SIG_DFL. */

__declspec(dllimport) void _Py_RestoreSignals(void);

__declspec(dllimport) int Py_FdIsInteractive(FILE *, const char *);


/* Bootstrap __main__ (defined in Modules/main.c) */
__declspec(dllimport) int Py_Main(int argc, wchar_t **argv);




/* In getpath.c */
__declspec(dllimport) wchar_t * Py_GetProgramFullPath(void);
__declspec(dllimport) wchar_t * Py_GetPrefix(void);
__declspec(dllimport) wchar_t * Py_GetExecPrefix(void);
__declspec(dllimport) wchar_t * Py_GetPath(void);









__declspec(dllimport) void      Py_SetPath(const wchar_t *);

int _Py_CheckPython3(void);


/* In their own files */
__declspec(dllimport) const char * Py_GetVersion(void);
__declspec(dllimport) const char * Py_GetPlatform(void);
__declspec(dllimport) const char * Py_GetCopyright(void);
__declspec(dllimport) const char * Py_GetCompiler(void);
__declspec(dllimport) const char * Py_GetBuildInfo(void);

__declspec(dllimport) const char * _Py_gitidentifier(void);
__declspec(dllimport) const char * _Py_gitversion(void);


/* Internal -- various one-time initializations */

__declspec(dllimport) PyObject * _PyBuiltin_Init(void);
__declspec(dllimport) _PyInitError _PySys_BeginInit(PyObject **sysmod);
__declspec(dllimport) int _PySys_EndInit(PyObject *sysdict, _PyMainInterpreterConfig *config);
__declspec(dllimport) _PyInitError _PyImport_Init(PyInterpreterState *interp);
__declspec(dllimport) void _PyExc_Init(PyObject * bltinmod);
__declspec(dllimport) _PyInitError _PyImportHooks_Init(void);
__declspec(dllimport) int _PyFrame_Init(void);
__declspec(dllimport) int _PyFloat_Init(void);
__declspec(dllimport) int PyByteArray_Init(void);
__declspec(dllimport) _PyInitError _Py_HashRandomization_Init(const _PyCoreConfig *);








/* Various internal finalizers */












__declspec(dllimport) void PyMethod_Fini(void);
__declspec(dllimport) void PyFrame_Fini(void);
__declspec(dllimport) void PyCFunction_Fini(void);
__declspec(dllimport) void PyDict_Fini(void);
__declspec(dllimport) void PyTuple_Fini(void);
__declspec(dllimport) void PyList_Fini(void);
__declspec(dllimport) void PySet_Fini(void);
__declspec(dllimport) void PyBytes_Fini(void);
__declspec(dllimport) void PyByteArray_Fini(void);
__declspec(dllimport) void PyFloat_Fini(void);
__declspec(dllimport) void PyOS_FiniInterrupts(void);
__declspec(dllimport) void PySlice_Fini(void);
__declspec(dllimport) void PyAsyncGen_Fini(void);

__declspec(dllimport) int _Py_IsFinalizing(void);


/* Signals */
typedef void (*PyOS_sighandler_t)(int);
__declspec(dllimport) PyOS_sighandler_t PyOS_getsig(int);
__declspec(dllimport) PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t);


/* Random */
__declspec(dllimport) int _PyOS_URandom(void *buffer, Py_ssize_t size);
__declspec(dllimport) int _PyOS_URandomNonblock(void *buffer, Py_ssize_t size);


/* Legacy locale support */

__declspec(dllimport) void _Py_CoerceLegacyLocale(const _PyCoreConfig *config);
__declspec(dllimport) int _Py_LegacyLocaleDetected(void);
__declspec(dllimport) char * _Py_SetLocaleFromEnv(int category);















/* Interface to random parts in ceval.c */

/* PyEval_CallObjectWithKeywords(), PyEval_CallObject(), PyEval_CallFunction
 * and PyEval_CallMethod are kept for backward compatibility: PyObject_Call(),
 * PyObject_CallFunction() and PyObject_CallMethod() are recommended to call
 * a callable object.
 */

__declspec(dllimport) PyObject * PyEval_CallObjectWithKeywords(
    PyObject *callable,
    PyObject *args,
    PyObject *kwargs);

/* Inline this */



__declspec(dllimport) PyObject * PyEval_CallFunction(PyObject *callable,
                                           const char *format, ...);
__declspec(dllimport) PyObject * PyEval_CallMethod(PyObject *obj,
                                         const char *name,
                                         const char *format, ...);


__declspec(dllimport) void PyEval_SetProfile(Py_tracefunc, PyObject *);
__declspec(dllimport) void PyEval_SetTrace(Py_tracefunc, PyObject *);
__declspec(dllimport) void _PyEval_SetCoroutineOriginTrackingDepth(int new_depth);
__declspec(dllimport) int _PyEval_GetCoroutineOriginTrackingDepth(void);
__declspec(dllimport) void _PyEval_SetCoroutineWrapper(PyObject *);
__declspec(dllimport) PyObject * _PyEval_GetCoroutineWrapper(void);
__declspec(dllimport) void _PyEval_SetAsyncGenFirstiter(PyObject *);
__declspec(dllimport) PyObject * _PyEval_GetAsyncGenFirstiter(void);
__declspec(dllimport) void _PyEval_SetAsyncGenFinalizer(PyObject *);
__declspec(dllimport) PyObject * _PyEval_GetAsyncGenFinalizer(void);


struct _frame; /* Avoid including frameobject.h */

__declspec(dllimport) PyObject * PyEval_GetBuiltins(void);
__declspec(dllimport) PyObject * PyEval_GetGlobals(void);
__declspec(dllimport) PyObject * PyEval_GetLocals(void);
__declspec(dllimport) struct _frame * PyEval_GetFrame(void);

/* Look at the current frame's (if any) code's co_flags, and turn on
   the corresponding compiler flags in cf->cf_flags.  Return 1 if any
   flag was set, else return 0. */

__declspec(dllimport) int PyEval_MergeCompilerFlags(PyCompilerFlags *cf);


__declspec(dllimport) int Py_AddPendingCall(int (*func)(void *), void *arg);
__declspec(dllimport) void _PyEval_SignalReceived(void);
__declspec(dllimport) int Py_MakePendingCalls(void);

/* Protection against deeply nested recursive calls

   In Python 3.0, this protection has two levels:
   * normal anti-recursion protection is triggered when the recursion level
     exceeds the current recursion limit. It raises a RecursionError, and sets
     the "overflowed" flag in the thread state structure. This flag
     temporarily *disables* the normal protection; this allows cleanup code
     to potentially outgrow the recursion limit while processing the
     RecursionError.
   * "last chance" anti-recursion protection is triggered when the recursion
     level exceeds "current recursion limit + 50". By construction, this
     protection can only be triggered when the "overflowed" flag is set. It
     means the cleanup code has itself gone into an infinite loop, or the
     RecursionError has been mistakingly ignored. When this protection is
     triggered, the interpreter aborts with a Fatal Error.

   In addition, the "overflowed" flag is automatically reset when the
   recursion level drops below "current recursion limit - 50". This heuristic
   is meant to ensure that the normal anti-recursion protection doesn't get
   disabled too long.

   Please note: this scheme has its own limitations. See:
   http://mail.python.org/pipermail/python-dev/2008-August/082106.html
   for some observations.
*/
__declspec(dllimport) void Py_SetRecursionLimit(int);
__declspec(dllimport) int Py_GetRecursionLimit(void);








__declspec(dllimport) int _Py_CheckRecursiveCall(const char *where);

/* Due to the macros in which it's used, _Py_CheckRecursionLimit is in
   the stable ABI.  It should be removed therefrom when possible.
*/
extern __declspec(dllimport) int _Py_CheckRecursionLimit;












/* Compute the "lower-water mark" for a recursion limit. When
 * Py_LeaveRecursiveCall() is called with a recursion depth below this mark,
 * the overflowed flag is reset to 0. */
















__declspec(dllimport) const char * PyEval_GetFuncName(PyObject *);
__declspec(dllimport) const char * PyEval_GetFuncDesc(PyObject *);

__declspec(dllimport) PyObject * PyEval_EvalFrame(struct _frame *);
__declspec(dllimport) PyObject * PyEval_EvalFrameEx(struct _frame *f, int exc);

__declspec(dllimport) PyObject * _PyEval_EvalFrameDefault(struct _frame *f, int exc);


/* Interface for threads.

   A module that plans to do a blocking system call (or something else
   that lasts a long time and doesn't touch Python data) can allow other
   threads to run as follows:

    ...preparations here...
    Py_BEGIN_ALLOW_THREADS
    ...blocking system call here...
    Py_END_ALLOW_THREADS
    ...interpret result here...

   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
   {}-surrounded block.
   To leave the block in the middle (e.g., with return), you must insert
   a line containing Py_BLOCK_THREADS before the return, e.g.

    if (...premature_exit...) {
        Py_BLOCK_THREADS
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }

   An alternative is:

    Py_BLOCK_THREADS
    if (...premature_exit...) {
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }
    Py_UNBLOCK_THREADS

   For convenience, that the value of 'errno' is restored across
   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.

   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
   Py_END_ALLOW_THREADS!!!

   The function PyEval_InitThreads() should be called only from
   init_thread() in "_threadmodule.c".

   Note that not yet all candidates have been converted to use this
   mechanism!
*/

__declspec(dllimport) PyThreadState * PyEval_SaveThread(void);
__declspec(dllimport) void PyEval_RestoreThread(PyThreadState *);

__declspec(dllimport) int  PyEval_ThreadsInitialized(void);
__declspec(dllimport) void PyEval_InitThreads(void);

__declspec(dllimport) void _PyEval_FiniThreads(void);

__declspec(dllimport) void PyEval_AcquireLock(void) ;
__declspec(dllimport) void PyEval_ReleaseLock(void) /* Py_DEPRECATED(3.2) */;
__declspec(dllimport) void PyEval_AcquireThread(PyThreadState *tstate);
__declspec(dllimport) void PyEval_ReleaseThread(PyThreadState *tstate);
__declspec(dllimport) void PyEval_ReInitThreads(void);


__declspec(dllimport) void _PyEval_SetSwitchInterval(unsigned long microseconds);
__declspec(dllimport) unsigned long _PyEval_GetSwitchInterval(void);



__declspec(dllimport) Py_ssize_t _PyEval_RequestCodeExtraIndex(freefunc);











__declspec(dllimport) int _PyEval_SliceIndex(PyObject *, Py_ssize_t *);
__declspec(dllimport) int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *);
__declspec(dllimport) void _PyEval_SignalAsyncExc(void);


/* Masks and values used by FORMAT_VALUE opcode. */















/* System module interface */







__declspec(dllimport) PyObject * PySys_GetObject(const char *);
__declspec(dllimport) int PySys_SetObject(const char *, PyObject *);

__declspec(dllimport) PyObject * _PySys_GetObjectId(_Py_Identifier *key);
__declspec(dllimport) int _PySys_SetObjectId(_Py_Identifier *key, PyObject *);


__declspec(dllimport) void PySys_SetArgv(int, wchar_t **);
__declspec(dllimport) void PySys_SetArgvEx(int, wchar_t **, int);
__declspec(dllimport) void PySys_SetPath(const wchar_t *);

__declspec(dllimport) void PySys_WriteStdout(const char *format, ...)
                 ;
__declspec(dllimport) void PySys_WriteStderr(const char *format, ...)
                 ;
__declspec(dllimport) void PySys_FormatStdout(const char *format, ...);
__declspec(dllimport) void PySys_FormatStderr(const char *format, ...);

__declspec(dllimport) void PySys_ResetWarnOptions(void);
__declspec(dllimport) void PySys_AddWarnOption(const wchar_t *);
__declspec(dllimport) void PySys_AddWarnOptionUnicode(PyObject *);
__declspec(dllimport) int PySys_HasWarnOptions(void);

__declspec(dllimport) void PySys_AddXOption(const wchar_t *);
__declspec(dllimport) PyObject * PySys_GetXOptions(void);


__declspec(dllimport) size_t _PySys_GetSizeOf(PyObject *);














/* os module interface */








__declspec(dllimport) PyObject * PyOS_FSPath(PyObject *path);















__declspec(dllimport) int PyOS_InterruptOccurred(void);
__declspec(dllimport) void PyOS_InitInterrupts(void);







/* Deprecated, please use PyOS_AfterFork_Child() instead */
__declspec(dllimport) void PyOS_AfterFork(void) ;


__declspec(dllimport) int _PyOS_IsMainThread(void);
__declspec(dllimport) void _PySignal_AfterFork(void);


/* windows.h is not included by Python.h so use void* instead of HANDLE */
__declspec(dllimport) void* _PyOS_SigintEvent(void);










/* Module definition and import interface */








__declspec(dllimport) _PyInitError _PyImportZip_Init(void);

__declspec(dllexport) PyObject* PyInit__imp(void);

__declspec(dllimport) long PyImport_GetMagicNumber(void);
__declspec(dllimport) const char * PyImport_GetMagicTag(void);
__declspec(dllimport) PyObject * PyImport_ExecCodeModule(
    const char *name,           /* UTF-8 encoded string */
    PyObject *co
    );
__declspec(dllimport) PyObject * PyImport_ExecCodeModuleEx(
    const char *name,           /* UTF-8 encoded string */
    PyObject *co,
    const char *pathname        /* decoded from the filesystem encoding */
    );
__declspec(dllimport) PyObject * PyImport_ExecCodeModuleWithPathnames(
    const char *name,           /* UTF-8 encoded string */
    PyObject *co,
    const char *pathname,       /* decoded from the filesystem encoding */
    const char *cpathname       /* decoded from the filesystem encoding */
    );

__declspec(dllimport) PyObject * PyImport_ExecCodeModuleObject(
    PyObject *name,
    PyObject *co,
    PyObject *pathname,
    PyObject *cpathname
    );

__declspec(dllimport) PyObject * PyImport_GetModuleDict(void);

__declspec(dllimport) PyObject * PyImport_GetModule(PyObject *name);


__declspec(dllimport) int _PyImport_IsInitialized(PyInterpreterState *);
__declspec(dllimport) PyObject * _PyImport_GetModuleId(struct _Py_Identifier *name);
__declspec(dllimport) PyObject * _PyImport_AddModuleObject(PyObject *name,
                                                 PyObject *modules);
__declspec(dllimport) int _PyImport_SetModule(PyObject *name, PyObject *module);
__declspec(dllimport) int _PyImport_SetModuleString(const char *name, PyObject* module);


__declspec(dllimport) PyObject * PyImport_AddModuleObject(
    PyObject *name
    );


__declspec(dllimport) PyObject * _PyImport_AddModuleObject(PyObject *, PyObject *);

__declspec(dllimport) PyObject * PyImport_AddModule(
    const char *name            /* UTF-8 encoded string */
    );
__declspec(dllimport) PyObject * PyImport_ImportModule(
    const char *name            /* UTF-8 encoded string */
    );
__declspec(dllimport) PyObject * PyImport_ImportModuleNoBlock(
    const char *name            /* UTF-8 encoded string */
    );
__declspec(dllimport) PyObject * PyImport_ImportModuleLevel(
    const char *name,           /* UTF-8 encoded string */
    PyObject *globals,
    PyObject *locals,
    PyObject *fromlist,
    int level
    );

__declspec(dllimport) PyObject * PyImport_ImportModuleLevelObject(
    PyObject *name,
    PyObject *globals,
    PyObject *locals,
    PyObject *fromlist,
    int level
    );





__declspec(dllimport) PyObject * PyImport_GetImporter(PyObject *path);
__declspec(dllimport) PyObject * PyImport_Import(PyObject *name);
__declspec(dllimport) PyObject * PyImport_ReloadModule(PyObject *m);
__declspec(dllimport) void PyImport_Cleanup(void);

__declspec(dllimport) int PyImport_ImportFrozenModuleObject(
    PyObject *name
    );

__declspec(dllimport) int PyImport_ImportFrozenModule(
    const char *name            /* UTF-8 encoded string */
    );


__declspec(dllimport) void _PyImport_AcquireLock(void);
__declspec(dllimport) int _PyImport_ReleaseLock(void);

__declspec(dllimport) void _PyImport_ReInitLock(void);

__declspec(dllimport) PyObject * _PyImport_FindBuiltin(
    const char *name,            /* UTF-8 encoded string */
    PyObject *modules
    );
__declspec(dllimport) PyObject * _PyImport_FindExtensionObject(PyObject *, PyObject *);
__declspec(dllimport) PyObject * _PyImport_FindExtensionObjectEx(PyObject *, PyObject *,
                                                       PyObject *);
__declspec(dllimport) int _PyImport_FixupBuiltin(
    PyObject *mod,
    const char *name,            /* UTF-8 encoded string */
    PyObject *modules
    );
__declspec(dllimport) int _PyImport_FixupExtensionObject(PyObject*, PyObject *,
                                               PyObject *, PyObject *);

struct _inittab {
    const char *name;           /* ASCII encoded string */
    PyObject* (*initfunc)(void);
};
extern __declspec(dllimport) struct _inittab * PyImport_Inittab;
__declspec(dllimport) int PyImport_ExtendInittab(struct _inittab *newtab);


extern __declspec(dllimport) PyTypeObject PyNullImporter_Type;

__declspec(dllimport) int PyImport_AppendInittab(
    const char *name,           /* ASCII encoded string */
    PyObject* (*initfunc)(void)
    );


struct _frozen {
    const char *name;                 /* ASCII encoded string */
    const unsigned char *code;
    int size;
};

/* Embedding apps may change this pointer to point to their favorite
   collection of frozen modules: */

extern __declspec(dllimport) const struct _frozen * PyImport_FrozenModules;









/* Abstract Object Interface (many thanks to Jim Fulton) */







/* === Object Protocol ================================================== */

/* Implemented elsewhere:

   int PyObject_Print(PyObject *o, FILE *fp, int flags);

   Print an object 'o' on file 'fp'.  Returns -1 on error. The flags argument
   is used to enable certain printing options. The only option currently
   supported is Py_Print_RAW.

   (What should be said about Py_Print_RAW?). */


/* Implemented elsewhere:

   int PyObject_HasAttrString(PyObject *o, const char *attr_name);

   Returns 1 if object 'o' has the attribute attr_name, and 0 otherwise.

   This is equivalent to the Python expression: hasattr(o,attr_name).

   This function always succeeds. */


/* Implemented elsewhere:

   PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name);

   Retrieve an attributed named attr_name form object o.
   Returns the attribute value on success, or NULL on failure.

   This is the equivalent of the Python expression: o.attr_name. */


/* Implemented elsewhere:

   int PyObject_HasAttr(PyObject *o, PyObject *attr_name);

   Returns 1 if o has the attribute attr_name, and 0 otherwise.

   This is equivalent to the Python expression: hasattr(o,attr_name).

   This function always succeeds. */

/* Implemented elsewhere:

   PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);

   Retrieve an attributed named 'attr_name' form object 'o'.
   Returns the attribute value on success, or NULL on failure.

   This is the equivalent of the Python expression: o.attr_name. */


/* Implemented elsewhere:

   int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v);

   Set the value of the attribute named attr_name, for object 'o',
   to the value 'v'. Raise an exception and return -1 on failure; return 0 on
   success.

   This is the equivalent of the Python statement o.attr_name=v. */


/* Implemented elsewhere:

   int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);

   Set the value of the attribute named attr_name, for object 'o', to the value
   'v'. an exception and return -1 on failure; return 0 on success.

   This is the equivalent of the Python statement o.attr_name=v. */

/* Implemented as a macro:

   int PyObject_DelAttrString(PyObject *o, const char *attr_name);

   Delete attribute named attr_name, for object o. Returns
   -1 on failure.

   This is the equivalent of the Python statement: del o.attr_name. */



/* Implemented as a macro:

   int PyObject_DelAttr(PyObject *o, PyObject *attr_name);

   Delete attribute named attr_name, for object o. Returns -1
   on failure.  This is the equivalent of the Python
   statement: del o.attr_name. */



/* Implemented elsewhere:

   PyObject *PyObject_Repr(PyObject *o);

   Compute the string representation of object 'o'.  Returns the
   string representation on success, NULL on failure.

   This is the equivalent of the Python expression: repr(o).

   Called by the repr() built-in function. */


/* Implemented elsewhere:

   PyObject *PyObject_Str(PyObject *o);

   Compute the string representation of object, o.  Returns the
   string representation on success, NULL on failure.

   This is the equivalent of the Python expression: str(o).

   Called by the str() and print() built-in functions. */


/* Declared elsewhere

   PyAPI_FUNC(int) PyCallable_Check(PyObject *o);

   Determine if the object, o, is callable.  Return 1 if the object is callable
   and 0 otherwise.

   This function always succeeds. */











/* Call a callable Python object 'callable' with arguments given by the
   tuple 'args' and keywords arguments given by the dictionary 'kwargs'.

   'args' must not be *NULL*, use an empty tuple if no arguments are
   needed. If no named arguments are needed, 'kwargs' can be NULL.

   This is the equivalent of the Python expression:
   callable(*args, **kwargs). */
__declspec(dllimport) PyObject * PyObject_Call(PyObject *callable,
                                     PyObject *args, PyObject *kwargs);


__declspec(dllimport) PyObject* _PyStack_AsTuple(
    PyObject *const *stack,
    Py_ssize_t nargs);

__declspec(dllimport) PyObject* _PyStack_AsTupleSlice(
    PyObject *const *stack,
    Py_ssize_t nargs,
    Py_ssize_t start,
    Py_ssize_t end);

/* Convert keyword arguments from the FASTCALL (stack: C array, kwnames: tuple)
   format to a Python dictionary ("kwargs" dict).

   The type of kwnames keys is not checked. The final function getting
   arguments is responsible to check if all keys are strings, for example using
   PyArg_ParseTupleAndKeywords() or PyArg_ValidateKeywordArguments().

   Duplicate keys are merged using the last value. If duplicate keys must raise
   an exception, the caller is responsible to implement an explicit keys on
   kwnames. */
__declspec(dllimport) PyObject * _PyStack_AsDict(
    PyObject *const *values,
    PyObject *kwnames);

/* Convert (args, nargs, kwargs: dict) into a (stack, nargs, kwnames: tuple).

   Return 0 on success, raise an exception and return -1 on error.

   Write the new stack into *p_stack. If *p_stack is differen than args, it
   must be released by PyMem_Free().

   The stack uses borrowed references.

   The type of keyword keys is not checked, these checks should be done
   later (ex: _PyArg_ParseStackAndKeywords). */
__declspec(dllimport) int _PyStack_UnpackDict(
    PyObject *const *args,
    Py_ssize_t nargs,
    PyObject *kwargs,
    PyObject *const **p_stack,
    PyObject **p_kwnames);

/* Suggested size (number of positional arguments) for arrays of PyObject*
   allocated on a C stack to avoid allocating memory on the heap memory. Such
   array is used to pass positional arguments to call functions of the
   _PyObject_FastCall() family.

   The size is chosen to not abuse the C stack and so limit the risk of stack
   overflow. The size is also chosen to allow using the small stack for most
   function calls of the Python standard library. On 64-bit CPU, it allocates
   40 bytes on the stack. */


/* Return 1 if callable supports FASTCALL calling convention for positional
   arguments: see _PyObject_FastCallDict() and _PyObject_FastCallKeywords() */
__declspec(dllimport) int _PyObject_HasFastCall(PyObject *callable);

/* Call the callable object 'callable' with the "fast call" calling convention:
   args is a C array for positional arguments (nargs is the number of
   positional arguments), kwargs is a dictionary for keyword arguments.

   If nargs is equal to zero, args can be NULL. kwargs can be NULL.
   nargs must be greater or equal to zero.

   Return the result on success. Raise an exception on return NULL on
   error. */
__declspec(dllimport) PyObject * _PyObject_FastCallDict(
    PyObject *callable,
    PyObject *const *args,
    Py_ssize_t nargs,
    PyObject *kwargs);

/* Call the callable object 'callable' with the "fast call" calling convention:
   args is a C array for positional arguments followed by values of
   keyword arguments. Keys of keyword arguments are stored as a tuple
   of strings in kwnames. nargs is the number of positional parameters at
   the beginning of stack. The size of kwnames gives the number of keyword
   values in the stack after positional arguments.

   kwnames must only contains str strings, no subclass, and all keys must
   be unique.

   If nargs is equal to zero and there is no keyword argument (kwnames is
   NULL or its size is zero), args can be NULL.

   Return the result on success. Raise an exception and return NULL on
   error. */
__declspec(dllimport) PyObject * _PyObject_FastCallKeywords(
    PyObject *callable,
    PyObject *const *args,
    Py_ssize_t nargs,
    PyObject *kwnames);







__declspec(dllimport) PyObject * _PyObject_Call_Prepend(
    PyObject *callable,
    PyObject *obj,
    PyObject *args,
    PyObject *kwargs);

__declspec(dllimport) PyObject * _PyObject_FastCall_Prepend(
    PyObject *callable,
    PyObject *obj,
    PyObject *const *args,
    Py_ssize_t nargs);

__declspec(dllimport) PyObject * _Py_CheckFunctionResult(PyObject *callable,
                                               PyObject *result,
                                               const char *where);



/* Call a callable Python object 'callable', with arguments given by the
   tuple 'args'.  If no arguments are needed, then 'args' can be *NULL*.

   Returns the result of the call on success, or *NULL* on failure.

   This is the equivalent of the Python expression:
   callable(*args). */
__declspec(dllimport) PyObject * PyObject_CallObject(PyObject *callable,
                                           PyObject *args);

/* Call a callable Python object, callable, with a variable number of C
   arguments. The C arguments are described using a mkvalue-style format
   string.

   The format may be NULL, indicating that no arguments are provided.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   callable(arg1, arg2, ...). */
__declspec(dllimport) PyObject * PyObject_CallFunction(PyObject *callable,
                                             const char *format, ...);

/* Call the method named 'name' of object 'obj' with a variable number of
   C arguments.  The C arguments are described by a mkvalue format string.

   The format can be NULL, indicating that no arguments are provided.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   obj.name(arg1, arg2, ...). */
__declspec(dllimport) PyObject * PyObject_CallMethod(PyObject *obj,
                                           const char *name,
                                           const char *format, ...);


/* Like PyObject_CallMethod(), but expect a _Py_Identifier*
   as the method name. */
__declspec(dllimport) PyObject * _PyObject_CallMethodId(PyObject *obj,
                                              _Py_Identifier *name,
                                              const char *format, ...);


__declspec(dllimport) PyObject * _PyObject_CallFunction_SizeT(PyObject *callable,
                                                    const char *format,
                                                    ...);

__declspec(dllimport) PyObject * _PyObject_CallMethod_SizeT(PyObject *obj,
                                                  const char *name,
                                                  const char *format,
                                                  ...);


__declspec(dllimport) PyObject * _PyObject_CallMethodId_SizeT(PyObject *obj,
                                                    _Py_Identifier *name,
                                                    const char *format,
                                                    ...);


/* Call a callable Python object 'callable' with a variable number of C
   arguments. The C arguments are provided as PyObject* values, terminated
   by a NULL.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   callable(arg1, arg2, ...). */
__declspec(dllimport) PyObject * PyObject_CallFunctionObjArgs(PyObject *callable,
                                                    ...);

/* Call the method named 'name' of object 'obj' with a variable number of
   C arguments.  The C arguments are provided as PyObject* values, terminated
   by NULL.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression: obj.name(*args). */

__declspec(dllimport) PyObject * PyObject_CallMethodObjArgs(
    PyObject *obj,
    PyObject *name,
    ...);


__declspec(dllimport) PyObject * _PyObject_CallMethodIdObjArgs(
    PyObject *obj,
    struct _Py_Identifier *name,
    ...);



/* Implemented elsewhere:

   Py_hash_t PyObject_Hash(PyObject *o);

   Compute and return the hash, hash_value, of an object, o.  On
   failure, return -1.

   This is the equivalent of the Python expression: hash(o). */


/* Implemented elsewhere:

   int PyObject_IsTrue(PyObject *o);

   Returns 1 if the object, o, is considered to be true, 0 if o is
   considered to be false and -1 on failure.

   This is equivalent to the Python expression: not not o. */


/* Implemented elsewhere:

   int PyObject_Not(PyObject *o);

   Returns 0 if the object, o, is considered to be true, 1 if o is
   considered to be false and -1 on failure.

   This is equivalent to the Python expression: not o. */


/* Get the type of an object.

   On success, returns a type object corresponding to the object type of object
   'o'. On failure, returns NULL.

   This is equivalent to the Python expression: type(o) */
__declspec(dllimport) PyObject * PyObject_Type(PyObject *o);


/* Return the size of object 'o'.  If the object 'o' provides both sequence and
   mapping protocols, the sequence size is returned.

   On error, -1 is returned.

   This is the equivalent to the Python expression: len(o) */
__declspec(dllimport) Py_ssize_t PyObject_Size(PyObject *o);


/* For DLL compatibility */

__declspec(dllimport) Py_ssize_t PyObject_Length(PyObject *o);




__declspec(dllimport) int _PyObject_HasLen(PyObject *o);

/* Guess the size of object 'o' using len(o) or o.__length_hint__().
   If neither of those return a non-negative value, then return the default
   value.  If one of the calls fails, this function returns -1. */
__declspec(dllimport) Py_ssize_t PyObject_LengthHint(PyObject *o, Py_ssize_t);


/* Return element of 'o' corresponding to the object 'key'. Return NULL
  on failure.

  This is the equivalent of the Python expression: o[key] */
__declspec(dllimport) PyObject * PyObject_GetItem(PyObject *o, PyObject *key);


/* Map the object 'key' to the value 'v' into 'o'.

   Raise an exception and return -1 on failure; return 0 on success.

   This is the equivalent of the Python statement: o[key]=v. */
__declspec(dllimport) int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);

/* Remove the mapping for the string 'key' from the object 'o'.
   Returns -1 on failure.

   This is equivalent to the Python statement: del o[key]. */
__declspec(dllimport) int PyObject_DelItemString(PyObject *o, const char *key);

/* Delete the mapping for the object 'key' from the object 'o'.
   Returns -1 on failure.

   This is the equivalent of the Python statement: del o[key]. */
__declspec(dllimport) int PyObject_DelItem(PyObject *o, PyObject *key);


/* === Old Buffer API ============================================ */

/* FIXME:  usage of these should all be replaced in Python itself
   but for backwards compatibility we will implement them.
   Their usage without a corresponding "unlock" mechanism
   may create issues (but they would already be there). */

/* Takes an arbitrary object which must support the (character, single segment)
   buffer interface and returns a pointer to a read-only memory location
   useable as character based input for subsequent processing.

   Return 0 on success.  buffer and buffer_len are only set in case no error
   occurs. Otherwise, -1 is returned and an exception set. */
__declspec(dllimport) int PyObject_AsCharBuffer(PyObject *obj,
                                      const char **buffer,
                                      Py_ssize_t *buffer_len)
                                      ;

/* Checks whether an arbitrary object supports the (character, single segment)
   buffer interface.

   Returns 1 on success, 0 on failure. */
__declspec(dllimport) int PyObject_CheckReadBuffer(PyObject *obj)
                                         ;

/* Same as PyObject_AsCharBuffer() except that this API expects (readable,
   single segment) buffer interface and returns a pointer to a read-only memory
   location which can contain arbitrary data.

   0 is returned on success.  buffer and buffer_len are only set in case no
   error occurs.  Otherwise, -1 is returned and an exception set. */
__declspec(dllimport) int PyObject_AsReadBuffer(PyObject *obj,
                                      const void **buffer,
                                      Py_ssize_t *buffer_len)
                                      ;

/* Takes an arbitrary object which must support the (writable, single segment)
   buffer interface and returns a pointer to a writable memory location in
   buffer of size 'buffer_len'.

   Return 0 on success.  buffer and buffer_len are only set in case no error
   occurs. Otherwise, -1 is returned and an exception set. */
__declspec(dllimport) int PyObject_AsWriteBuffer(PyObject *obj,
                                       void **buffer,
                                       Py_ssize_t *buffer_len)
                                       ;


/* === New Buffer API ============================================ */



/* Return 1 if the getbuffer function is available, otherwise return 0. */




/* This is a C-API version of the getbuffer function call.  It checks
   to make sure object has the required function pointer and issues the
   call.

   Returns -1 and raises an error on failure and returns 0 on success. */
__declspec(dllimport) int PyObject_GetBuffer(PyObject *obj, Py_buffer *view,
                                   int flags);

/* Get the memory area pointed to by the indices for the buffer given.
   Note that view->ndim is the assumed size of indices. */
__declspec(dllimport) void * PyBuffer_GetPointer(Py_buffer *view, Py_ssize_t *indices);

/* Return the implied itemsize of the data-format area from a
   struct-style description. */
__declspec(dllimport) int PyBuffer_SizeFromFormat(const char *);

/* Implementation in memoryobject.c */
__declspec(dllimport) int PyBuffer_ToContiguous(void *buf, Py_buffer *view,
                                      Py_ssize_t len, char order);

__declspec(dllimport) int PyBuffer_FromContiguous(Py_buffer *view, void *buf,
                                        Py_ssize_t len, char order);

/* Copy len bytes of data from the contiguous chunk of memory
   pointed to by buf into the buffer exported by obj.  Return
   0 on success and return -1 and raise a PyBuffer_Error on
   error (i.e. the object does not have a buffer interface or
   it is not working).

   If fort is 'F', then if the object is multi-dimensional,
   then the data will be copied into the array in
   Fortran-style (first dimension varies the fastest).  If
   fort is 'C', then the data will be copied into the array
   in C-style (last dimension varies the fastest).  If fort
   is 'A', then it does not matter and the copy will be made
   in whatever way is more efficient. */
__declspec(dllimport) int PyObject_CopyData(PyObject *dest, PyObject *src);

/* Copy the data from the src buffer to the buffer of destination. */
__declspec(dllimport) int PyBuffer_IsContiguous(const Py_buffer *view, char fort);

/*Fill the strides array with byte-strides of a contiguous
  (Fortran-style if fort is 'F' or C-style otherwise)
  array of the given shape with the given number of bytes
  per element. */
__declspec(dllimport) void PyBuffer_FillContiguousStrides(int ndims,
                                               Py_ssize_t *shape,
                                               Py_ssize_t *strides,
                                               int itemsize,
                                               char fort);

/* Fills in a buffer-info structure correctly for an exporter
   that can only share a contiguous chunk of memory of
   "unsigned bytes" of the given length.

   Returns 0 on success and -1 (with raising an error) on error. */
__declspec(dllimport) int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf,
                                  Py_ssize_t len, int readonly,
                                  int flags);

/* Releases a Py_buffer obtained from getbuffer ParseTuple's "s*". */
__declspec(dllimport) void PyBuffer_Release(Py_buffer *view);



/* Takes an arbitrary object and returns the result of calling
   obj.__format__(format_spec). */
__declspec(dllimport) PyObject * PyObject_Format(PyObject *obj,
                                       PyObject *format_spec);


/* ==== Iterators ================================================ */

/* Takes an object and returns an iterator for it.
   This is typically a new iterator but if the argument is an iterator, this
   returns itself. */
__declspec(dllimport) PyObject * PyObject_GetIter(PyObject *);





/* Takes an iterator object and calls its tp_iternext slot,
   returning the next value.

   If the iterator is exhausted, this returns NULL without setting an
   exception.

   NULL with an exception means an error occurred. */
__declspec(dllimport) PyObject * PyIter_Next(PyObject *);


/* === Number Protocol ================================================== */

/* Returns 1 if the object 'o' provides numeric protocols, and 0 otherwise.

   This function always succeeds. */
__declspec(dllimport) int PyNumber_Check(PyObject *o);

/* Returns the result of adding o1 and o2, or NULL on failure.

   This is the equivalent of the Python expression: o1 + o2. */
__declspec(dllimport) PyObject * PyNumber_Add(PyObject *o1, PyObject *o2);

/* Returns the result of subtracting o2 from o1, or NULL on failure.

   This is the equivalent of the Python expression: o1 - o2. */
__declspec(dllimport) PyObject * PyNumber_Subtract(PyObject *o1, PyObject *o2);

/* Returns the result of multiplying o1 and o2, or NULL on failure.

   This is the equivalent of the Python expression: o1 * o2. */
__declspec(dllimport) PyObject * PyNumber_Multiply(PyObject *o1, PyObject *o2);


/* This is the equivalent of the Python expression: o1 @ o2. */
__declspec(dllimport) PyObject * PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);


/* Returns the result of dividing o1 by o2 giving an integral result,
   or NULL on failure.

   This is the equivalent of the Python expression: o1 // o2. */
__declspec(dllimport) PyObject * PyNumber_FloorDivide(PyObject *o1, PyObject *o2);

/* Returns the result of dividing o1 by o2 giving a float result, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 / o2. */
__declspec(dllimport) PyObject * PyNumber_TrueDivide(PyObject *o1, PyObject *o2);

/* Returns the remainder of dividing o1 by o2, or NULL on failure.

   This is the equivalent of the Python expression: o1 % o2. */
__declspec(dllimport) PyObject * PyNumber_Remainder(PyObject *o1, PyObject *o2);

/* See the built-in function divmod.

   Returns NULL on failure.

   This is the equivalent of the Python expression: divmod(o1, o2). */
__declspec(dllimport) PyObject * PyNumber_Divmod(PyObject *o1, PyObject *o2);

/* See the built-in function pow. Returns NULL on failure.

   This is the equivalent of the Python expression: pow(o1, o2, o3),
   where o3 is optional. */
__declspec(dllimport) PyObject * PyNumber_Power(PyObject *o1, PyObject *o2,
                                      PyObject *o3);

/* Returns the negation of o on success, or NULL on failure.

 This is the equivalent of the Python expression: -o. */
__declspec(dllimport) PyObject * PyNumber_Negative(PyObject *o);

/* Returns the positive of o on success, or NULL on failure.

   This is the equivalent of the Python expression: +o. */
__declspec(dllimport) PyObject * PyNumber_Positive(PyObject *o);

/* Returns the absolute value of 'o', or NULL on failure.

   This is the equivalent of the Python expression: abs(o). */
__declspec(dllimport) PyObject * PyNumber_Absolute(PyObject *o);

/* Returns the bitwise negation of 'o' on success, or NULL on failure.

   This is the equivalent of the Python expression: ~o. */
__declspec(dllimport) PyObject * PyNumber_Invert(PyObject *o);

/* Returns the result of left shifting o1 by o2 on success, or NULL on failure.

   This is the equivalent of the Python expression: o1 << o2. */
__declspec(dllimport) PyObject * PyNumber_Lshift(PyObject *o1, PyObject *o2);

/* Returns the result of right shifting o1 by o2 on success, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 >> o2. */
__declspec(dllimport) PyObject * PyNumber_Rshift(PyObject *o1, PyObject *o2);

/* Returns the result of bitwise and of o1 and o2 on success, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 & o2. */
__declspec(dllimport) PyObject * PyNumber_And(PyObject *o1, PyObject *o2);

/* Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.

   This is the equivalent of the Python expression: o1 ^ o2. */
__declspec(dllimport) PyObject * PyNumber_Xor(PyObject *o1, PyObject *o2);

/* Returns the result of bitwise or on o1 and o2 on success, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 | o2. */
__declspec(dllimport) PyObject * PyNumber_Or(PyObject *o1, PyObject *o2);





/* Returns the object 'o' converted to a Python int, or NULL with an exception
   raised on failure. */
__declspec(dllimport) PyObject * PyNumber_Index(PyObject *o);

/* Returns the object 'o' converted to Py_ssize_t by going through
   PyNumber_Index() first.

   If an overflow error occurs while converting the int to Py_ssize_t, then the
   second argument 'exc' is the error-type to return.  If it is NULL, then the
   overflow error is cleared and the value is clipped. */
__declspec(dllimport) Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc);

/* Returns the object 'o' converted to an integer object on success, or NULL
   on failure.

   This is the equivalent of the Python expression: int(o). */
__declspec(dllimport) PyObject * PyNumber_Long(PyObject *o);

/* Returns the object 'o' converted to a float object on success, or NULL
  on failure.

  This is the equivalent of the Python expression: float(o). */
__declspec(dllimport) PyObject * PyNumber_Float(PyObject *o);


/* --- In-place variants of (some of) the above number protocol functions -- */

/* Returns the result of adding o2 to o1, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 += o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);

/* Returns the result of subtracting o2 from o1, possibly in-place or
   NULL on failure.

   This is the equivalent of the Python expression: o1 -= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);

/* Returns the result of multiplying o1 by o2, possibly in-place, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 *= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);


/* This is the equivalent of the Python expression: o1 @= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);


/* Returns the result of dividing o1 by o2 giving an integral result, possibly
   in-place, or NULL on failure.

   This is the equivalent of the Python expression: o1 /= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceFloorDivide(PyObject *o1,
                                                   PyObject *o2);

/* Returns the result of dividing o1 by o2 giving a float result, possibly
   in-place, or null on failure.

   This is the equivalent of the Python expression: o1 /= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceTrueDivide(PyObject *o1,
                                                  PyObject *o2);

/* Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 %= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);

/* Returns the result of raising o1 to the power of o2, possibly in-place,
   or NULL on failure.

   This is the equivalent of the Python expression: o1 **= o2,
   or o1 = pow(o1, o2, o3) if o3 is present. */
__declspec(dllimport) PyObject * PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
                                             PyObject *o3);

/* Returns the result of left shifting o1 by o2, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 <<= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);

/* Returns the result of right shifting o1 by o2, possibly in-place or NULL
   on failure.

   This is the equivalent of the Python expression: o1 >>= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);

/* Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 &= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);

/* Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 ^= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);

/* Returns the result of bitwise or of o1 and o2, possibly in-place,
   or NULL on failure.

   This is the equivalent of the Python expression: o1 |= o2. */
__declspec(dllimport) PyObject * PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);

/* Returns the integer n converted to a string with a base, with a base
   marker of 0b, 0o or 0x prefixed if applicable.

   If n is not an int object, it is converted with PyNumber_Index first. */
__declspec(dllimport) PyObject * PyNumber_ToBase(PyObject *n, int base);


/* === Sequence protocol ================================================ */

/* Return 1 if the object provides sequence protocol, and zero
   otherwise.

   This function always succeeds. */
__declspec(dllimport) int PySequence_Check(PyObject *o);

/* Return the size of sequence object o, or -1 on failure. */
__declspec(dllimport) Py_ssize_t PySequence_Size(PyObject *o);

/* For DLL compatibility */

__declspec(dllimport) Py_ssize_t PySequence_Length(PyObject *o);



/* Return the concatenation of o1 and o2 on success, and NULL on failure.

   This is the equivalent of the Python expression: o1 + o2. */
__declspec(dllimport) PyObject * PySequence_Concat(PyObject *o1, PyObject *o2);

/* Return the result of repeating sequence object 'o' 'count' times,
  or NULL on failure.

  This is the equivalent of the Python expression: o * count. */
__declspec(dllimport) PyObject * PySequence_Repeat(PyObject *o, Py_ssize_t count);

/* Return the ith element of o, or NULL on failure.

   This is the equivalent of the Python expression: o[i]. */
__declspec(dllimport) PyObject * PySequence_GetItem(PyObject *o, Py_ssize_t i);

/* Return the slice of sequence object o between i1 and i2, or NULL on failure.

   This is the equivalent of the Python expression: o[i1:i2]. */
__declspec(dllimport) PyObject * PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);

/* Assign object 'v' to the ith element of the sequence 'o'. Raise an exception
   and return -1 on failure; return 0 on success.

   This is the equivalent of the Python statement o[i] = v. */
__declspec(dllimport) int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v);

/* Delete the 'i'-th element of the sequence 'v'. Returns -1 on failure.

   This is the equivalent of the Python statement: del o[i]. */
__declspec(dllimport) int PySequence_DelItem(PyObject *o, Py_ssize_t i);

/* Assign the sequence object 'v' to the slice in sequence object 'o',
   from 'i1' to 'i2'. Returns -1 on failure.

   This is the equivalent of the Python statement: o[i1:i2] = v. */
__declspec(dllimport) int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2,
                                    PyObject *v);

/* Delete the slice in sequence object 'o' from 'i1' to 'i2'.
   Returns -1 on failure.

   This is the equivalent of the Python statement: del o[i1:i2]. */
__declspec(dllimport) int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);

/* Returns the sequence 'o' as a tuple on success, and NULL on failure.

   This is equivalent to the Python expression: tuple(o). */
__declspec(dllimport) PyObject * PySequence_Tuple(PyObject *o);

/* Returns the sequence 'o' as a list on success, and NULL on failure.
   This is equivalent to the Python expression: list(o) */
__declspec(dllimport) PyObject * PySequence_List(PyObject *o);

/* Return the sequence 'o' as a list, unless it's already a tuple or list.

   Use PySequence_Fast_GET_ITEM to access the members of this list, and
   PySequence_Fast_GET_SIZE to get its length.

   Returns NULL on failure.  If the object does not support iteration, raises a
   TypeError exception with 'm' as the message text. */
__declspec(dllimport) PyObject * PySequence_Fast(PyObject *o, const char* m);

/* Return the size of the sequence 'o', assuming that 'o' was returned by
   PySequence_Fast and is not NULL. */



/* Return the 'i'-th element of the sequence 'o', assuming that o was returned
   by PySequence_Fast, and that i is within bounds. */



/* Assume tp_as_sequence and sq_item exist and that 'i' does not
   need to be corrected for a negative index. */



/* Return a pointer to the underlying item array for
   an object retured by PySequence_Fast */




/* Return the number of occurrences on value on 'o', that is, return
   the number of keys for which o[key] == value.

   On failure, return -1.  This is equivalent to the Python expression:
   o.count(value). */
__declspec(dllimport) Py_ssize_t PySequence_Count(PyObject *o, PyObject *value);

/* Return 1 if 'ob' is in the sequence 'seq'; 0 if 'ob' is not in the sequence
   'seq'; -1 on error.

   Use __contains__ if possible, else _PySequence_IterSearch(). */
__declspec(dllimport) int PySequence_Contains(PyObject *seq, PyObject *ob);






/* Iterate over seq.

   Result depends on the operation:

   PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if
     error.
   PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of
     obj in seq; set ValueError and return -1 if none found;
     also return -1 on error.
   PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on
     error. */
__declspec(dllimport) Py_ssize_t _PySequence_IterSearch(PyObject *seq,
                                              PyObject *obj, int operation);



/* For DLL-level backwards compatibility */

/* Determine if the sequence 'o' contains 'value'. If an item in 'o' is equal
   to 'value', return 1, otherwise return 0. On error, return -1.

   This is equivalent to the Python expression: value in o. */
__declspec(dllimport) int PySequence_In(PyObject *o, PyObject *value);

/* For source-level backwards compatibility */



/* Return the first index for which o[i] == value.
   On error, return -1.

   This is equivalent to the Python expression: o.index(value). */
__declspec(dllimport) Py_ssize_t PySequence_Index(PyObject *o, PyObject *value);


/* --- In-place versions of some of the above Sequence functions --- */

/* Append sequence 'o2' to sequence 'o1', in-place when possible. Return the
   resulting object, which could be 'o1', or NULL on failure.

  This is the equivalent of the Python expression: o1 += o2. */
__declspec(dllimport) PyObject * PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);

/* Repeat sequence 'o' by 'count', in-place when possible. Return the resulting
   object, which could be 'o', or NULL on failure.

   This is the equivalent of the Python expression: o1 *= count.  */
__declspec(dllimport) PyObject * PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);


/* === Mapping protocol ================================================= */

/* Return 1 if the object provides mapping protocol, and 0 otherwise.

   This function always succeeds. */
__declspec(dllimport) int PyMapping_Check(PyObject *o);

/* Returns the number of keys in mapping object 'o' on success, and -1 on
  failure. This is equivalent to the Python expression: len(o). */
__declspec(dllimport) Py_ssize_t PyMapping_Size(PyObject *o);

/* For DLL compatibility */

__declspec(dllimport) Py_ssize_t PyMapping_Length(PyObject *o);



/* Implemented as a macro:

   int PyMapping_DelItemString(PyObject *o, const char *key);

   Remove the mapping for the string 'key' from the mapping 'o'. Returns -1 on
   failure.

   This is equivalent to the Python statement: del o[key]. */


/* Implemented as a macro:

   int PyMapping_DelItem(PyObject *o, PyObject *key);

   Remove the mapping for the object 'key' from the mapping object 'o'.
   Returns -1 on failure.

   This is equivalent to the Python statement: del o[key]. */


/* On success, return 1 if the mapping object 'o' has the key 'key',
   and 0 otherwise.

   This is equivalent to the Python expression: key in o.

   This function always succeeds. */
__declspec(dllimport) int PyMapping_HasKeyString(PyObject *o, const char *key);

/* Return 1 if the mapping object has the key 'key', and 0 otherwise.

   This is equivalent to the Python expression: key in o.

   This function always succeeds. */
__declspec(dllimport) int PyMapping_HasKey(PyObject *o, PyObject *key);

/* On success, return a list or tuple of the keys in mapping object 'o'.
   On failure, return NULL. */
__declspec(dllimport) PyObject * PyMapping_Keys(PyObject *o);

/* On success, return a list or tuple of the values in mapping object 'o'.
   On failure, return NULL. */
__declspec(dllimport) PyObject * PyMapping_Values(PyObject *o);

/* On success, return a list or tuple of the items in mapping object 'o',
   where each item is a tuple containing a key-value pair. On failure, return
   NULL. */
__declspec(dllimport) PyObject * PyMapping_Items(PyObject *o);

/* Return element of 'o' corresponding to the string 'key' or NULL on failure.

   This is the equivalent of the Python expression: o[key]. */
__declspec(dllimport) PyObject * PyMapping_GetItemString(PyObject *o,
                                               const char *key);

/* Map the string 'key' to the value 'v' in the mapping 'o'.
   Returns -1 on failure.

   This is the equivalent of the Python statement: o[key]=v. */
__declspec(dllimport) int PyMapping_SetItemString(PyObject *o, const char *key,
                                        PyObject *value);

/* isinstance(object, typeorclass) */
__declspec(dllimport) int PyObject_IsInstance(PyObject *object, PyObject *typeorclass);

/* issubclass(object, typeorclass) */
__declspec(dllimport) int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);



__declspec(dllimport) int _PyObject_RealIsInstance(PyObject *inst, PyObject *cls);

__declspec(dllimport) int _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls);

__declspec(dllimport) char *const * _PySequence_BytesToCharpArray(PyObject* self);

__declspec(dllimport) void _Py_FreeCharPArray(char *const array[]);

/* For internal use by buffer API functions */
__declspec(dllimport) void _Py_add_one_to_index_F(int nd, Py_ssize_t *index,
                                        const Py_ssize_t *shape);
__declspec(dllimport) void _Py_add_one_to_index_C(int nd, Py_ssize_t *index,
                                        const Py_ssize_t *shape);

/* Convert Python int to Py_ssize_t. Do nothing if the argument is None. */
__declspec(dllimport) int _Py_convert_optional_to_ssize_t(PyObject *, void *);















extern __declspec(dllimport) PyTypeObject PyFilter_Type;
extern __declspec(dllimport) PyTypeObject PyMap_Type;
extern __declspec(dllimport) PyTypeObject PyZip_Type;









/* Interface to execute compiled code */







__declspec(dllimport) PyObject * PyEval_EvalCode(PyObject *, PyObject *, PyObject *);

__declspec(dllimport) PyObject * PyEval_EvalCodeEx(PyObject *co,
                                         PyObject *globals,
                                         PyObject *locals,
                                         PyObject *const *args, int argc,
                                         PyObject *const *kwds, int kwdc,
                                         PyObject *const *defs, int defc,
                                         PyObject *kwdefs, PyObject *closure);


__declspec(dllimport) PyObject * _PyEval_EvalCodeWithName(
    PyObject *co,
    PyObject *globals, PyObject *locals,
    PyObject *const *args, Py_ssize_t argcount,
    PyObject *const *kwnames, PyObject *const *kwargs,
    Py_ssize_t kwcount, int kwstep,
    PyObject *const *defs, Py_ssize_t defcount,
    PyObject *kwdefs, PyObject *closure,
    PyObject *name, PyObject *qualname);

__declspec(dllimport) PyObject * _PyEval_CallTracing(PyObject *func, PyObject *args);





















extern __declspec(dllimport) const unsigned int _Py_ctype_table[256];

/* Unlike their C counterparts, the following macros are not meant to
 * handle an int with any of the values [EOF, 0-UCHAR_MAX]. The argument
 * must be a signed/unsigned char. */








extern __declspec(dllimport) const unsigned char _Py_ctype_tolower[256];
extern __declspec(dllimport) const unsigned char _Py_ctype_toupper[256];
















__declspec(dllimport) double PyOS_string_to_double(const char *str,
                                         char **endptr,
                                         PyObject *overflow_exception);

/* The caller is responsible for calling PyMem_Free to free the buffer
   that's is returned. */
__declspec(dllimport) char * PyOS_double_to_string(double val,
                                         char format_code,
                                         int precision,
                                         int flags,
                                         int *type);


__declspec(dllimport) PyObject * _Py_string_to_number_with_underscores(
    const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg,
    PyObject *(*innerfunc)(const char *, Py_ssize_t, void *));

__declspec(dllimport) double _Py_parse_inf_or_nan(const char *p, char **endptr);



/* PyOS_double_to_string's "flags" parameter can be set to 0 or more of: */





/* PyOS_double_to_string's "type", if non-NULL, will be set to one of: */


















__declspec(dllimport) int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t);
__declspec(dllimport) int PyOS_mystricmp(const char *, const char *);






















__declspec(dllimport) double _Py_dg_strtod(const char *str, char **ptr);
__declspec(dllimport) char * _Py_dg_dtoa(double d, int mode, int ndigits,
                        int *decpt, int *sign, char **rve);
__declspec(dllimport) void _Py_dg_freedtoa(char *s);
__declspec(dllimport) double _Py_dg_stdnan(int sign);
__declspec(dllimport) double _Py_dg_infinity(int sign);

















__declspec(dllimport) wchar_t * Py_DecodeLocale(
    const char *arg,
    size_t *size);

__declspec(dllimport) char* Py_EncodeLocale(
    const wchar_t *text,
    size_t *error_pos);

__declspec(dllimport) char* _Py_EncodeLocaleRaw(
    const wchar_t *text,
    size_t *error_pos);









































__declspec(dllimport) PyObject * _Py_device_encoding(int);


struct _Py_stat_struct {
    unsigned long st_dev;
    uint64_t st_ino;
    unsigned short st_mode;
    int st_nlink;
    int st_uid;
    int st_gid;
    unsigned long st_rdev;
    __int64 st_size;
    time_t st_atime;
    int st_atime_nsec;
    time_t st_mtime;
    int st_mtime_nsec;
    time_t st_ctime;
    int st_ctime_nsec;
    unsigned long st_file_attributes;
};




__declspec(dllimport) int _Py_fstat(
    int fd,
    struct _Py_stat_struct *status);

__declspec(dllimport) int _Py_fstat_noraise(
    int fd,
    struct _Py_stat_struct *status);

__declspec(dllimport) int _Py_stat(
    PyObject *path,
    struct stat *status);

__declspec(dllimport) int _Py_open(
    const char *pathname,
    int flags);

__declspec(dllimport) int _Py_open_noraise(
    const char *pathname,
    int flags);

__declspec(dllimport) FILE * _Py_wfopen(
    const wchar_t *path,
    const wchar_t *mode);

__declspec(dllimport) FILE* _Py_fopen(
    const char *pathname,
    const char *mode);

__declspec(dllimport) FILE* _Py_fopen_obj(
    PyObject *path,
    const char *mode);

__declspec(dllimport) Py_ssize_t _Py_read(
    int fd,
    void *buf,
    size_t count);

__declspec(dllimport) Py_ssize_t _Py_write(
    int fd,
    const void *buf,
    size_t count);

__declspec(dllimport) Py_ssize_t _Py_write_noraise(
    int fd,
    const void *buf,
    size_t count);















__declspec(dllimport) wchar_t* _Py_wgetcwd(
    wchar_t *buf,
    size_t size);

__declspec(dllimport) int _Py_get_inheritable(int fd);

__declspec(dllimport) int _Py_set_inheritable(int fd, int inheritable,
                                    int *atomic_flag_works);

__declspec(dllimport) int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               int *atomic_flag_works);

__declspec(dllimport) int _Py_dup(int fd);







__declspec(dllimport) int _Py_GetLocaleconvNumeric(
    PyObject **decimal_point,
    PyObject **thousands_sep,
    const char **grouping);













/* These macros used to do something when Python was built with --with-fpectl,
 * but support for that was dropped in 3.7. We continue to define them though,
 * to avoid breaking API users.
 */











/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */


/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */








/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/









/*  Generic buffer size */




/* Flags for pointer conversions */




/* Flags for new pointer objects */



/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/






/* The CastRankLimit says how many bits are used for the cast rank */

/* The NewMask denotes the object was created (using new/malloc) */

/* The TmpMask is for in/out typemaps that use temporal objects */

/* Simple returning values */




/* Check, add and del mask methods */







/* Cast-Rank Mode */



























typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
static  int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
static  int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
static  int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
static  swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
static  swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
static   void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
static  swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
static   const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
static  const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return ((void *)0);
  if (type->str != ((void *)0)) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
static  void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
static  void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
static  swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
static  swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
static  char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
static  const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
static  char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

static  const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

static  char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

static  const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}





/*  Errors in SWIG */
















/* Compatibility macros for Python 3 */























/* SWIG APIs for compatibility of both Python 2 & 3 */








/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
static  char*
SWIG_Python_str_AsChar(PyObject *str)
{

  char *newstr = 0;
  str = PyUnicode_AsUTF8String(str);
  if (str) {
    char *cstr;
    Py_ssize_t len;
    PyBytes_AsStringAndSize(str, &cstr, &len);
    newstr = (char *) malloc(len+1);
    memcpy(newstr, cstr, len+1);
    do { PyObject *_py_xdecref_tmp = (PyObject *)(str); if (_py_xdecref_tmp != ((void *)0)) do { PyObject *_py_decref_tmp = (PyObject *)(_py_xdecref_tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0); } while (0);
  }
  return newstr;



}








static  PyObject*
SWIG_Python_str_FromChar(const char *c)
{

  return PyUnicode_FromString(c); 



}





// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
// interface files check for it.









/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

static  PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case -12:
    type = PyExc_MemoryError;
    break;
  case -2:
    type = PyExc_IOError;
    break;
  case -3:
    type = PyExc_RuntimeError;
    break;
  case -4:
    type = PyExc_IndexError;
    break;
  case -5:
    type = PyExc_TypeError;
    break;
  case -6:
    type = PyExc_ZeroDivisionError;
    break;
  case -7:
    type = PyExc_OverflowError;
    break;
  case -8:
    type = PyExc_SyntaxError;
    break;
  case -9:
    type = PyExc_ValueError;
    break;
  case -10:
    type = PyExc_SystemError;
    break;
  case -11:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


static  void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred())
    PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    PyObject *old_str = PyObject_Str(value);
    const char *tmp = SWIG_Python_str_AsChar(old_str);
    PyErr_Clear();
    do { PyObject *_py_xincref_tmp = (PyObject *)(type); if (_py_xincref_tmp != ((void *)0)) (   ((PyObject *)(_py_xincref_tmp))->ob_refcnt++); } while (0);
    if (tmp)
      PyErr_Format(type, "%s %s", tmp, mesg);
    else
      PyErr_Format(type, "%s", mesg);
    free( (void*) (tmp) );
    do { PyObject *_py_decref_tmp = (PyObject *)(old_str); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    do { PyObject *_py_decref_tmp = (PyObject *)(value); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

static  int
SWIG_Python_TypeErrorOccurred(PyObject *obj)
{
  PyObject *error;
  if (obj)
    return 0;
  error = PyErr_Occurred();
  return error && PyErr_GivenExceptionMatches(error, PyExc_TypeError);
}

static  void
SWIG_Python_RaiseOrModifyTypeError(const char *message)
{
  if (SWIG_Python_TypeErrorOccurred(((void *)0))) {
    /* Use existing TypeError to preserve stacktrace and enhance with given message */
    PyObject *newvalue;
    PyObject *type = ((void *)0), *value = ((void *)0), *traceback = ((void *)0);
    PyErr_Fetch(&type, &value, &traceback);

    newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);



    do { PyObject *_py_xdecref_tmp = (PyObject *)(value); if (_py_xdecref_tmp != ((void *)0)) do { PyObject *_py_decref_tmp = (PyObject *)(_py_xdecref_tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0); } while (0);
    PyErr_Restore(type, newvalue, traceback);
  } else {
    /* Raise TypeError using given message */
    PyErr_SetString(PyExc_TypeError, message);
  }
}


































































/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */





/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */



/* Constant information structure */
typedef struct swig_const_info {
  int type;
  const char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;






/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */









/* Common SWIG API */

/* for raw pointers */
















/* for raw packed data */



/* for class or struct pointers */



/* for C or C++ function pointers */



/* for C++ member pointers, ie, member methods */




/* Runtime API */












/* Runtime API implementation */

/* Error manipulation */

static  void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  ; 
  PyErr_SetObject(errtype, obj);
  do { PyObject *_py_decref_tmp = (PyObject *)(obj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
  ;
}

static  void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  ;
  PyErr_SetString(errtype, msg);
  ;
}



/* Set a constant value */




















static  void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  do { PyObject *_py_decref_tmp = (PyObject *)(obj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);                            
}



/* Append a value to the result obj */

static  PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
  if (!result) {
    result = obj;
  } else if (result == (&_Py_NoneStruct)) {
    do { PyObject *_py_decref_tmp = (PyObject *)(result); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    result = obj;
  } else {
    if (!((((((PyObject*)(result))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    do { PyObject *_py_decref_tmp = (PyObject *)(obj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
  }
  return result;
}

/* Unpack the argument tuple */

static  Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!((((((PyObject*)(args))->ob_type))->tp_flags & ((1UL << 26))) != 0)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = ((void)( (!!(((((((PyObject*)(args))->ob_type))->tp_flags & ((1UL << 26))) != 0))) || (_wassert(L"PyTuple_Check(args)", L".\\trch-1_wrap.c", (unsigned)(1200)), 0) ),(((PyVarObject*)(args))->ob_size));
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = (((PyTupleObject *)(args))->ob_item[i]);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */


/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/






/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */












/* The python void return value */

static   PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = (&_Py_NoneStruct);
  (   ((PyObject *)(none))->ob_refcnt++);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

static   int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  int fail = data ? data->implicitconv : 0;
  if (fail)
    PyErr_SetString(PyExc_TypeError, "Implicit conversion is prohibited for explicit constructors.");
  return fail;
}

static   PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


static  SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    (   ((PyObject *)(data->klass))->ob_refcnt++);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyObject_IsInstance(obj, (PyObject *)&PyType_Type)) {
      data->newraw = 0;
      data->newargs = obj;
      (   ((PyObject *)(obj))->ob_refcnt++);
    } else {
      data->newraw = PyObject_GetAttrString(data->klass, "__new__");
      if (data->newraw) {
	(   ((PyObject *)(data->newraw))->ob_refcnt++);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      (   ((PyObject *)(data->newargs))->ob_refcnt++);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      (   ((PyObject *)(data->destroy))->ob_refcnt++);
      flags = (((PyCFunctionObject *)data->destroy) -> m_ml -> ml_flags);
      data->delargs = !(flags & (0x0008));
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

static  void 
SwigPyClientData_Del(SwigPyClientData *data) {
  do { PyObject *_py_xdecref_tmp = (PyObject *)(data->newraw); if (_py_xdecref_tmp != ((void *)0)) do { PyObject *_py_decref_tmp = (PyObject *)(_py_xdecref_tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0); } while (0);
  do { PyObject *_py_xdecref_tmp = (PyObject *)(data->newargs); if (_py_xdecref_tmp != ((void *)0)) do { PyObject *_py_decref_tmp = (PyObject *)(_py_xdecref_tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0); } while (0);
  do { PyObject *_py_xdecref_tmp = (PyObject *)(data->destroy); if (_py_xdecref_tmp != ((void *)0)) do { PyObject *_py_decref_tmp = (PyObject *)(_py_xdecref_tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0); } while (0);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject ob_base;
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;



} SwigPyObject;


















static  PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

static  PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = ((void *)0);
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {

	res = PyUnicode_Format(ofmt,args);



	do { PyObject *_py_decref_tmp = (PyObject *)(ofmt); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
      }
      do { PyObject *_py_decref_tmp = (PyObject *)(args); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    }
  }
  return res;
}

static  PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

static  PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

static  PyObject *
SwigPyObject_repr(SwigPyObject *v)
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = PyUnicode_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);

    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;



  }
  return repr;  
}

/* We need a version taking two PyObject* parameters so it's a valid
 * PyCFunction to use in swigobject_methods[]. */
static  PyObject *
SwigPyObject_repr2(PyObject *v, PyObject *args )
{
  return SwigPyObject_repr((SwigPyObject*)v);
}

static  int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
static  PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != 2 && op != 3 ) {
    (   ((PyObject *)((&_Py_NotImplementedStruct)))->ob_refcnt++);
    return (&_Py_NotImplementedStruct);
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == 2) ? 1 : 0);
  return res;  
}


static  PyTypeObject* SwigPyObject_TypeOnce(void);













static  PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *type = 0; if (!type) type = SwigPyObject_TypeOnce();
  return type;
}


static   int
SwigPyObject_Check(PyObject *op) {






  return ((((PyObject*)(op))->ob_type) == SwigPyObject_type())
    || (strcmp((((PyObject*)(op))->ob_type)->tp_name,"SwigPyObject") == 0);

}

static  PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

static  void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == 0x1) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *type = ((void *)0), *value = ((void *)0), *traceback = ((void *)0);
      PyErr_Fetch(&type, &value, &traceback);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = PyObject_CallFunctionObjArgs(destroy, tmp, ((void *)0));;
        do { PyObject *_py_decref_tmp = (PyObject *)(tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
      } else {
        PyCFunction meth = (((PyCFunctionObject *)destroy) -> m_ml -> ml_meth);
        PyObject *mself = (((PyCFunctionObject *)destroy) -> m_ml -> ml_flags & 0x0020 ? ((void *)0) : ((PyCFunctionObject *)destroy) -> m_self);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(type, value, traceback);

      do { PyObject *_py_xdecref_tmp = (PyObject *)(res); if (_py_xdecref_tmp != ((void *)0)) do { PyObject *_py_decref_tmp = (PyObject *)(_py_xdecref_tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0); } while (0);
    } 

    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }

  } 
  do { PyObject *_py_xdecref_tmp = (PyObject *)(next); if (_py_xdecref_tmp != ((void *)0)) do { PyObject *_py_decref_tmp = (PyObject *)(_py_xdecref_tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0); } while (0);
  PyObject_Free(v);
}

static  PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return ((void *)0);
  }
  sobj->next = next;
  (   ((PyObject *)(next))->ob_refcnt++);
  return SWIG_Py_Void();
}

static  PyObject* 
SwigPyObject_next(PyObject* v, PyObject *args )
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    (   ((PyObject *)(sobj->next))->ob_refcnt++);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

static  PyObject*
SwigPyObject_disown(PyObject* v, PyObject *args )
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

static  PyObject*
SwigPyObject_acquire(PyObject* v, PyObject *args )
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0x1;
  return SWIG_Py_Void();
}

static  PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
    return ((void *)0);
  } else {
    SwigPyObject *sobj = (SwigPyObject *)v;
    PyObject *obj = PyBool_FromLong(sobj->own);
    if (val) {
      if (PyObject_IsTrue(val)) {
        SwigPyObject_acquire(v,args);
      } else {
        SwigPyObject_disown(v,args);
      }
    } 
    return obj;
  }
}

static PyMethodDef
swigobject_methods[] = {
  {"disown",  SwigPyObject_disown,  0x0004,  "releases ownership of the pointer"},
  {"acquire", SwigPyObject_acquire, 0x0004,  "acquires ownership of the pointer"},
  {"own",     SwigPyObject_own,     0x0001, "returns/sets ownership of the pointer"},
  {"append",  SwigPyObject_append,  0x0008,       "appends another 'this' object"},
  {"next",    SwigPyObject_next,    0x0004,  "returns the next 'this' object"},
  {"__repr__",SwigPyObject_repr2,   0x0004,  "returns object representation"},
  {0, 0, 0, 0}  
};

static  PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */



    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/



    (unaryfunc)SwigPyObject_long, /*nb_int*/



    0, /*nb_reserved*/

    (unaryfunc)0,                 /*nb_float*/





    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */





  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {

      { {  1, ((void *)0) }, 0 },




      "SwigPyObject",                       /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */

      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */



      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      ( 0 | (1UL << 18) | 0),                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */

      0,                                    /* tp_finalize */








    };
    swigpyobject_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpyobject_type) < 0)
      return ((void *)0);
  }
  return &swigpyobject_type;
}

static  PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = ( (SwigPyObject *) PyObject_Init( (PyObject *) PyObject_Malloc( ( (SwigPyObject_type())->tp_basicsize ) ), (SwigPyObject_type())) );
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject ob_base;
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

static  PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[1024];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return PyUnicode_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return PyUnicode_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

static  PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[1024];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return PyUnicode_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

static  int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((const char *)v->pack, (const char *)w->pack, 2*v->size);
}

static  PyTypeObject* SwigPyPacked_TypeOnce(void);

static  PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *type = 0; if (!type) type = SwigPyPacked_TypeOnce();
  return type;
}

static   int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

static  void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_Free(v);
}

static  PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {

      { {  1, ((void *)0) }, 0 },




      "SwigPyPacked",                       /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */

      0, /* tp_reserved in 3.0.1 */



      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      ( 0 | (1UL << 18) | 0),                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */

      0,                                    /* tp_finalize */








    };
    swigpypacked_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpypacked_type) < 0)
      return ((void *)0);
  }
  return &swigpypacked_type;
}

static  PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = ( (SwigPyPacked *) PyObject_Init( (PyObject *) PyObject_Malloc( ( (SwigPyPacked_type())->tp_basicsize ) ), (SwigPyPacked_type())) );
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_Free((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

static  swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

static PyObject *Swig_This_global = ((void *)0);

static  PyObject *
SWIG_This(void)
{
  if (Swig_This_global == ((void *)0))
    Swig_This_global = SWIG_Python_str_FromChar("this");
  return Swig_This_global;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */




static  SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;













  obj = 0;


























  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    do { PyObject *_py_decref_tmp = (PyObject *)(obj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }

  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;

}

/* Acquire a pointer value */

static  int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == 0x1) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

static  int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & (0x1 << 1)) != 0;

  if (!obj)
    return (-1);
  if (obj == (&_Py_NoneStruct) && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return (flags & 0x4) ? -13 : (0);
  }

  res = (-1);

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == 0x2) {
              (void)( (!!(own)) || (_wassert(L"own", L".\\trch-1_wrap.c", (unsigned)(2082)), 0) ); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | 0x2;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & 0x1) {
      sobj->own = 0;
    }
    res = (0);
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = PyObject_CallFunctionObjArgs(klass, obj, ((void *)0));;
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if ((res >= 0)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = (res);
                  res = ((res >= 0) ? (res | ((1 << 8) << 1)) : res);
                } else {
                  res = (res);		    
                }
              }
            }
            do { PyObject *_py_decref_tmp = (PyObject *)(impconv); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
          }
        }
      }
      if (!(res >= 0) && obj == (&_Py_NoneStruct)) {
        if (ptr)
          *ptr = 0;
        if (PyErr_Occurred())
          PyErr_Clear();
        res = (0);
      }
    }
  }
  return res;
}

/* Convert a function ptr value */

static  int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!((((PyObject*)(obj))->ob_type) == &PyCFunction_Type)) {
    return SWIG_Python_ConvertPtrAndOwn(obj, ptr, ty, 0, 0);
  } else {
    void *vptr = 0;
    swig_cast_info *tc;

    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc)
      return (-1);
    tc = SWIG_TypeCheck(desc,ty);
    if (tc) {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
      (void)( (!!(!newmemory)) || (_wassert(L"!newmemory", L".\\trch-1_wrap.c", (unsigned)(2170)), 0) ); /* newmemory handling not yet implemented */
    } else {
      return (-1);
    }
    return (0);
  }
}

/* Convert a packed pointer value */

static  int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return (-1);
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return (-1);
    }
  }
  return (0);
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

static  PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, ((void *)0));
    if (inst) {











      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);

    }
  } else {

    PyObject *empty_args = PyTuple_New(0);
    if (empty_args) {
      PyObject *empty_kwargs = PyDict_New();
      if (empty_kwargs) {
        inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
        do { PyObject *_py_decref_tmp = (PyObject *)(empty_kwargs); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
        if (inst) {
          PyObject_SetAttr(inst, SWIG_This(), swig_this);
          (((PyObject*)(inst))->ob_type)->tp_flags &= ~(1UL << 19);
        }
      }
      do { PyObject *_py_decref_tmp = (PyObject *)(empty_args); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    }








  }
  return inst;
}

static  void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;












 dict = PyObject_GetAttrString(inst, "__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 do { PyObject *_py_decref_tmp = (PyObject *)(dict); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
} 


static  PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return ((void *)0);
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

static  PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & 0x1) ? 0x1 : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & (0x1 << 2)) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;



      }
    } else {
      newobj = ( (SwigPyObject *) _PyObject_New(clientdata->pytype) );



    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  (void)( (!!(!(flags & (0x1 << 2)))) || (_wassert(L"!(flags & SWIG_BUILTIN_TP_INIT)", L".\\trch-1_wrap.c", (unsigned)(2334)), 0) );

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & (0x1 << 1))) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    do { PyObject *_py_decref_tmp = (PyObject *)(robj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

static   PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/





static  swig_module_info *
SWIG_Python_GetModule(void *clientdata ) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {



    type_pointer = PyCapsule_Import(("swig_runtime_data" "4" ".type_pointer_capsule" ), 0);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }

  }
  return (swig_module_info *) type_pointer;
}

static  void
SWIG_Python_DestroyModule(PyObject *obj)
{
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, ("swig_runtime_data" "4" ".type_pointer_capsule" ));
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  do { PyObject *_py_decref_tmp = (PyObject *)(SWIG_This()); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
  Swig_This_global = ((void *)0);
}

static  void
SWIG_Python_SetModule(swig_module_info *swig_module) {

 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule("swig_runtime_data" "4");




  PyObject *pointer = PyCapsule_New((void *) swig_module, ("swig_runtime_data" "4" ".type_pointer_capsule" ), SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, "type_pointer_capsule" , pointer);
  } else {
    do { PyObject *_py_xdecref_tmp = (PyObject *)(pointer); if (_py_xdecref_tmp != ((void *)0)) do { PyObject *_py_decref_tmp = (PyObject *)(_py_xdecref_tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0); } while (0);
  }
}

/* The python cached type query */
static  PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *cache = 0; if (!cache) cache = PyDict_New();
  return cache;
}

static  swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, ((void *)0));
  } else {
    swig_module_info *swig_module = SWIG_Python_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCapsule_New((void*) descriptor, ((void *)0), ((void *)0));
      PyDict_SetItem(cache, key, obj);
      do { PyObject *_py_decref_tmp = (PyObject *)(obj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    }
  }
  do { PyObject *_py_decref_tmp = (PyObject *)(key); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
  return descriptor;
}

/* 
   For backward compatibility only
*/




static  int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      PyObject *old_str = PyObject_Str(value);
      const char *tmp = SWIG_Python_str_AsChar(old_str);
      const char *errmesg = tmp ? tmp : "Invalid error message";
      do { PyObject *_py_xincref_tmp = (PyObject *)(type); if (_py_xincref_tmp != ((void *)0)) (   ((PyObject *)(_py_xincref_tmp))->ob_refcnt++); } while (0);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, errmesg);
      } else {
	PyErr_Format(type, "%s %s", errmesg, mesg);
      }
      free( (void*) (tmp) );
      do { PyObject *_py_decref_tmp = (PyObject *)(old_str); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    }
    return 1;
  } else {
    return 0;
  }
}
  
static  int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

static   const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

static  void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {










    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          free( (void*) (cstr) );
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	do { PyObject *_py_xdecref_tmp = (PyObject *)(str); if (_py_xdecref_tmp != ((void *)0)) do { PyObject *_py_decref_tmp = (PyObject *)(_py_xdecref_tmp); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0); } while (0);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
static  void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum , int flags) {
  void *result;
  if (SWIG_Python_ConvertPtrAndOwn(obj, &result, ty, flags, 0) == -1) {
    PyErr_Clear();






  }
  return result;
}









































































/* Method creation and docstring support functions */

static  PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
static  PyObject *SWIG_PyInstanceMethod_New(PyObject *self , PyObject *func);
static  PyObject *SWIG_PyStaticMethod_New(PyObject *self , PyObject *func);






/* -------- TYPES TABLE (BEGIN) -------- */



























static swig_type_info *swig_types[27];
static swig_module_info swig_module = {swig_types, 26, 0, 0, 0, 0};



/* -------- TYPES TABLE (END) -------- */






/*-----------------------------------------------
              @(target):= _pytrch.so
  ------------------------------------------------*/



















typedef void* TcLogger;
struct Config_struct
{
    uint8_t tmp[0x48];
};
struct Params_struct
{
    uint8_t tmp[0x38];
};
struct Paramchoice_struct
{
    uint8_t tmp[0x48];
};
struct Paramgroup_struct
{
    uint8_t tmp[0x40];
};
struct Parameter_struct
{
    uint8_t tmp[0x80];
};



//
// stdbool.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdbool.h> header.
//















typedef uint64_t _QWORD;
typedef uint32_t _DWORD;
typedef uint16_t _WORD;
typedef uint8_t _BYTE;
typedef uint8_t _BOOL8;
typedef struct Config_struct* Config;
typedef struct Params_struct* Params;
typedef struct Paramchoice_struct* Paramchoice;
typedef struct Paramgroup_struct* Paramgroup;
typedef struct Parameter_struct* Parameter;



typedef char* MarshalledValue;
typedef long long posh_i64_t;
typedef unsigned long long posh_u64_t;
// x64

typedef unsigned long long SOCKET;




MarshalledValue Boolean_List_marshal(size_t listSize, int *list); // ok
MarshalledValue Boolean_marshal(int); // ok
char *Boolean_type(); // ok
MarshalledValue Buffer_List_marshal(size_t listSize, unsigned char **ucharPtrList, size_t *ucharPtrSizeList); // ok
MarshalledValue Buffer_marshal(unsigned char *ucharPtr, size_t ucharSize); // ok
char *Buffer_type(); // ok
Config Config_create(char *, char *, char *, char *, char *, char *); // ok
void Config_delete(Config self); // ok
Config Config_duplicate(Config self); // ok
char* Config_getConfigVersion(Config self); // ok
int Config_getConstants(Config self, Params *); // wait test
char *Config_getID(Config self); // ok
int Config_getInputParams(Config self, Params *outParams); // ok
char *Config_getName(Config self); // ok
char* Config_getNamespaceUri(Config self); // ok
signed int Config_getOutputParams(Config self, Params *outParams); // ok
char* Config_getSchemaVersion(Config self); // ok
char* Config_getVersion(Config self); // ok
MarshalledValue Config_marshal(Config self, char *, char *); // ok
void Config_printUsage(Config self, char*, TcLogger, int); // wait test
int Config_setConstants(Config self, Params); // wait test
int Config_setInputParams(Config self, Params); // wait test
int Config_setOutputParams(Config self, Params); // wait test
Config Config_unmarshal(char *str); // ok
void FinalizeXMLUnmarshal(); // ok
MarshalledValue IPv4_List_marshal(size_t listSize, char **charPtrList); // ok
MarshalledValue IPv4_marshal(char *); // ok
char *IPv4_type(); // ok
MarshalledValue IPv6_List_marshal(size_t listSize, char **charPtrList); // ok
MarshalledValue IPv6_marshal(char *); // ok
char *IPv6_type(); // ok
void InitializeXMLUnmarshal(); // ok
char *List_format(); // ok
MarshalledValue LocalFile_List_marshal(size_t listSize, char **charPtrList); // ok
MarshalledValue LocalFile_marshal(char *); // ok
char *LocalFile_type(); // ok
int Paramchoice_addParamgroup(Paramchoice self, Paramgroup); // wait test
Paramchoice Paramchoice_create(char *, char *, char *, char *, char*); // wait test
void Paramchoice_delete(Paramchoice self); // wait test
int Paramchoice_getDefaultValue(Paramchoice self, char **outCharPtr); // wait test
int Paramchoice_getDescription(Paramchoice self, char **outCharPtr); // wait test
int Paramchoice_getName(Paramchoice self, char **outCharPtr); // wait test
unsigned int Paramchoice_getNumParamgroups(Paramchoice self); // wait test
Paramgroup Paramchoice_getParamgroup(Paramchoice self, size_t); // wait test
char* Paramchoice_getValue(Paramchoice self, char **outCharPtr); // wait test
int Paramchoice_hasValidValue(Paramchoice self); // wait test
int Paramchoice_hasValue(Paramchoice self); // wait test
int Paramchoice_isValid(Paramchoice self);// wait test
int Paramchoice_matchName(Paramchoice self, char*); // wait test
int Paramchoice_setValue(Paramchoice self, char*); // wait test
__int64 Parameter_Boolean_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_Boolean_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_Boolean_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_Boolean_List_setValue(int a1);
__int64 Parameter_Boolean_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_Boolean_getValue(Parameter self, __int64 a2);
__int64 Parameter_Boolean_setValue(__int64 a1, unsigned int a2);
__int64 Parameter_Buffer_List_create(char *Source, char *a2, int a3, int a4, char *Str2, __int64 a6);
__int64 Parameter_Buffer_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_Buffer_List_getValue(__int64 a1);
__int64 Parameter_Buffer_List_setValue(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 Parameter_Buffer_create(char *Source, char *a2, int a3, int a4, char *Str2, __int64 a6);
__int64 Parameter_Buffer_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_Buffer_setValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_IPv4_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_IPv4_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_IPv4_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_IPv4_List_setValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_IPv4_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_IPv4_getValue(__int64 a1, __int64 a2);
__int64 Parameter_IPv4_setValue(__int64 a1, __int64 a2);
__int64 Parameter_IPv6_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_IPv6_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_IPv6_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_IPv6_List_setValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_IPv6_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_IPv6_getValue(__int64 a1, __int64 a2);
__int64 Parameter_IPv6_setValue(__int64 a1, __int64 a2);
__int64 Parameter_LocalFile_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_LocalFile_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_LocalFile_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_LocalFile_List_setValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_LocalFile_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_LocalFile_getValue(__int64 a1, __int64 a2);
__int64 Parameter_LocalFile_setValue(__int64 a1, __int64 a2);
__int64 Parameter_Port_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_Port_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_Port_List_setValue(int a1);
__int64 Parameter_Port_getValue(__int64 a1, __int64 a2);
__int64 Parameter_Port_setValue(__int64 a1, unsigned __int16 a2);
__int64 Parameter_S16_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_S16_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_S16_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_S16_List_setValue(int a1);
__int64 Parameter_S16_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_S16_getValue(__int64 a1, __int64 a2);
__int64 Parameter_S16_setValue(__int64 a1, unsigned __int16 a2);
__int64 Parameter_S32_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_S32_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_S32_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_S32_List_setValue(int a1);
__int64 Parameter_S32_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_S32_getValue(__int64 a1, __int64 a2);
__int64 Parameter_S32_setValue(__int64 a1, unsigned int a2);
__int64 Parameter_S64_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_S64_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_S64_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_S64_List_setValue(int a1);
__int64 Parameter_S64_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_S64_getValue(__int64 a1, __int64 a2);
__int64 Parameter_S64_setValue(__int64 a1, __int64 a2);
__int64 Parameter_S8_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_S8_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_S8_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_S8_List_setValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_S8_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_S8_getValue(__int64 a1, __int64 a2);
__int64 Parameter_S8_setValue(__int64 a1, char a2, __int64 a3);
__int64 Parameter_Socket_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_Socket_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_Socket_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_Socket_List_setValue(int a1);
__int64 Parameter_Socket_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_Socket_getValue(__int64 a1, __int64 a2);
__int64 Parameter_Socket_setValue(__int64 a1, __int64 a2);
__int64 Parameter_String_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_String_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_String_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_String_List_setValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_String_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_String_getValue(__int64 a1, __int64 a2);
__int64 Parameter_String_setValue(__int64 a1, __int64 a2);
__int64 Parameter_TcpPort_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_TcpPort_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_U16_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_U16_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_U16_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_U16_List_setValue(int a1);
__int64 Parameter_U16_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_U16_getValue(__int64 a1, __int64 a2);
__int64 Parameter_U16_setValue(__int64 a1, unsigned __int16 a2);
__int64 Parameter_U32_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_U32_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_U32_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_U32_List_setValue(int a1);
__int64 Parameter_U32_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_U32_getValue(__int64 a1, __int64 a2);
__int64 Parameter_U32_setValue(__int64 a1, unsigned int a2);
__int64 Parameter_U64_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_U64_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_U64_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_U64_List_setValue(int a1);
__int64 Parameter_U64_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_U64_getValue(__int64 a1, __int64 a2);
__int64 Parameter_U64_setValue(__int64 a1, __int64 a2);
__int64 Parameter_U8_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_U8_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_U8_List_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_U8_List_setValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_U8_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_U8_getValue(__int64 a1, __int64 a2);
__int64 Parameter_U8_setValue(__int64 a1, char a2, __int64 a3);
__int64 Parameter_UString_List_create(char *Source, char *a2, int a3, int a4, char *Str2, __int64 a6);
__int64 Parameter_UString_List_getSize(__int64 a1, __int64 a2);
__int64 Parameter_UString_List_getValue(__int64 a1);
__int64 Parameter_UString_List_setValue(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 Parameter_UString_create(char *Source, char *a2, int a3, int a4, char *Str2, __int64 a6);
__int64 Parameter_UString_getValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_UString_setValue(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_UdpPort_List_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
__int64 Parameter_UdpPort_create(char *Source, char *a2, int a3, int a4, char *a5, __int64 a6);
void Parameter_delete(__int64 a1);
signed __int64 Parameter_getDescription(__int64 a1, _QWORD *a2);
signed __int64 Parameter_getFormat(__int64 a1, _QWORD *a2);
signed __int64 Parameter_getInvalidReason(__int64 a1, _QWORD *a2);
signed __int64 Parameter_getMarshalledDefault(__int64 a1, _QWORD *a2);
MarshalledValue Parameter_getMarshalledValue(__int64 a1, __int64 a2); // wtf?
signed __int64 Parameter_getName(_QWORD *a1, _QWORD *a2);
signed __int64 Parameter_getType(__int64 a1, _QWORD *a2);
_BOOL8 Parameter_hasValidValue();
_BOOL8 Parameter_hasValue(__int64 a1);
void Parameter_hide(__int64 a1);
_Bool Parameter_isHidden(__int64 a1);
_Bool Parameter_isRequired(__int64 a1);
_BOOL8 Parameter_isValid(__int64 a1, int a2);
void Parameter_markInvalid(__int64 a1);
void Parameter_markInvalidWithReason(__int64 a1, char *a2);
__int64 Parameter_matchFormat(__int64 a1, __int64 a2);
_BOOL8 Parameter_matchFormatAndType(__int64 a1, __int64 a2, __int64 a3);
__int64 Parameter_matchName(_QWORD *a1, __int64 a2);
__int64 Parameter_matchType(__int64 a1, __int64 a2);
__int64 Parameter_resetValue(__int64 a1);
__int64 Parameter_setMarshalledValue(__int64 a1, __int64 a2);
signed __int64 Paramgroup_addParamchoice(__int64 a1, __int64 a2);
signed __int64 Paramgroup_addParameter(__int64 a1, __int64 a2);
_QWORD *Paramgroup_create(char *Source, char *a2, char *a3, char *a4);
void Paramgroup_delete(__int64 a1);
signed __int64 Paramgroup_getDescription(__int64 a1, _QWORD *a2);
signed __int64 Paramgroup_getName(_QWORD *a1, _QWORD *a2);
__int64 Paramgroup_getNumParamchoices(__int64 a1);
__int64 Paramgroup_getNumParameters(__int64 a1);
__int64 Paramgroup_getParamchoice(__int64 a1, unsigned __int64 a2);
__int64 Paramgroup_getParameter(__int64 a1, unsigned __int64 a2);
signed __int64 Paramgroup_isValid(__int64 a1);
__int64 Paramgroup_matchName(_QWORD *a1, __int64 a2);
__int64 Paramgroup_removeParameter(_QWORD *a1, __int64 a2);
int Params_addParamchoice(Params self, Paramchoice); // wait test
int Params_addParameter(Params self, Parameter); // wait test
Params Params_create(char *, char *, char *); // wait test
void Params_delete(Params self); // wait test
Params Params_duplicate(Params self); // wait test
Paramchoice Params_findParamchoice(Params self, char*); // wait test
Parameter Params_findParameter(Params self, char*); // wait test
int Params_getCallbackIPv4Values(Params self, char *, char *, char **, char **); // wait test
int Params_getCallbackIPv6Values(Params self, char *, char *, char **, char **); // wait test
int Params_getCallbackPortValues(Params self, char *, char *, unsigned short *, unsigned short *); // wait test
int Params_getName(Params self, char **outCharPtr); // ok
unsigned int Params_getNumParamchoices(Params self); // wait test
unsigned int Params_getNumParameters(Params self); // wait test
Paramchoice Params_getParamchoice(Params self, size_t); // wait test
Parameter Params_getParameter(Params self, size_t); // wait test
int Params_isValid(Params self); // wait test
int Params_parseCommandLine(Params self, int, char **, int *); // wait test
void Params_printInvalid(Params self, TcLogger); // wait test
void Params_removeParameter(Params self, Parameter); // wait test
int Params_validateCallbackPorts(Params self, char *, char *); // wait test
MarshalledValue Port_List_marshal(size_t listSize, unsigned short *list); // ok
MarshalledValue Port_marshal(unsigned short); // ok
MarshalledValue S16_List_marshal(size_t listSize, short *list); // ok
MarshalledValue S16_marshal(short); // ok
char *S16_type(); // ok
MarshalledValue S32_List_marshal(size_t listSize, int *list); // ok
MarshalledValue S32_marshal(int); // ok
char *S32_type();// ok
MarshalledValue S64_List_marshal(size_t listSize, posh_i64_t *list);
MarshalledValue S64_marshal(posh_i64_t); // ok
char *S64_type();// ok
MarshalledValue S8_List_marshal(size_t listSize, char *list); // ok
MarshalledValue S8_marshal(char); // ok
char *S8_type(); // ok
char *Scalar_format(); // ok
MarshalledValue Socket_List_marshal(size_t listSize, SOCKET *list); // ok
MarshalledValue Socket_marshal(SOCKET); // ok
char *Socket_type(); // ok
MarshalledValue String_List_marshal(size_t listSize, char **charPtrList); // ok
MarshalledValue String_marshal(char *); // ok
char *String_type(); // ok
char *TcpPort_type(); // ok
MarshalledValue U16_List_marshal(size_t listSize, unsigned short *list); // ok
MarshalledValue U16_marshal(unsigned short); // ok
char *U16_type(); // ok
MarshalledValue U32_List_marshal(size_t listSize, unsigned int *list); // ok
MarshalledValue U32_marshal(unsigned int); // ok
char *U32_type(); // ok
MarshalledValue U64_List_marshal(size_t listSize, posh_u64_t *list); // ok
MarshalledValue U64_marshal(posh_u64_t); // ok
char *U64_type(); // ok
MarshalledValue U8_List_marshal(size_t listSize, unsigned char *list); // ok
MarshalledValue U8_marshal(unsigned char); // ok
char *U8_type(); // ok
MarshalledValue UString_List_marshal(size_t listSize, unsigned char **ucharPtrList, size_t *ucharPtrSizeList); // ok
MarshalledValue UString_marshal(unsigned char *ucharPtr, size_t ucharSize); // ok
char *UString_type(); // ok
char *UdpPort_type(); // ok
void freeMarshalledValue(MarshalledValue); // ok
char fuck1();
unsigned char fuck2();
short fuck3();
unsigned short fuck4();
int fuck5();
unsigned int fuck6();
long long fuck7();
unsigned long long fuck8();

static PyObject* TrchError;  /* add this! */
static  int
SWIG_AsVal_char (PyObject *, char *);
static  int
SWIG_AsVal_short (PyObject *, short *);
static  int
SWIG_AsVal_int (PyObject *, int *);
static  int
SWIG_AsVal_long_SS_long (PyObject *, long long *);
static  int
SWIG_AsVal_unsigned_SS_char (PyObject *, unsigned char *);
static  int
SWIG_AsVal_unsigned_SS_short (PyObject *, unsigned short *);
static  int
SWIG_AsVal_unsigned_SS_int (PyObject *, unsigned int *);
static  int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *, unsigned long long *);
static  int
toInterger(char* typeName, PyObject * obj, void* ptr)
{
    if (!strcmp(typeName, "char"))
        return SWIG_AsVal_char(obj, (char*)ptr);
    else if (!strcmp(typeName, "short"))
        return SWIG_AsVal_short(obj, (short*)ptr);
    else if (!strcmp(typeName, "int"))
        return SWIG_AsVal_int(obj, (int*)ptr);
    else if (!strcmp(typeName, "posh_i64_t"))
        return SWIG_AsVal_long_SS_long(obj, (posh_i64_t*)ptr);
    else if (!strcmp(typeName, "SOCKET"))
        return SWIG_AsVal_unsigned_SS_long_SS_long(obj, (SOCKET*)ptr);
    else if (!strcmp(typeName, "unsigned char"))
        return SWIG_AsVal_unsigned_SS_char(obj, (unsigned char*)ptr);
    else if (!strcmp(typeName, "unsigned short"))
        return SWIG_AsVal_unsigned_SS_short(obj, (unsigned short*)ptr);
    else if (!strcmp(typeName, "unsigned int"))
        return SWIG_AsVal_unsigned_SS_int(obj, (unsigned int*)ptr);
    else if (!strcmp(typeName, "posh_u64_t"))
        return SWIG_AsVal_unsigned_SS_long_SS_long(obj, (posh_u64_t*)ptr);
    else
        return -1;
}
static  PyObject*
fromInterger(char *typeName, void* ptr)
{
    if (!strcmp(typeName, "char"))
        return SWIG_From_char(*(char*)ptr);
    else if (!strcmp(typeName, "short"))
        return SWIG_From_short(*(short*)ptr);
    else if (!strcmp(typeName, "int"))
        return SWIG_From_int(*(int*)ptr);
    else if (!strcmp(typeName, "posh_i64_t"))
        return SWIG_From_long_SS_long(*(posh_i64_t*)ptr);
    else if (!strcmp(typeName, "SOCKET"))
        return SWIG_From_unsigned_SS_long_SS_long(*(SOCKET*)ptr);
    else if (!strcmp(typeName, "unsigned char"))
        return SWIG_From_unsigned_SS_char(*(unsigned char*)ptr);
    else if (!strcmp(typeName, "unsigned short"))
        return SWIG_From_unsigned_SS_short(*(unsigned short*)ptr);
    else if (!strcmp(typeName, "unsigned int"))
        return SWIG_From_unsigned_SS_int(*(unsigned int*)ptr);
    else if (!strcmp(typeName, "posh_u64_t"))
        return SWIG_From_unsigned_SS_long_SS_long(*(posh_u64_t*)ptr);
    else
        return SWIG_Py_Void();
}


static  int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = -5;
  if (((((PyObject*)(obj))->ob_type) == (&PyFloat_Type) || PyType_IsSubtype((((PyObject*)(obj))->ob_type), (&PyFloat_Type)))) {
    if (val) *val = PyFloat_AsDouble(obj);
    return (0);





  } else if (((((((PyObject*)(obj))->ob_type))->tp_flags & ((1UL << 24))) != 0)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return (0);
    } else {
      PyErr_Clear();
    }
  }





















  return res;
}






//
// math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <math.h> header.  This header consists of two parts:
// <corecrt_math.h> contains the math library; <corecrt_math_defines.h> contains
// the nonstandard but useful constant definitions.  The headers are divided in
// this way for modularity (to support the C++ modules feature).
//








static   int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if (((*_errno()) == 33) || ((*_errno()) == 34)) {
     (*_errno()) = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*2.2204460492503131e-016) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


static  int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{











  if (((((((PyObject*)(obj))->ob_type))->tp_flags & ((1UL << 24))) != 0)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return (0);
    } else {
      PyErr_Clear();
      return -7;
    }
  }




















  return -5;
}


















static  int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = -5;
  if (((((((PyObject*)(obj))->ob_type))->tp_flags & ((1UL << 24))) != 0)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return (0);
    } else {
      PyErr_Clear();
      res = -7;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if ((res >= 0)) {
      if (val) *val = v;
      return res;
    }
  }














  return res;
}



static   int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  int res = -5;

  if (sizeof(size_t) <= sizeof(unsigned long)) {

    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if ((res >= 0) && val) *val = (size_t)(v);

  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if ((res >= 0) && val) *val = (size_t)(v);
  }

  return res;
}


static  int
SWIG_AsVal_long (PyObject *obj, long* val)
{






  if (((((((PyObject*)(obj))->ob_type))->tp_flags & ((1UL << 24))) != 0)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return (0);
    } else {
      PyErr_Clear();
      return -7;
    }
  }




















  return -5;
}


static  int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if ((res >= 0)) {
    if ((v < (-2147483647 - 1) || v > 2147483647)) {
      return -7;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}


static  swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_Python_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


static   PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > 2147483647) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_Python_NewPointerObj(((void *)0), (char *)(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {


      return PyBytes_FromStringAndSize(carray, (Py_ssize_t)(size));






    }
  } else {
    return SWIG_Py_Void();
  }
}


static   PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


static  int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{


  if (((((((PyObject*)(obj))->ob_type))->tp_flags & ((1UL << 27))) != 0))






  {
    char *cstr; Py_ssize_t len;
    int ret = (0);















    PyBytes_AsStringAndSize(obj, &cstr, &len);



    if (cptr) {
      if (alloc) {
	if (*alloc == ((0) | ((1 << 8) << 1))) {
	  *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
	  *alloc = ((0) | ((1 << 8) << 1));
	} else {
	  *cptr = cstr;
	  *alloc = ((0));
	}
      } else {


	*cptr = PyBytes_AsString(obj);








      }
    }
    if (psize) *psize = len + 1;



    return ret;
  } else {





























    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_Python_ConvertPtrAndOwn(obj, &vptr, pchar_descriptor, 0, 0) == (0)) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = ((0));
	return (0);
      }
    }
  }
  return -5;
}





static   PyObject*
  SWIG_From_int  (int value)
{
  return PyLong_FromLong((long) value);
}


static   PyObject*
  SWIG_From_unsigned_SS_int  (unsigned int value)
{
  return PyLong_FromSize_t((size_t) value);
}


static  int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if ((res >= 0)) {
    if ((v > 0xffffffff)) {
      return -7;
    } else {
      if (val) *val = (unsigned int)(v);
    }
  }  
  return res;
}


static  int
SWIG_AsCharArray(PyObject * obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = ((0));
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if ((res >= 0)) {
    /* special case of single char conversion when we don't need space for NUL */
    if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == ((0) | ((1 << 8) << 1))) {
	free((char*)cptr);
	res = ((res >= 0) ? (res & ~((1 << 8) << 1)) : res);
      }      
      return res;
    }
    if (alloc == ((0) | ((1 << 8) << 1))) free((char*)cptr);
  }
  return -5;
}


static  int
SWIG_AsVal_char (PyObject * obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!(res >= 0)) {
    long v;
    res = (SWIG_AsVal_long (obj, &v));
    if ((res >= 0)) {
      if (((-128) <= v) && (v <= 127)) {
	if (val) *val = (char)(v);
      } else {
	res = -7;
      }
    }
  }
  return res;
}


static   PyObject*
  SWIG_From_bool  (_Bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


static  int
SWIG_AsVal_unsigned_SS_short (PyObject * obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if ((res >= 0)) {
    if ((v > 0xffff)) {
      return -7;
    } else {
      if (val) *val = (unsigned short)(v);
    }
  }  
  return res;
}


static  int
SWIG_AsVal_short (PyObject * obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if ((res >= 0)) {
    if ((v < (-32768) || v > 32767)) {
      return -7;
    } else {
      if (val) *val = (short)(v);
    }
  }  
  return res;
}



static  int
SWIG_AsVal_long_SS_long (PyObject *obj, long long *val)
{
  int res = -5;
  if (((((((PyObject*)(obj))->ob_type))->tp_flags & ((1UL << 24))) != 0)) {
    long long v = PyLong_AsLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return (0);
    } else {
      PyErr_Clear();
      res = -7;
    }
  } else {
    long v;
    res = SWIG_AsVal_long (obj,&v);
    if ((res >= 0)) {
      if (val) *val = v;
      return res;
    }
  }















  return res;
}



static  int
SWIG_AsVal_unsigned_SS_char (PyObject * obj, unsigned char *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if ((res >= 0)) {
    if ((v > 0xff)) {
      return -7;
    } else {
      if (val) *val = (unsigned char)(v);
    }
  }  
  return res;
}


static   PyObject *
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


  


static   PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > 2147483647L) ?
    PyLong_FromUnsignedLong(value) : PyLong_FromLong((long)(value));
}


static   PyObject *
SWIG_From_unsigned_SS_char  (unsigned char value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


static   PyObject *
SWIG_From_short  (short value)
{    
  return PyLong_FromLong(value);
}


static   PyObject *
SWIG_From_unsigned_SS_short  (unsigned short value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}



static   PyObject* 
SWIG_From_long_SS_long  (long long value)
{
  return ((value < (-2147483647L - 1)) || (value > 2147483647L)) ?
    PyLong_FromLongLong(value) : PyLong_FromLong((long)(value));
}




static   PyObject* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > 2147483647L) ?
    PyLong_FromUnsignedLongLong(value) : PyLong_FromLong((long)(value));
}





static  PyObject *_wrap_Boolean_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  int *arg2 = (int *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (int *) malloc((arg1)*sizeof(int));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("int", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)Boolean_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_Boolean_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Boolean_marshal" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = (MarshalledValue)Boolean_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Boolean_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Boolean_type", 0, 0, 0)) goto fail;
  result = (char *)Boolean_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Buffer_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  size_t *arg3 = (size_t *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (unsigned char **) malloc((arg1)*sizeof(unsigned char*));
    arg3 = (size_t *) malloc((arg1)*sizeof(size_t));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(SWIG_AsCharPtrAndSize(item, (char**)&arg2[i], &arg3[i], ((void *)0)) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "list must contain strings"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)Buffer_List_marshal(arg1,arg2,arg3);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
    if (arg3) free(arg3);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
    if (arg3) free(arg3);
  }
  return ((void *)0);
}


static  PyObject *_wrap_Buffer_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned char *arg1 = (unsigned char *) 0 ;
  size_t arg2 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!(SWIG_AsCharPtrAndSize(swig_obj[0], (char**)&arg1, &arg2, ((void *)0)) >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "argument " "1"" of type '" "unsigned char *""'"); goto fail; } while(0);
    }
  }
  result = (MarshalledValue)Buffer_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Buffer_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Buffer_type", 0, 0, 0)) goto fail;
  result = (char *)Buffer_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  char *arg6 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  PyObject *swig_obj[6] ;
  Config result;
  
  if (!SWIG_Python_UnpackTuple(args, "Config_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Config_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, ((void *)0), &alloc3);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Config_create" "', argument " "3"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, ((void *)0), &alloc4);
  if (!(res4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res4 != (-1)) ? res4 : -5)), "in method '" "Config_create" "', argument " "4"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg4 = (char *)(buf4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Config_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, ((void *)0), &alloc6);
  if (!(res6 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Config_create" "', argument " "6"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg6 = (char *)(buf6);
  result = (Config)Config_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[0], 0 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  if (alloc4 == ((0) | ((1 << 8) << 1))) free((char*)buf4);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  if (alloc6 == ((0) | ((1 << 8) << 1))) free((char*)buf6);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  if (alloc4 == ((0) | ((1 << 8) << 1))) free((char*)buf4);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  if (alloc6 == ((0) | ((1 << 8) << 1))) free((char*)buf6);
  return ((void *)0);
}


static  PyObject *_wrap_Config_delete(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_delete" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  Config_delete(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_duplicate(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Config result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_duplicate" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (Config)Config_duplicate(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[0], 0 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_getConfigVersion(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_getConfigVersion" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (char *)Config_getConfigVersion(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_getConstants(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  Params *arg2 = (Params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Config_getConstants", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_getConstants" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[10], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Config_getConstants" "', argument " "2"" of type '" "Params *""'"); goto fail; } while(0); 
  }
  arg2 = (Params *)(argp2);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Config_getConstants(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_getID(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_getID" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (char *)Config_getID(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_getInputParams(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  Params *arg2 = (Params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Params temp2 ;
  PyObject *swig_obj[1] ;
  int result;
  
  {
    arg2 = &temp2;
  }
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_getInputParams" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Config_getInputParams(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  {
    do { PyObject *_py_decref_tmp = (PyObject *)(resultobj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    if ( *arg2 )
    resultobj =  SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(*arg2)), swig_types[4], 0);
    else
    resultobj = SWIG_Py_Void(); 
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_getName(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_getName" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (char *)Config_getName(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_getNamespaceUri(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_getNamespaceUri" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (char *)Config_getNamespaceUri(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_getOutputParams(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  Params *arg2 = (Params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Params temp2 ;
  PyObject *swig_obj[1] ;
  int result;
  
  {
    arg2 = &temp2;
  }
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_getOutputParams" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Config_getOutputParams(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  {
    do { PyObject *_py_decref_tmp = (PyObject *)(resultobj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    if ( *arg2 )
    resultobj =  SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(*arg2)), swig_types[4], 0);
    else
    resultobj = SWIG_Py_Void(); 
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_getSchemaVersion(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_getSchemaVersion" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (char *)Config_getSchemaVersion(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_getVersion(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_getVersion" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (char *)Config_getVersion(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  MarshalledValue result;
  
  if (!SWIG_Python_UnpackTuple(args, "Config_marshal", 3, 3, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_marshal" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Config_marshal" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, ((void *)0), &alloc3);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Config_marshal" "', argument " "3"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg3 = (char *)(buf3);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (MarshalledValue)Config_marshal(arg1,arg2,arg3);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return ((void *)0);
}


static  PyObject *_wrap_Config_printUsage(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  char *arg2 = (char *) 0 ;
  TcLogger arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Config_printUsage", 4, 4, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_printUsage" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Config_printUsage" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[5], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Config_printUsage" "', argument " "3"" of type '" "TcLogger""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Config_printUsage" "', argument " "3"" of type '" "TcLogger""'"); goto fail; } while(0);
    } else {
      arg3 = *((TcLogger *)(argp3));
    }
  }
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Config_printUsage" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  Config_printUsage(arg1,arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return ((void *)0);
}


static  PyObject *_wrap_Config_setConstants(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  Params arg2 = (Params) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Config_setConstants", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_setConstants" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[4], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Config_setConstants" "', argument " "2"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg2 = (Params)(argp2);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Config_setConstants(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_setInputParams(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  Params arg2 = (Params) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Config_setInputParams", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_setInputParams" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[4], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Config_setInputParams" "', argument " "2"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg2 = (Params)(argp2);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Config_setInputParams(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_setOutputParams(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Config arg1 = (Config) 0 ;
  Params arg2 = (Params) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Config_setOutputParams", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[0], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_setOutputParams" "', argument " "1"" of type '" "Config""'"); goto fail; } while(0); 
  }
  arg1 = (Config)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[4], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Config_setOutputParams" "', argument " "2"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg2 = (Params)(argp2);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Config_setOutputParams(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Config_unmarshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject *swig_obj[1] ;
  Config result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Config_unmarshal" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  result = (Config)Config_unmarshal(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[0], 0 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return ((void *)0);
}


static  PyObject *_wrap_FinalizeXMLUnmarshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  
  if (!SWIG_Python_UnpackTuple(args, "FinalizeXMLUnmarshal", 0, 0, 0)) goto fail;
  FinalizeXMLUnmarshal();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_IPv4_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  char **arg2 = (char **) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (char **) malloc((arg1)*sizeof(char*));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(SWIG_AsCharPtrAndSize(item, &arg2[i], ((void *)0), ((void *)0)) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "list must contain strings"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)IPv4_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_IPv4_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "IPv4_marshal" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  result = (MarshalledValue)IPv4_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return ((void *)0);
}


static  PyObject *_wrap_IPv4_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "IPv4_type", 0, 0, 0)) goto fail;
  result = (char *)IPv4_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_IPv6_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  char **arg2 = (char **) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (char **) malloc((arg1)*sizeof(char*));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(SWIG_AsCharPtrAndSize(item, &arg2[i], ((void *)0), ((void *)0)) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "list must contain strings"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)IPv6_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_IPv6_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "IPv6_marshal" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  result = (MarshalledValue)IPv6_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return ((void *)0);
}


static  PyObject *_wrap_IPv6_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "IPv6_type", 0, 0, 0)) goto fail;
  result = (char *)IPv6_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_InitializeXMLUnmarshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  
  if (!SWIG_Python_UnpackTuple(args, "InitializeXMLUnmarshal", 0, 0, 0)) goto fail;
  InitializeXMLUnmarshal();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_List_format(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "List_format", 0, 0, 0)) goto fail;
  result = (char *)List_format();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_LocalFile_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  char **arg2 = (char **) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (char **) malloc((arg1)*sizeof(char*));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(SWIG_AsCharPtrAndSize(item, &arg2[i], ((void *)0), ((void *)0)) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "list must contain strings"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)LocalFile_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_LocalFile_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "LocalFile_marshal" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  result = (MarshalledValue)LocalFile_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return ((void *)0);
}


static  PyObject *_wrap_LocalFile_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "LocalFile_type", 0, 0, 0)) goto fail;
  result = (char *)LocalFile_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_addParamgroup(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  Paramgroup arg2 = (Paramgroup) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramchoice_addParamgroup", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_addParamgroup" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[3], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramchoice_addParamgroup" "', argument " "2"" of type '" "Paramgroup""'"); goto fail; } while(0); 
  }
  arg2 = (Paramgroup)(argp2);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Paramchoice_addParamgroup(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  PyObject *swig_obj[5] ;
  Paramchoice result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramchoice_create", 5, 5, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramchoice_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, ((void *)0), &alloc3);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Paramchoice_create" "', argument " "3"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, ((void *)0), &alloc4);
  if (!(res4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res4 != (-1)) ? res4 : -5)), "in method '" "Paramchoice_create" "', argument " "4"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg4 = (char *)(buf4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Paramchoice_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  result = (Paramchoice)Paramchoice_create(arg1,arg2,arg3,arg4,arg5);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[1], 0 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  if (alloc4 == ((0) | ((1 << 8) << 1))) free((char*)buf4);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  if (alloc4 == ((0) | ((1 << 8) << 1))) free((char*)buf4);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_delete(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_delete" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  Paramchoice_delete(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_getDefaultValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  char **arg2 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *temp2 ;
  PyObject *swig_obj[1] ;
  int result;
  
  {
    arg2 = &temp2;
  }
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_getDefaultValue" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Paramchoice_getDefaultValue(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  {
    do { PyObject *_py_decref_tmp = (PyObject *)(resultobj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    if (result < 0)
    {
      SWIG_Python_SetErrorMsg(TrchError, "function failed");
      goto fail;
    }
    if ( *arg2 )
    resultobj = SWIG_FromCharPtr((const char *)*arg2);
    else
    resultobj = SWIG_Py_Void();
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_getDescription(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  char **arg2 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *temp2 ;
  PyObject *swig_obj[1] ;
  int result;
  
  {
    arg2 = &temp2;
  }
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_getDescription" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Paramchoice_getDescription(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  {
    do { PyObject *_py_decref_tmp = (PyObject *)(resultobj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    if (result < 0)
    {
      SWIG_Python_SetErrorMsg(TrchError, "function failed");
      goto fail;
    }
    if ( *arg2 )
    resultobj = SWIG_FromCharPtr((const char *)*arg2);
    else
    resultobj = SWIG_Py_Void();
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_getName(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  char **arg2 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *temp2 ;
  PyObject *swig_obj[1] ;
  int result;
  
  {
    arg2 = &temp2;
  }
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_getName" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Paramchoice_getName(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  {
    do { PyObject *_py_decref_tmp = (PyObject *)(resultobj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    if (result < 0)
    {
      SWIG_Python_SetErrorMsg(TrchError, "function failed");
      goto fail;
    }
    if ( *arg2 )
    resultobj = SWIG_FromCharPtr((const char *)*arg2);
    else
    resultobj = SWIG_Py_Void();
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_getNumParamgroups(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned int result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_getNumParamgroups" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (unsigned int)Paramchoice_getNumParamgroups(arg1);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_getParamgroup(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  Paramgroup result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramchoice_getParamgroup", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_getParamgroup" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Paramchoice_getParamgroup" "', argument " "2"" of type '" "size_t""'"); goto fail; } while(0);
  } 
  arg2 = (size_t)(val2);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (Paramgroup)Paramchoice_getParamgroup(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[3], 0 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  char **arg2 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *temp2 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  {
    arg2 = &temp2;
  }
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_getValue" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (char *)Paramchoice_getValue(arg1,arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  {
    do { PyObject *_py_decref_tmp = (PyObject *)(resultobj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    if (result < 0)
    {
      SWIG_Python_SetErrorMsg(TrchError, "function failed");
      goto fail;
    }
    if ( *arg2 )
    resultobj = SWIG_FromCharPtr((const char *)*arg2);
    else
    resultobj = SWIG_Py_Void();
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_hasValidValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_hasValidValue" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Paramchoice_hasValidValue(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_hasValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_hasValue" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Paramchoice_hasValue(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_isValid(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_isValid" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Paramchoice_isValid(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_matchName(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramchoice_matchName", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_matchName" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramchoice_matchName" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Paramchoice_matchName(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return ((void *)0);
}


static  PyObject *_wrap_Paramchoice_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Paramchoice arg1 = (Paramchoice) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramchoice_setValue", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[1], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramchoice_setValue" "', argument " "1"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg1 = (Paramchoice)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramchoice_setValue" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  {
    if (!arg1) {
      SWIG_Python_SetErrorMsg(TrchError, "self cannot be NULL");
      goto fail;
    }
  }
  result = (int)Paramchoice_setValue(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Boolean_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Boolean_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Boolean_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Boolean_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_Boolean_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_Boolean_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_Boolean_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_Boolean_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Boolean_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_Boolean_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Boolean_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Boolean_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Boolean_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Boolean_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Boolean_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Boolean_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_Boolean_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Boolean_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Boolean_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Boolean_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Boolean_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Boolean_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Boolean_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_Boolean_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Boolean_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_Boolean_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Boolean_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Parameter_Boolean_List_setValue" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = Parameter_Boolean_List_setValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Boolean_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Boolean_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Boolean_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Boolean_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_Boolean_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_Boolean_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_Boolean_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_Boolean_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Boolean_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_Boolean_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Boolean_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Parameter arg1 = (Parameter) 0 ;
  __int64 arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Boolean_getValue", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[2], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Boolean_getValue" "', argument " "1"" of type '" "Parameter""'"); goto fail; } while(0); 
  }
  arg1 = (Parameter)(argp1);
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Boolean_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Boolean_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_Boolean_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Boolean_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  unsigned int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Boolean_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Boolean_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Boolean_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Parameter_Boolean_setValue" "', argument " "2"" of type '" "unsigned int""'"); goto fail; } while(0);
  } 
  arg2 = (unsigned int)(val2);
  result = Parameter_Boolean_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Buffer_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Buffer_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Buffer_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Buffer_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_Buffer_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_Buffer_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_Buffer_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_Buffer_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_Buffer_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Buffer_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Buffer_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Buffer_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Buffer_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_Buffer_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Buffer_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Buffer_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  result = Parameter_Buffer_List_getValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Buffer_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  __int64 arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject *swig_obj[4] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Buffer_List_setValue", 4, 4, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Buffer_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Buffer_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_Buffer_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  {
    res4 = SWIG_Python_ConvertPtrAndOwn(swig_obj[3], &argp4, swig_types[6], 0, 0);
    if (!(res4 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res4 != (-1)) ? res4 : -5)), "in method '" "Parameter_Buffer_List_setValue" "', argument " "4"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp4) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_List_setValue" "', argument " "4"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg4 = *((__int64 *)(argp4));
    }
  }
  result = Parameter_Buffer_List_setValue(arg1,arg2,arg3,arg4);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Buffer_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Buffer_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Buffer_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Buffer_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_Buffer_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_Buffer_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_Buffer_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_Buffer_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_Buffer_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Buffer_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Buffer_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Buffer_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Buffer_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_Buffer_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_Buffer_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Buffer_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Buffer_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Buffer_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Buffer_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_Buffer_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Buffer_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_Buffer_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv4_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv4_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv4_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv4_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_IPv4_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_IPv4_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_IPv4_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_IPv4_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_IPv4_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv4_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv4_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv4_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv4_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_IPv4_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv4_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv4_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv4_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv4_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_IPv4_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_IPv4_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv4_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv4_List_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv4_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv4_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_IPv4_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_IPv4_List_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv4_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv4_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv4_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv4_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_IPv4_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_IPv4_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_IPv4_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_IPv4_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_IPv4_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv4_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv4_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv4_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv4_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_IPv4_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv4_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv4_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv4_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv4_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv4_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_IPv4_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv6_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv6_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv6_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv6_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_IPv6_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_IPv6_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_IPv6_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_IPv6_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_IPv6_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv6_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv6_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv6_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv6_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_IPv6_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv6_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv6_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv6_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv6_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_IPv6_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_IPv6_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv6_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv6_List_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv6_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv6_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_IPv6_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_IPv6_List_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv6_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv6_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv6_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv6_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_IPv6_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_IPv6_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_IPv6_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_IPv6_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_IPv6_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv6_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv6_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv6_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv6_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_IPv6_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_IPv6_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_IPv6_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_IPv6_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_IPv6_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_IPv6_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_IPv6_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_LocalFile_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_LocalFile_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_LocalFile_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_LocalFile_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_LocalFile_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_LocalFile_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_LocalFile_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_LocalFile_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_LocalFile_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_LocalFile_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_LocalFile_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_LocalFile_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_LocalFile_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_LocalFile_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_LocalFile_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_LocalFile_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_LocalFile_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_LocalFile_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_LocalFile_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_LocalFile_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_LocalFile_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_LocalFile_List_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_LocalFile_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_LocalFile_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_LocalFile_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_LocalFile_List_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_LocalFile_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_LocalFile_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_LocalFile_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_LocalFile_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_LocalFile_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_LocalFile_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_LocalFile_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_LocalFile_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_LocalFile_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_LocalFile_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_LocalFile_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_LocalFile_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_LocalFile_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_LocalFile_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_LocalFile_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_LocalFile_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_LocalFile_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_LocalFile_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_LocalFile_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_LocalFile_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Port_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Port_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Port_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Port_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Port_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Port_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_Port_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Port_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Port_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Port_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Port_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Port_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Port_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_Port_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Port_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_Port_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Port_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Parameter_Port_List_setValue" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = Parameter_Port_List_setValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Port_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Port_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Port_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Port_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Port_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Port_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_Port_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Port_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  unsigned __int16 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Port_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Port_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Port_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[20], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Port_setValue" "', argument " "2"" of type '" "unsigned __int16""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Port_setValue" "', argument " "2"" of type '" "unsigned __int16""'"); goto fail; } while(0);
    } else {
      arg2 = *((unsigned __int16 *)(argp2));
    }
  }
  result = Parameter_Port_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S16_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S16_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S16_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S16_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_S16_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_S16_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_S16_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_S16_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_S16_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S16_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S16_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S16_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S16_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_S16_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S16_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S16_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S16_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S16_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_S16_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_S16_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S16_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Parameter_S16_List_setValue" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = Parameter_S16_List_setValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S16_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S16_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S16_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S16_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_S16_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_S16_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_S16_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_S16_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_S16_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S16_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S16_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S16_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S16_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_S16_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S16_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  unsigned __int16 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S16_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S16_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[20], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S16_setValue" "', argument " "2"" of type '" "unsigned __int16""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S16_setValue" "', argument " "2"" of type '" "unsigned __int16""'"); goto fail; } while(0);
    } else {
      arg2 = *((unsigned __int16 *)(argp2));
    }
  }
  result = Parameter_S16_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S32_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S32_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S32_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S32_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_S32_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_S32_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_S32_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_S32_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_S32_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S32_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S32_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S32_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S32_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_S32_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S32_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S32_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S32_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S32_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_S32_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_S32_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S32_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Parameter_S32_List_setValue" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = Parameter_S32_List_setValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S32_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S32_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S32_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S32_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_S32_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_S32_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_S32_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_S32_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_S32_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S32_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S32_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S32_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S32_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_S32_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S32_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  unsigned int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S32_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S32_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S32_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Parameter_S32_setValue" "', argument " "2"" of type '" "unsigned int""'"); goto fail; } while(0);
  } 
  arg2 = (unsigned int)(val2);
  result = Parameter_S32_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S64_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S64_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S64_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S64_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_S64_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_S64_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_S64_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_S64_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_S64_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S64_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S64_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S64_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S64_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_S64_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S64_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S64_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S64_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S64_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_S64_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_S64_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S64_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Parameter_S64_List_setValue" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = Parameter_S64_List_setValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S64_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S64_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S64_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S64_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_S64_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_S64_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_S64_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_S64_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_S64_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S64_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S64_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S64_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S64_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_S64_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S64_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S64_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S64_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S64_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S64_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_S64_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S8_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S8_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S8_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S8_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_S8_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_S8_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_S8_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_S8_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_S8_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S8_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S8_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S8_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S8_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_S8_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S8_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S8_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S8_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S8_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_S8_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_S8_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S8_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S8_List_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S8_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S8_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_S8_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_S8_List_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S8_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S8_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S8_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S8_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_S8_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_S8_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_S8_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_S8_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_S8_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S8_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S8_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S8_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_S8_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_S8_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_S8_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  char arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_S8_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_S8_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_char(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Parameter_S8_setValue" "', argument " "2"" of type '" "char""'"); goto fail; } while(0);
  } 
  arg2 = (char)(val2);
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_S8_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_S8_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_S8_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Socket_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Socket_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Socket_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Socket_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_Socket_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_Socket_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_Socket_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_Socket_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_Socket_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Socket_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Socket_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Socket_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Socket_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_Socket_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Socket_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Socket_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Socket_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Socket_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_Socket_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_Socket_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Socket_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Parameter_Socket_List_setValue" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = Parameter_Socket_List_setValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Socket_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Socket_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Socket_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Socket_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_Socket_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_Socket_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_Socket_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_Socket_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_Socket_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Socket_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Socket_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Socket_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Socket_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_Socket_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_Socket_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_Socket_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_Socket_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_Socket_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_Socket_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_Socket_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_String_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_String_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_String_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_String_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_String_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_String_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_String_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_String_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_String_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_String_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_String_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_String_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_String_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_String_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_String_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_String_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_String_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_String_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_String_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_String_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_String_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_String_List_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_String_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_String_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_String_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_String_List_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_String_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_String_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_String_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_String_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_String_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_String_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_String_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_String_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_String_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_String_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_String_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_String_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_String_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_String_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_String_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_String_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_String_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_String_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_String_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_String_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_TcpPort_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_TcpPort_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_TcpPort_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_TcpPort_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_TcpPort_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_TcpPort_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_TcpPort_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_TcpPort_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_TcpPort_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_TcpPort_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_TcpPort_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_TcpPort_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_TcpPort_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_TcpPort_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_TcpPort_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_TcpPort_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_TcpPort_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_TcpPort_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_TcpPort_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_TcpPort_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U16_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U16_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U16_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U16_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_U16_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_U16_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_U16_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_U16_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_U16_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U16_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U16_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U16_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U16_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_U16_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U16_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U16_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U16_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U16_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_U16_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_U16_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U16_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Parameter_U16_List_setValue" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = Parameter_U16_List_setValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U16_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U16_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U16_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U16_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_U16_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_U16_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_U16_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_U16_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_U16_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U16_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U16_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U16_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U16_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_U16_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U16_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  unsigned __int16 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U16_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U16_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[20], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U16_setValue" "', argument " "2"" of type '" "unsigned __int16""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U16_setValue" "', argument " "2"" of type '" "unsigned __int16""'"); goto fail; } while(0);
    } else {
      arg2 = *((unsigned __int16 *)(argp2));
    }
  }
  result = Parameter_U16_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U32_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U32_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U32_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U32_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_U32_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_U32_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_U32_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_U32_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_U32_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U32_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U32_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U32_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U32_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_U32_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U32_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U32_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U32_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U32_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_U32_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_U32_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U32_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Parameter_U32_List_setValue" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = Parameter_U32_List_setValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U32_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U32_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U32_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U32_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_U32_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_U32_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_U32_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_U32_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_U32_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U32_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U32_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U32_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U32_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_U32_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U32_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  unsigned int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U32_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U32_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U32_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Parameter_U32_setValue" "', argument " "2"" of type '" "unsigned int""'"); goto fail; } while(0);
  } 
  arg2 = (unsigned int)(val2);
  result = Parameter_U32_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U64_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U64_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U64_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U64_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_U64_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_U64_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_U64_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_U64_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_U64_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U64_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U64_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U64_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U64_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_U64_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U64_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U64_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U64_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U64_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_U64_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_U64_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U64_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Parameter_U64_List_setValue" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = Parameter_U64_List_setValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U64_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U64_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U64_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U64_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_U64_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_U64_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_U64_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_U64_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_U64_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U64_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U64_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U64_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U64_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_U64_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U64_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U64_setValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U64_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U64_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U64_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_U64_setValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U8_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U8_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U8_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U8_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_U8_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_U8_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_U8_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_U8_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_U8_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U8_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U8_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U8_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U8_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_U8_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U8_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U8_List_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U8_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U8_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_List_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_U8_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_List_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_U8_List_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U8_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U8_List_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U8_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U8_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_U8_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_U8_List_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U8_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U8_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U8_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U8_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_U8_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_U8_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_U8_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_U8_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_U8_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U8_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U8_getValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U8_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_U8_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_U8_getValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_U8_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  char arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_U8_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_U8_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_char(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Parameter_U8_setValue" "', argument " "2"" of type '" "char""'"); goto fail; } while(0);
  } 
  arg2 = (char)(val2);
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_U8_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_U8_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_U8_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_UString_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_UString_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_UString_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_UString_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_UString_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_UString_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_UString_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_UString_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_UString_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_UString_List_getSize(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_UString_List_getSize", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_UString_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_List_getSize" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_UString_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_List_getSize" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_UString_List_getSize(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_UString_List_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_UString_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_List_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  result = Parameter_UString_List_getValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_UString_List_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  __int64 arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject *swig_obj[4] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_UString_List_setValue", 4, 4, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_UString_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_List_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_UString_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_List_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_UString_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_List_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  {
    res4 = SWIG_Python_ConvertPtrAndOwn(swig_obj[3], &argp4, swig_types[6], 0, 0);
    if (!(res4 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res4 != (-1)) ? res4 : -5)), "in method '" "Parameter_UString_List_setValue" "', argument " "4"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp4) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_List_setValue" "', argument " "4"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg4 = *((__int64 *)(argp4));
    }
  }
  result = Parameter_UString_List_setValue(arg1,arg2,arg3,arg4);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_UString_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_UString_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_UString_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_UString_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_UString_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_UString_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_UString_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_UString_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_UString_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_UString_getValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_UString_getValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_UString_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_getValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_UString_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_getValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_UString_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_getValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_UString_getValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_UString_setValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_UString_setValue", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_UString_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_setValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_UString_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_setValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_UString_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UString_setValue" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_UString_setValue(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_UdpPort_List_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_UdpPort_List_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_UdpPort_List_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_UdpPort_List_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_UdpPort_List_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_UdpPort_List_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_UdpPort_List_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_UdpPort_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UdpPort_List_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_UdpPort_List_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_UdpPort_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  __int64 arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_UdpPort_create", 6, 6, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_UdpPort_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_UdpPort_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!(ecode3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode3 != (-1)) ? ecode3 : -5)), "in method '" "Parameter_UdpPort_create" "', argument " "3"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!(ecode4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode4 != (-1)) ? ecode4 : -5)), "in method '" "Parameter_UdpPort_create" "', argument " "4"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg4 = (int)(val4);
  res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, ((void *)0), &alloc5);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Parameter_UdpPort_create" "', argument " "5"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg5 = (char *)(buf5);
  {
    res6 = SWIG_Python_ConvertPtrAndOwn(swig_obj[5], &argp6, swig_types[6], 0, 0);
    if (!(res6 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res6 != (-1)) ? res6 : -5)), "in method '" "Parameter_UdpPort_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp6) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_UdpPort_create" "', argument " "6"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg6 = *((__int64 *)(argp6));
    }
  }
  result = Parameter_UdpPort_create(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc5 == ((0) | ((1 << 8) << 1))) free((char*)buf5);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_delete(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_delete" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_delete" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  Parameter_delete(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_getDescription(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  _QWORD *arg2 = (_QWORD *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_getDescription", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_getDescription" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_getDescription" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[18], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_getDescription" "', argument " "2"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg2 = (_QWORD *)(argp2);
  result = Parameter_getDescription(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_getFormat(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  _QWORD *arg2 = (_QWORD *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_getFormat", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_getFormat" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_getFormat" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[18], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_getFormat" "', argument " "2"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg2 = (_QWORD *)(argp2);
  result = Parameter_getFormat(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_getInvalidReason(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  _QWORD *arg2 = (_QWORD *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_getInvalidReason", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_getInvalidReason" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_getInvalidReason" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[18], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_getInvalidReason" "', argument " "2"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg2 = (_QWORD *)(argp2);
  result = Parameter_getInvalidReason(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_getMarshalledDefault(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  _QWORD *arg2 = (_QWORD *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_getMarshalledDefault", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_getMarshalledDefault" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_getMarshalledDefault" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[18], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_getMarshalledDefault" "', argument " "2"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg2 = (_QWORD *)(argp2);
  result = Parameter_getMarshalledDefault(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_getMarshalledValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  MarshalledValue result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_getMarshalledValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_getMarshalledValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_getMarshalledValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_getMarshalledValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_getMarshalledValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = (MarshalledValue)Parameter_getMarshalledValue(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_getName(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  _QWORD *arg1 = (_QWORD *) 0 ;
  _QWORD *arg2 = (_QWORD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_getName", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[18], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_getName" "', argument " "1"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg1 = (_QWORD *)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[18], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_getName" "', argument " "2"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg2 = (_QWORD *)(argp2);
  result = Parameter_getName(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_getType(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  _QWORD *arg2 = (_QWORD *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_getType", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_getType" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_getType" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[18], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_getType" "', argument " "2"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg2 = (_QWORD *)(argp2);
  result = Parameter_getType(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_hasValidValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  _BOOL8 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_hasValidValue", 0, 0, 0)) goto fail;
  result = Parameter_hasValidValue();
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (_BOOL8 *)memcpy((_BOOL8 *)calloc(1,sizeof(_BOOL8)),&result,sizeof(_BOOL8)), swig_types[19], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_hasValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  _BOOL8 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_hasValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_hasValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  result = Parameter_hasValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (_BOOL8 *)memcpy((_BOOL8 *)calloc(1,sizeof(_BOOL8)),&result,sizeof(_BOOL8)), swig_types[19], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_hide(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_hide" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_hide" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  Parameter_hide(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_isHidden(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  _Bool result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_isHidden" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_isHidden" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  result = (_Bool)Parameter_isHidden(arg1);
  resultobj = SWIG_From_bool((_Bool)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_isRequired(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  _Bool result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_isRequired" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_isRequired" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  result = (_Bool)Parameter_isRequired(arg1);
  resultobj = SWIG_From_bool((_Bool)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_isValid(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  _BOOL8 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_isValid", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_isValid" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_isValid" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Parameter_isValid" "', argument " "2"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg2 = (int)(val2);
  result = Parameter_isValid(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (_BOOL8 *)memcpy((_BOOL8 *)calloc(1,sizeof(_BOOL8)),&result,sizeof(_BOOL8)), swig_types[19], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_markInvalid(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_markInvalid" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_markInvalid" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  Parameter_markInvalid(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_markInvalidWithReason(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  char *arg2 = (char *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_markInvalidWithReason", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_markInvalidWithReason" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_markInvalidWithReason" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_markInvalidWithReason" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  Parameter_markInvalidWithReason(arg1,arg2);
  resultobj = SWIG_Py_Void();
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_matchFormat(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_matchFormat", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_matchFormat" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_matchFormat" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_matchFormat" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_matchFormat" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_matchFormat(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_matchFormatAndType(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  __int64 arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  _BOOL8 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_matchFormatAndType", 3, 3, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_matchFormatAndType" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_matchFormatAndType" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_matchFormatAndType" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_matchFormatAndType" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  {
    res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[6], 0, 0);
    if (!(res3 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Parameter_matchFormatAndType" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp3) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_matchFormatAndType" "', argument " "3"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg3 = *((__int64 *)(argp3));
    }
  }
  result = Parameter_matchFormatAndType(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (_BOOL8 *)memcpy((_BOOL8 *)calloc(1,sizeof(_BOOL8)),&result,sizeof(_BOOL8)), swig_types[19], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_matchName(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  _QWORD *arg1 = (_QWORD *) 0 ;
  __int64 arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_matchName", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[18], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_matchName" "', argument " "1"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg1 = (_QWORD *)(argp1);
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_matchName" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_matchName" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_matchName(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_matchType(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_matchType", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_matchType" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_matchType" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_matchType" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_matchType" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_matchType(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_resetValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_resetValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_resetValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  result = Parameter_resetValue(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Parameter_setMarshalledValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_setMarshalledValue", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Parameter_setMarshalledValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_setMarshalledValue" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Parameter_setMarshalledValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Parameter_setMarshalledValue" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Parameter_setMarshalledValue(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_addParamchoice(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramgroup_addParamchoice", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_addParamchoice" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_addParamchoice" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramgroup_addParamchoice" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_addParamchoice" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Paramgroup_addParamchoice(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_addParameter(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramgroup_addParameter", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_addParameter" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_addParameter" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramgroup_addParameter" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_addParameter" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Paramgroup_addParameter(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  PyObject *swig_obj[4] ;
  _QWORD *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramgroup_create", 4, 4, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramgroup_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, ((void *)0), &alloc3);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Paramgroup_create" "', argument " "3"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, ((void *)0), &alloc4);
  if (!(res4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res4 != (-1)) ? res4 : -5)), "in method '" "Paramgroup_create" "', argument " "4"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg4 = (char *)(buf4);
  result = (_QWORD *)Paramgroup_create(arg1,arg2,arg3,arg4);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[18], 0 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  if (alloc4 == ((0) | ((1 << 8) << 1))) free((char*)buf4);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  if (alloc4 == ((0) | ((1 << 8) << 1))) free((char*)buf4);
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_delete(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_delete" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_delete" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  Paramgroup_delete(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_getDescription(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  _QWORD *arg2 = (_QWORD *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramgroup_getDescription", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_getDescription" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_getDescription" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[18], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramgroup_getDescription" "', argument " "2"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg2 = (_QWORD *)(argp2);
  result = Paramgroup_getDescription(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_getName(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  _QWORD *arg1 = (_QWORD *) 0 ;
  _QWORD *arg2 = (_QWORD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  signed __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramgroup_getName", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[18], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_getName" "', argument " "1"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg1 = (_QWORD *)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[18], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramgroup_getName" "', argument " "2"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg2 = (_QWORD *)(argp2);
  result = Paramgroup_getName(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_getNumParamchoices(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_getNumParamchoices" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_getNumParamchoices" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  result = Paramgroup_getNumParamchoices(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_getNumParameters(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_getNumParameters" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_getNumParameters" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  result = Paramgroup_getNumParameters(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_getParamchoice(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  unsigned __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramgroup_getParamchoice", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_getParamchoice" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_getParamchoice" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[21], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramgroup_getParamchoice" "', argument " "2"" of type '" "unsigned __int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_getParamchoice" "', argument " "2"" of type '" "unsigned __int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((unsigned __int64 *)(argp2));
    }
  }
  result = Paramgroup_getParamchoice(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_getParameter(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  unsigned __int64 arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramgroup_getParameter", 2, 2, swig_obj)) goto fail;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_getParameter" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_getParameter" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[21], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramgroup_getParameter" "', argument " "2"" of type '" "unsigned __int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_getParameter" "', argument " "2"" of type '" "unsigned __int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((unsigned __int64 *)(argp2));
    }
  }
  result = Paramgroup_getParameter(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_isValid(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  __int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  signed __int64 result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[6], 0, 0);
    if (!(res1 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_isValid" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp1) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_isValid" "', argument " "1"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg1 = *((__int64 *)(argp1));
    }
  }
  result = Paramgroup_isValid(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (signed __int64 *)memcpy((signed __int64 *)calloc(1,sizeof(signed __int64)),&result,sizeof(signed __int64)), swig_types[14], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_matchName(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  _QWORD *arg1 = (_QWORD *) 0 ;
  __int64 arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramgroup_matchName", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[18], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_matchName" "', argument " "1"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg1 = (_QWORD *)(argp1);
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramgroup_matchName" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_matchName" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Paramgroup_matchName(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Paramgroup_removeParameter(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  _QWORD *arg1 = (_QWORD *) 0 ;
  __int64 arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  __int64 result;
  
  if (!SWIG_Python_UnpackTuple(args, "Paramgroup_removeParameter", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[18], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Paramgroup_removeParameter" "', argument " "1"" of type '" "_QWORD *""'"); goto fail; } while(0); 
  }
  arg1 = (_QWORD *)(argp1);
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[6], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Paramgroup_removeParameter" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Paramgroup_removeParameter" "', argument " "2"" of type '" "__int64""'"); goto fail; } while(0);
    } else {
      arg2 = *((__int64 *)(argp2));
    }
  }
  result = Paramgroup_removeParameter(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (__int64 *)memcpy((__int64 *)calloc(1,sizeof(__int64)),&result,sizeof(__int64)), swig_types[6], 0x1 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_addParamchoice(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  Paramchoice arg2 = (Paramchoice) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_addParamchoice", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_addParamchoice" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[1], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_addParamchoice" "', argument " "2"" of type '" "Paramchoice""'"); goto fail; } while(0); 
  }
  arg2 = (Paramchoice)(argp2);
  result = (int)Params_addParamchoice(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_addParameter(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  Parameter arg2 = (Parameter) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_addParameter", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_addParameter" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[2], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_addParameter" "', argument " "2"" of type '" "Parameter""'"); goto fail; } while(0); 
  }
  arg2 = (Parameter)(argp2);
  result = (int)Params_addParameter(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_create(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  Params result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_create", 3, 3, swig_obj)) goto fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_create" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_create" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, ((void *)0), &alloc3);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Params_create" "', argument " "3"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg3 = (char *)(buf3);
  result = (Params)Params_create(arg1,arg2,arg3);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[4], 0 | 0);
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return ((void *)0);
}


static  PyObject *_wrap_Params_delete(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_delete" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  Params_delete(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_duplicate(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Params result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_duplicate" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  result = (Params)Params_duplicate(arg1);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[4], 0 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_findParamchoice(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  Paramchoice result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_findParamchoice", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_findParamchoice" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_findParamchoice" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  result = (Paramchoice)Params_findParamchoice(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[1], 0 | 0);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return ((void *)0);
}


static  PyObject *_wrap_Params_findParameter(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  Parameter result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_findParameter", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_findParameter" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_findParameter" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  result = (Parameter)Params_findParameter(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[2], 0 | 0);
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  return ((void *)0);
}


static  PyObject *_wrap_Params_getCallbackIPv4Values(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char **arg4 = (char **) 0 ;
  char **arg5 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject *swig_obj[5] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_getCallbackIPv4Values", 5, 5, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_getCallbackIPv4Values" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_getCallbackIPv4Values" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, ((void *)0), &alloc3);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Params_getCallbackIPv4Values" "', argument " "3"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_Python_ConvertPtrAndOwn(swig_obj[3], &argp4, swig_types[11], 0 | 0, 0);
  if (!(res4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res4 != (-1)) ? res4 : -5)), "in method '" "Params_getCallbackIPv4Values" "', argument " "4"" of type '" "char **""'"); goto fail; } while(0); 
  }
  arg4 = (char **)(argp4);
  res5 = SWIG_Python_ConvertPtrAndOwn(swig_obj[4], &argp5, swig_types[11], 0 | 0, 0);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Params_getCallbackIPv4Values" "', argument " "5"" of type '" "char **""'"); goto fail; } while(0); 
  }
  arg5 = (char **)(argp5);
  result = (int)Params_getCallbackIPv4Values(arg1,arg2,arg3,arg4,arg5);
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return ((void *)0);
}


static  PyObject *_wrap_Params_getCallbackIPv6Values(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char **arg4 = (char **) 0 ;
  char **arg5 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject *swig_obj[5] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_getCallbackIPv6Values", 5, 5, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_getCallbackIPv6Values" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_getCallbackIPv6Values" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, ((void *)0), &alloc3);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Params_getCallbackIPv6Values" "', argument " "3"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_Python_ConvertPtrAndOwn(swig_obj[3], &argp4, swig_types[11], 0 | 0, 0);
  if (!(res4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res4 != (-1)) ? res4 : -5)), "in method '" "Params_getCallbackIPv6Values" "', argument " "4"" of type '" "char **""'"); goto fail; } while(0); 
  }
  arg4 = (char **)(argp4);
  res5 = SWIG_Python_ConvertPtrAndOwn(swig_obj[4], &argp5, swig_types[11], 0 | 0, 0);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Params_getCallbackIPv6Values" "', argument " "5"" of type '" "char **""'"); goto fail; } while(0); 
  }
  arg5 = (char **)(argp5);
  result = (int)Params_getCallbackIPv6Values(arg1,arg2,arg3,arg4,arg5);
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return ((void *)0);
}


static  PyObject *_wrap_Params_getCallbackPortValues(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  unsigned short *arg4 = (unsigned short *) 0 ;
  unsigned short *arg5 = (unsigned short *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject *swig_obj[5] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_getCallbackPortValues", 5, 5, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_getCallbackPortValues" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_getCallbackPortValues" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, ((void *)0), &alloc3);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Params_getCallbackPortValues" "', argument " "3"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_Python_ConvertPtrAndOwn(swig_obj[3], &argp4, swig_types[25], 0 | 0, 0);
  if (!(res4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res4 != (-1)) ? res4 : -5)), "in method '" "Params_getCallbackPortValues" "', argument " "4"" of type '" "unsigned short *""'"); goto fail; } while(0); 
  }
  arg4 = (unsigned short *)(argp4);
  res5 = SWIG_Python_ConvertPtrAndOwn(swig_obj[4], &argp5, swig_types[25], 0 | 0, 0);
  if (!(res5 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res5 != (-1)) ? res5 : -5)), "in method '" "Params_getCallbackPortValues" "', argument " "5"" of type '" "unsigned short *""'"); goto fail; } while(0); 
  }
  arg5 = (unsigned short *)(argp5);
  result = (int)Params_getCallbackPortValues(arg1,arg2,arg3,arg4,arg5);
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return ((void *)0);
}


static  PyObject *_wrap_Params_getName(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  char **arg2 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *temp2 ;
  PyObject *swig_obj[1] ;
  int result;
  
  {
    arg2 = &temp2;
  }
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_getName" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  result = (int)Params_getName(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  {
    do { PyObject *_py_decref_tmp = (PyObject *)(resultobj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
    if (result < 0)
    {
      SWIG_Python_SetErrorMsg(TrchError, "function failed");
      goto fail;
    }
    if ( *arg2 )
    resultobj = SWIG_FromCharPtr((const char *)*arg2);
    else
    resultobj = SWIG_Py_Void();
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_getNumParamchoices(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned int result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_getNumParamchoices" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  result = (unsigned int)Params_getNumParamchoices(arg1);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_getNumParameters(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned int result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_getNumParameters" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  result = (unsigned int)Params_getNumParameters(arg1);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_getParamchoice(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  Paramchoice result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_getParamchoice", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_getParamchoice" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Params_getParamchoice" "', argument " "2"" of type '" "size_t""'"); goto fail; } while(0);
  } 
  arg2 = (size_t)(val2);
  result = (Paramchoice)Params_getParamchoice(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[1], 0 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_getParameter(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  Parameter result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_getParameter", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_getParameter" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Params_getParameter" "', argument " "2"" of type '" "size_t""'"); goto fail; } while(0);
  } 
  arg2 = (size_t)(val2);
  result = (Parameter)Params_getParameter(arg1,arg2);
  resultobj = SWIG_Python_NewPointerObj(((void *)0), (void *)((const void *)(result)), swig_types[2], 0 | 0);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_isValid(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_isValid" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  result = (int)Params_isValid(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_parseCommandLine(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject *swig_obj[4] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_parseCommandLine", 4, 4, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_parseCommandLine" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!(ecode2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode2 != (-1)) ? ecode2 : -5)), "in method '" "Params_parseCommandLine" "', argument " "2"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg2 = (int)(val2);
  res3 = SWIG_Python_ConvertPtrAndOwn(swig_obj[2], &argp3, swig_types[11], 0 | 0, 0);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Params_parseCommandLine" "', argument " "3"" of type '" "char **""'"); goto fail; } while(0); 
  }
  arg3 = (char **)(argp3);
  res4 = SWIG_Python_ConvertPtrAndOwn(swig_obj[3], &argp4, swig_types[8], 0 | 0, 0);
  if (!(res4 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res4 != (-1)) ? res4 : -5)), "in method '" "Params_parseCommandLine" "', argument " "4"" of type '" "int *""'"); goto fail; } while(0); 
  }
  arg4 = (int *)(argp4);
  result = (int)Params_parseCommandLine(arg1,arg2,arg3,arg4);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_printInvalid(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  TcLogger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_printInvalid", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_printInvalid" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  {
    res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[5], 0, 0);
    if (!(res2 >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_printInvalid" "', argument " "2"" of type '" "TcLogger""'"); goto fail; } while(0); 
    }  
    if (!argp2) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-9), "invalid null reference " "in method '" "Params_printInvalid" "', argument " "2"" of type '" "TcLogger""'"); goto fail; } while(0);
    } else {
      arg2 = *((TcLogger *)(argp2));
    }
  }
  Params_printInvalid(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_removeParameter(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  Parameter arg2 = (Parameter) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_removeParameter", 2, 2, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_removeParameter" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  res2 = SWIG_Python_ConvertPtrAndOwn(swig_obj[1], &argp2, swig_types[2], 0 | 0, 0);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_removeParameter" "', argument " "2"" of type '" "Parameter""'"); goto fail; } while(0); 
  }
  arg2 = (Parameter)(argp2);
  Params_removeParameter(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Params_validateCallbackPorts(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  Params arg1 = (Params) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Params_validateCallbackPorts", 3, 3, swig_obj)) goto fail;
  res1 = SWIG_Python_ConvertPtrAndOwn(swig_obj[0], &argp1, swig_types[4], 0 | 0, 0);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "Params_validateCallbackPorts" "', argument " "1"" of type '" "Params""'"); goto fail; } while(0); 
  }
  arg1 = (Params)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, ((void *)0), &alloc2);
  if (!(res2 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res2 != (-1)) ? res2 : -5)), "in method '" "Params_validateCallbackPorts" "', argument " "2"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, ((void *)0), &alloc3);
  if (!(res3 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res3 != (-1)) ? res3 : -5)), "in method '" "Params_validateCallbackPorts" "', argument " "3"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg3 = (char *)(buf3);
  result = (int)Params_validateCallbackPorts(arg1,arg2,arg3);
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == ((0) | ((1 << 8) << 1))) free((char*)buf2);
  if (alloc3 == ((0) | ((1 << 8) << 1))) free((char*)buf3);
  return ((void *)0);
}


static  PyObject *_wrap_Port_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (unsigned short *) malloc((arg1)*sizeof(unsigned short));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("unsigned short", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)Port_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_Port_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned short arg1 ;
  unsigned short val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_unsigned_SS_short(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Port_marshal" "', argument " "1"" of type '" "unsigned short""'"); goto fail; } while(0);
  } 
  arg1 = (unsigned short)(val1);
  result = (MarshalledValue)Port_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_S16_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  short *arg2 = (short *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (short *) malloc((arg1)*sizeof(short));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("short", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)S16_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_S16_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  short arg1 ;
  short val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_short(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "S16_marshal" "', argument " "1"" of type '" "short""'"); goto fail; } while(0);
  } 
  arg1 = (short)(val1);
  result = (MarshalledValue)S16_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_S16_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "S16_type", 0, 0, 0)) goto fail;
  result = (char *)S16_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_S32_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  int *arg2 = (int *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (int *) malloc((arg1)*sizeof(int));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("int", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)S32_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_S32_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "S32_marshal" "', argument " "1"" of type '" "int""'"); goto fail; } while(0);
  } 
  arg1 = (int)(val1);
  result = (MarshalledValue)S32_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_S32_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "S32_type", 0, 0, 0)) goto fail;
  result = (char *)S32_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_S64_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  posh_i64_t *arg2 = (posh_i64_t *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (posh_i64_t *) malloc((arg1)*sizeof(posh_i64_t));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("posh_i64_t", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)S64_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_S64_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  posh_i64_t arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_long_SS_long(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "S64_marshal" "', argument " "1"" of type '" "posh_i64_t""'"); goto fail; } while(0);
  } 
  arg1 = (posh_i64_t)(val1);
  result = (MarshalledValue)S64_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_S64_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "S64_type", 0, 0, 0)) goto fail;
  result = (char *)S64_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_S8_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  char *arg2 = (char *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (char *) malloc((arg1)*sizeof(char));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("char", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)S8_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_S8_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char arg1 ;
  char val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_char(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "S8_marshal" "', argument " "1"" of type '" "char""'"); goto fail; } while(0);
  } 
  arg1 = (char)(val1);
  result = (MarshalledValue)S8_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_S8_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "S8_type", 0, 0, 0)) goto fail;
  result = (char *)S8_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Scalar_format(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Scalar_format", 0, 0, 0)) goto fail;
  result = (char *)Scalar_format();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Socket_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  SOCKET *arg2 = (SOCKET *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (SOCKET *) malloc((arg1)*sizeof(SOCKET));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("SOCKET", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)Socket_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_Socket_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  SOCKET arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "Socket_marshal" "', argument " "1"" of type '" "SOCKET""'"); goto fail; } while(0);
  } 
  arg1 = (SOCKET)(val1);
  result = (MarshalledValue)Socket_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_Socket_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Socket_type", 0, 0, 0)) goto fail;
  result = (char *)Socket_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_String_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  char **arg2 = (char **) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (char **) malloc((arg1)*sizeof(char*));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(SWIG_AsCharPtrAndSize(item, &arg2[i], ((void *)0), ((void *)0)) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "list must contain strings"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)String_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_String_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "String_marshal" "', argument " "1"" of type '" "char *""'"); goto fail; } while(0);
  }
  arg1 = (char *)(buf1);
  result = (MarshalledValue)String_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return ((void *)0);
}


static  PyObject *_wrap_String_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "String_type", 0, 0, 0)) goto fail;
  result = (char *)String_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_TcpPort_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TcpPort_type", 0, 0, 0)) goto fail;
  result = (char *)TcpPort_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_U16_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (unsigned short *) malloc((arg1)*sizeof(unsigned short));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("unsigned short", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)U16_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_U16_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned short arg1 ;
  unsigned short val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_unsigned_SS_short(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "U16_marshal" "', argument " "1"" of type '" "unsigned short""'"); goto fail; } while(0);
  } 
  arg1 = (unsigned short)(val1);
  result = (MarshalledValue)U16_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_U16_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "U16_type", 0, 0, 0)) goto fail;
  result = (char *)U16_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_U32_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (unsigned int *) malloc((arg1)*sizeof(unsigned int));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("unsigned int", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)U32_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_U32_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "U32_marshal" "', argument " "1"" of type '" "unsigned int""'"); goto fail; } while(0);
  } 
  arg1 = (unsigned int)(val1);
  result = (MarshalledValue)U32_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_U32_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "U32_type", 0, 0, 0)) goto fail;
  result = (char *)U32_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_U64_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  posh_u64_t *arg2 = (posh_u64_t *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (posh_u64_t *) malloc((arg1)*sizeof(posh_u64_t));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("posh_u64_t", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)U64_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_U64_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  posh_u64_t arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "U64_marshal" "', argument " "1"" of type '" "posh_u64_t""'"); goto fail; } while(0);
  } 
  arg1 = (posh_u64_t)(val1);
  result = (MarshalledValue)U64_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_U64_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "U64_type", 0, 0, 0)) goto fail;
  result = (char *)U64_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_U8_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (unsigned char *) malloc((arg1)*sizeof(unsigned char));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(toInterger("unsigned char", item, &arg2[i]) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "invalid list contents"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)U8_List_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
  }
  return ((void *)0);
}


static  PyObject *_wrap_U8_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned char arg1 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_unsigned_SS_char(swig_obj[0], &val1);
  if (!(ecode1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((ecode1 != (-1)) ? ecode1 : -5)), "in method '" "U8_marshal" "', argument " "1"" of type '" "unsigned char""'"); goto fail; } while(0);
  } 
  arg1 = (unsigned char)(val1);
  result = (MarshalledValue)U8_marshal(arg1);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_U8_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "U8_type", 0, 0, 0)) goto fail;
  result = (char *)U8_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_UString_List_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  size_t *arg3 = (size_t *) 0 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!((((((PyObject*)(swig_obj[0]))->ob_type))->tp_flags & ((1UL << 25))) != 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "Not a list"); goto fail; } while(0);
    }
    arg1 = PyList_Size(swig_obj[0]);
    arg2 = (unsigned char **) malloc((arg1)*sizeof(unsigned char*));
    arg3 = (size_t *) malloc((arg1)*sizeof(size_t));
    for (int i = 0; i < arg1; i++) {
      PyObject *item = PyList_GetItem(swig_obj[0],i);
      if (!(SWIG_AsCharPtrAndSize(item, (char**)&arg2[i], &arg3[i], ((void *)0)) >= 0)) {
        do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "list must contain strings"); goto fail; } while(0);
      }
    }
  }
  result = (MarshalledValue)UString_List_marshal(arg1,arg2,arg3);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  {
    if (arg2) free(arg2);
    if (arg3) free(arg3);
  }
  return resultobj;
fail:
  {
    if (arg2) free(arg2);
    if (arg3) free(arg3);
  }
  return ((void *)0);
}


static  PyObject *_wrap_UString_marshal(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned char *arg1 = (unsigned char *) 0 ;
  size_t arg2 ;
  PyObject *swig_obj[1] ;
  MarshalledValue result;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  {
    if (!(SWIG_AsCharPtrAndSize(swig_obj[0], (char**)&arg1, &arg2, ((void *)0)) >= 0)) {
      do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(-5), "argument " "1"" of type '" "unsigned char *""'"); goto fail; } while(0);
    }
  }
  result = (MarshalledValue)UString_marshal(arg1,arg2);
  {
    resultobj = SWIG_FromCharPtr((const char *)result);
    freeMarshalledValue(result);
  }
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_UString_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "UString_type", 0, 0, 0)) goto fail;
  result = (char *)UString_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_UdpPort_type(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "UdpPort_type", 0, 0, 0)) goto fail;
  result = (char *)UdpPort_type();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_freeMarshalledValue(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  MarshalledValue arg1 = (MarshalledValue) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) goto fail;
  swig_obj[0] = args;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, ((void *)0), &alloc1);
  if (!(res1 >= 0)) {
    do { SWIG_Python_SetErrorMsg(SWIG_Python_ErrorType(((res1 != (-1)) ? res1 : -5)), "in method '" "freeMarshalledValue" "', argument " "1"" of type '" "MarshalledValue""'"); goto fail; } while(0);
  }
  arg1 = (MarshalledValue)(buf1);
  freeMarshalledValue(arg1);
  resultobj = SWIG_Py_Void();
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == ((0) | ((1 << 8) << 1))) free((char*)buf1);
  return ((void *)0);
}


static  PyObject *_wrap_fuck1(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  char result;
  
  if (!SWIG_Python_UnpackTuple(args, "fuck1", 0, 0, 0)) goto fail;
  result = (char)fuck1();
  resultobj = SWIG_From_char((char)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_fuck2(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned char result;
  
  if (!SWIG_Python_UnpackTuple(args, "fuck2", 0, 0, 0)) goto fail;
  result = (unsigned char)fuck2();
  resultobj = SWIG_From_unsigned_SS_char((unsigned char)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_fuck3(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  short result;
  
  if (!SWIG_Python_UnpackTuple(args, "fuck3", 0, 0, 0)) goto fail;
  result = (short)fuck3();
  resultobj = SWIG_From_short((short)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_fuck4(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned short result;
  
  if (!SWIG_Python_UnpackTuple(args, "fuck4", 0, 0, 0)) goto fail;
  result = (unsigned short)fuck4();
  resultobj = SWIG_From_unsigned_SS_short((unsigned short)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_fuck5(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "fuck5", 0, 0, 0)) goto fail;
  result = (int)fuck5();
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_fuck6(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int result;
  
  if (!SWIG_Python_UnpackTuple(args, "fuck6", 0, 0, 0)) goto fail;
  result = (unsigned int)fuck6();
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_fuck7(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  long long result;
  
  if (!SWIG_Python_UnpackTuple(args, "fuck7", 0, 0, 0)) goto fail;
  result = (long long)fuck7();
  resultobj = SWIG_From_long_SS_long((long long)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static  PyObject *_wrap_fuck8(PyObject *self , PyObject *args) {
  PyObject *resultobj = 0;
  unsigned long long result;
  
  if (!SWIG_Python_UnpackTuple(args, "fuck8", 0, 0, 0)) goto fail;
  result = (unsigned long long)fuck8();
  resultobj = SWIG_From_unsigned_SS_long_SS_long((unsigned long long)(result));
  return resultobj;
fail:
  return ((void *)0);
}


static PyMethodDef SwigMethods[] = {
	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, 0x0008, ((void *)0)},
	 { "Boolean_List_marshal", _wrap_Boolean_List_marshal, 0x0008, ((void *)0)},
	 { "Boolean_marshal", _wrap_Boolean_marshal, 0x0008, ((void *)0)},
	 { "Boolean_type", _wrap_Boolean_type, 0x0004, ((void *)0)},
	 { "Buffer_List_marshal", _wrap_Buffer_List_marshal, 0x0008, ((void *)0)},
	 { "Buffer_marshal", _wrap_Buffer_marshal, 0x0008, ((void *)0)},
	 { "Buffer_type", _wrap_Buffer_type, 0x0004, ((void *)0)},
	 { "Config_create", _wrap_Config_create, 0x0001, ((void *)0)},
	 { "Config_delete", _wrap_Config_delete, 0x0008, ((void *)0)},
	 { "Config_duplicate", _wrap_Config_duplicate, 0x0008, ((void *)0)},
	 { "Config_getConfigVersion", _wrap_Config_getConfigVersion, 0x0008, ((void *)0)},
	 { "Config_getConstants", _wrap_Config_getConstants, 0x0001, ((void *)0)},
	 { "Config_getID", _wrap_Config_getID, 0x0008, ((void *)0)},
	 { "Config_getInputParams", _wrap_Config_getInputParams, 0x0008, ((void *)0)},
	 { "Config_getName", _wrap_Config_getName, 0x0008, ((void *)0)},
	 { "Config_getNamespaceUri", _wrap_Config_getNamespaceUri, 0x0008, ((void *)0)},
	 { "Config_getOutputParams", _wrap_Config_getOutputParams, 0x0008, ((void *)0)},
	 { "Config_getSchemaVersion", _wrap_Config_getSchemaVersion, 0x0008, ((void *)0)},
	 { "Config_getVersion", _wrap_Config_getVersion, 0x0008, ((void *)0)},
	 { "Config_marshal", _wrap_Config_marshal, 0x0001, ((void *)0)},
	 { "Config_printUsage", _wrap_Config_printUsage, 0x0001, ((void *)0)},
	 { "Config_setConstants", _wrap_Config_setConstants, 0x0001, ((void *)0)},
	 { "Config_setInputParams", _wrap_Config_setInputParams, 0x0001, ((void *)0)},
	 { "Config_setOutputParams", _wrap_Config_setOutputParams, 0x0001, ((void *)0)},
	 { "Config_unmarshal", _wrap_Config_unmarshal, 0x0008, ((void *)0)},
	 { "FinalizeXMLUnmarshal", _wrap_FinalizeXMLUnmarshal, 0x0004, ((void *)0)},
	 { "IPv4_List_marshal", _wrap_IPv4_List_marshal, 0x0008, ((void *)0)},
	 { "IPv4_marshal", _wrap_IPv4_marshal, 0x0008, ((void *)0)},
	 { "IPv4_type", _wrap_IPv4_type, 0x0004, ((void *)0)},
	 { "IPv6_List_marshal", _wrap_IPv6_List_marshal, 0x0008, ((void *)0)},
	 { "IPv6_marshal", _wrap_IPv6_marshal, 0x0008, ((void *)0)},
	 { "IPv6_type", _wrap_IPv6_type, 0x0004, ((void *)0)},
	 { "InitializeXMLUnmarshal", _wrap_InitializeXMLUnmarshal, 0x0004, ((void *)0)},
	 { "List_format", _wrap_List_format, 0x0004, ((void *)0)},
	 { "LocalFile_List_marshal", _wrap_LocalFile_List_marshal, 0x0008, ((void *)0)},
	 { "LocalFile_marshal", _wrap_LocalFile_marshal, 0x0008, ((void *)0)},
	 { "LocalFile_type", _wrap_LocalFile_type, 0x0004, ((void *)0)},
	 { "Paramchoice_addParamgroup", _wrap_Paramchoice_addParamgroup, 0x0001, ((void *)0)},
	 { "Paramchoice_create", _wrap_Paramchoice_create, 0x0001, ((void *)0)},
	 { "Paramchoice_delete", _wrap_Paramchoice_delete, 0x0008, ((void *)0)},
	 { "Paramchoice_getDefaultValue", _wrap_Paramchoice_getDefaultValue, 0x0008, ((void *)0)},
	 { "Paramchoice_getDescription", _wrap_Paramchoice_getDescription, 0x0008, ((void *)0)},
	 { "Paramchoice_getName", _wrap_Paramchoice_getName, 0x0008, ((void *)0)},
	 { "Paramchoice_getNumParamgroups", _wrap_Paramchoice_getNumParamgroups, 0x0008, ((void *)0)},
	 { "Paramchoice_getParamgroup", _wrap_Paramchoice_getParamgroup, 0x0001, ((void *)0)},
	 { "Paramchoice_getValue", _wrap_Paramchoice_getValue, 0x0008, ((void *)0)},
	 { "Paramchoice_hasValidValue", _wrap_Paramchoice_hasValidValue, 0x0008, ((void *)0)},
	 { "Paramchoice_hasValue", _wrap_Paramchoice_hasValue, 0x0008, ((void *)0)},
	 { "Paramchoice_isValid", _wrap_Paramchoice_isValid, 0x0008, ((void *)0)},
	 { "Paramchoice_matchName", _wrap_Paramchoice_matchName, 0x0001, ((void *)0)},
	 { "Paramchoice_setValue", _wrap_Paramchoice_setValue, 0x0001, ((void *)0)},
	 { "Parameter_Boolean_List_create", _wrap_Parameter_Boolean_List_create, 0x0001, ((void *)0)},
	 { "Parameter_Boolean_List_getSize", _wrap_Parameter_Boolean_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_Boolean_List_getValue", _wrap_Parameter_Boolean_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_Boolean_List_setValue", _wrap_Parameter_Boolean_List_setValue, 0x0008, ((void *)0)},
	 { "Parameter_Boolean_create", _wrap_Parameter_Boolean_create, 0x0001, ((void *)0)},
	 { "Parameter_Boolean_getValue", _wrap_Parameter_Boolean_getValue, 0x0001, ((void *)0)},
	 { "Parameter_Boolean_setValue", _wrap_Parameter_Boolean_setValue, 0x0001, ((void *)0)},
	 { "Parameter_Buffer_List_create", _wrap_Parameter_Buffer_List_create, 0x0001, ((void *)0)},
	 { "Parameter_Buffer_List_getSize", _wrap_Parameter_Buffer_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_Buffer_List_getValue", _wrap_Parameter_Buffer_List_getValue, 0x0008, ((void *)0)},
	 { "Parameter_Buffer_List_setValue", _wrap_Parameter_Buffer_List_setValue, 0x0001, ((void *)0)},
	 { "Parameter_Buffer_create", _wrap_Parameter_Buffer_create, 0x0001, ((void *)0)},
	 { "Parameter_Buffer_getValue", _wrap_Parameter_Buffer_getValue, 0x0001, ((void *)0)},
	 { "Parameter_Buffer_setValue", _wrap_Parameter_Buffer_setValue, 0x0001, ((void *)0)},
	 { "Parameter_IPv4_List_create", _wrap_Parameter_IPv4_List_create, 0x0001, ((void *)0)},
	 { "Parameter_IPv4_List_getSize", _wrap_Parameter_IPv4_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_IPv4_List_getValue", _wrap_Parameter_IPv4_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_IPv4_List_setValue", _wrap_Parameter_IPv4_List_setValue, 0x0001, ((void *)0)},
	 { "Parameter_IPv4_create", _wrap_Parameter_IPv4_create, 0x0001, ((void *)0)},
	 { "Parameter_IPv4_getValue", _wrap_Parameter_IPv4_getValue, 0x0001, ((void *)0)},
	 { "Parameter_IPv4_setValue", _wrap_Parameter_IPv4_setValue, 0x0001, ((void *)0)},
	 { "Parameter_IPv6_List_create", _wrap_Parameter_IPv6_List_create, 0x0001, ((void *)0)},
	 { "Parameter_IPv6_List_getSize", _wrap_Parameter_IPv6_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_IPv6_List_getValue", _wrap_Parameter_IPv6_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_IPv6_List_setValue", _wrap_Parameter_IPv6_List_setValue, 0x0001, ((void *)0)},
	 { "Parameter_IPv6_create", _wrap_Parameter_IPv6_create, 0x0001, ((void *)0)},
	 { "Parameter_IPv6_getValue", _wrap_Parameter_IPv6_getValue, 0x0001, ((void *)0)},
	 { "Parameter_IPv6_setValue", _wrap_Parameter_IPv6_setValue, 0x0001, ((void *)0)},
	 { "Parameter_LocalFile_List_create", _wrap_Parameter_LocalFile_List_create, 0x0001, ((void *)0)},
	 { "Parameter_LocalFile_List_getSize", _wrap_Parameter_LocalFile_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_LocalFile_List_getValue", _wrap_Parameter_LocalFile_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_LocalFile_List_setValue", _wrap_Parameter_LocalFile_List_setValue, 0x0001, ((void *)0)},
	 { "Parameter_LocalFile_create", _wrap_Parameter_LocalFile_create, 0x0001, ((void *)0)},
	 { "Parameter_LocalFile_getValue", _wrap_Parameter_LocalFile_getValue, 0x0001, ((void *)0)},
	 { "Parameter_LocalFile_setValue", _wrap_Parameter_LocalFile_setValue, 0x0001, ((void *)0)},
	 { "Parameter_Port_List_getSize", _wrap_Parameter_Port_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_Port_List_getValue", _wrap_Parameter_Port_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_Port_List_setValue", _wrap_Parameter_Port_List_setValue, 0x0008, ((void *)0)},
	 { "Parameter_Port_getValue", _wrap_Parameter_Port_getValue, 0x0001, ((void *)0)},
	 { "Parameter_Port_setValue", _wrap_Parameter_Port_setValue, 0x0001, ((void *)0)},
	 { "Parameter_S16_List_create", _wrap_Parameter_S16_List_create, 0x0001, ((void *)0)},
	 { "Parameter_S16_List_getSize", _wrap_Parameter_S16_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_S16_List_getValue", _wrap_Parameter_S16_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_S16_List_setValue", _wrap_Parameter_S16_List_setValue, 0x0008, ((void *)0)},
	 { "Parameter_S16_create", _wrap_Parameter_S16_create, 0x0001, ((void *)0)},
	 { "Parameter_S16_getValue", _wrap_Parameter_S16_getValue, 0x0001, ((void *)0)},
	 { "Parameter_S16_setValue", _wrap_Parameter_S16_setValue, 0x0001, ((void *)0)},
	 { "Parameter_S32_List_create", _wrap_Parameter_S32_List_create, 0x0001, ((void *)0)},
	 { "Parameter_S32_List_getSize", _wrap_Parameter_S32_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_S32_List_getValue", _wrap_Parameter_S32_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_S32_List_setValue", _wrap_Parameter_S32_List_setValue, 0x0008, ((void *)0)},
	 { "Parameter_S32_create", _wrap_Parameter_S32_create, 0x0001, ((void *)0)},
	 { "Parameter_S32_getValue", _wrap_Parameter_S32_getValue, 0x0001, ((void *)0)},
	 { "Parameter_S32_setValue", _wrap_Parameter_S32_setValue, 0x0001, ((void *)0)},
	 { "Parameter_S64_List_create", _wrap_Parameter_S64_List_create, 0x0001, ((void *)0)},
	 { "Parameter_S64_List_getSize", _wrap_Parameter_S64_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_S64_List_getValue", _wrap_Parameter_S64_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_S64_List_setValue", _wrap_Parameter_S64_List_setValue, 0x0008, ((void *)0)},
	 { "Parameter_S64_create", _wrap_Parameter_S64_create, 0x0001, ((void *)0)},
	 { "Parameter_S64_getValue", _wrap_Parameter_S64_getValue, 0x0001, ((void *)0)},
	 { "Parameter_S64_setValue", _wrap_Parameter_S64_setValue, 0x0001, ((void *)0)},
	 { "Parameter_S8_List_create", _wrap_Parameter_S8_List_create, 0x0001, ((void *)0)},
	 { "Parameter_S8_List_getSize", _wrap_Parameter_S8_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_S8_List_getValue", _wrap_Parameter_S8_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_S8_List_setValue", _wrap_Parameter_S8_List_setValue, 0x0001, ((void *)0)},
	 { "Parameter_S8_create", _wrap_Parameter_S8_create, 0x0001, ((void *)0)},
	 { "Parameter_S8_getValue", _wrap_Parameter_S8_getValue, 0x0001, ((void *)0)},
	 { "Parameter_S8_setValue", _wrap_Parameter_S8_setValue, 0x0001, ((void *)0)},
	 { "Parameter_Socket_List_create", _wrap_Parameter_Socket_List_create, 0x0001, ((void *)0)},
	 { "Parameter_Socket_List_getSize", _wrap_Parameter_Socket_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_Socket_List_getValue", _wrap_Parameter_Socket_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_Socket_List_setValue", _wrap_Parameter_Socket_List_setValue, 0x0008, ((void *)0)},
	 { "Parameter_Socket_create", _wrap_Parameter_Socket_create, 0x0001, ((void *)0)},
	 { "Parameter_Socket_getValue", _wrap_Parameter_Socket_getValue, 0x0001, ((void *)0)},
	 { "Parameter_Socket_setValue", _wrap_Parameter_Socket_setValue, 0x0001, ((void *)0)},
	 { "Parameter_String_List_create", _wrap_Parameter_String_List_create, 0x0001, ((void *)0)},
	 { "Parameter_String_List_getSize", _wrap_Parameter_String_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_String_List_getValue", _wrap_Parameter_String_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_String_List_setValue", _wrap_Parameter_String_List_setValue, 0x0001, ((void *)0)},
	 { "Parameter_String_create", _wrap_Parameter_String_create, 0x0001, ((void *)0)},
	 { "Parameter_String_getValue", _wrap_Parameter_String_getValue, 0x0001, ((void *)0)},
	 { "Parameter_String_setValue", _wrap_Parameter_String_setValue, 0x0001, ((void *)0)},
	 { "Parameter_TcpPort_List_create", _wrap_Parameter_TcpPort_List_create, 0x0001, ((void *)0)},
	 { "Parameter_TcpPort_create", _wrap_Parameter_TcpPort_create, 0x0001, ((void *)0)},
	 { "Parameter_U16_List_create", _wrap_Parameter_U16_List_create, 0x0001, ((void *)0)},
	 { "Parameter_U16_List_getSize", _wrap_Parameter_U16_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_U16_List_getValue", _wrap_Parameter_U16_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_U16_List_setValue", _wrap_Parameter_U16_List_setValue, 0x0008, ((void *)0)},
	 { "Parameter_U16_create", _wrap_Parameter_U16_create, 0x0001, ((void *)0)},
	 { "Parameter_U16_getValue", _wrap_Parameter_U16_getValue, 0x0001, ((void *)0)},
	 { "Parameter_U16_setValue", _wrap_Parameter_U16_setValue, 0x0001, ((void *)0)},
	 { "Parameter_U32_List_create", _wrap_Parameter_U32_List_create, 0x0001, ((void *)0)},
	 { "Parameter_U32_List_getSize", _wrap_Parameter_U32_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_U32_List_getValue", _wrap_Parameter_U32_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_U32_List_setValue", _wrap_Parameter_U32_List_setValue, 0x0008, ((void *)0)},
	 { "Parameter_U32_create", _wrap_Parameter_U32_create, 0x0001, ((void *)0)},
	 { "Parameter_U32_getValue", _wrap_Parameter_U32_getValue, 0x0001, ((void *)0)},
	 { "Parameter_U32_setValue", _wrap_Parameter_U32_setValue, 0x0001, ((void *)0)},
	 { "Parameter_U64_List_create", _wrap_Parameter_U64_List_create, 0x0001, ((void *)0)},
	 { "Parameter_U64_List_getSize", _wrap_Parameter_U64_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_U64_List_getValue", _wrap_Parameter_U64_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_U64_List_setValue", _wrap_Parameter_U64_List_setValue, 0x0008, ((void *)0)},
	 { "Parameter_U64_create", _wrap_Parameter_U64_create, 0x0001, ((void *)0)},
	 { "Parameter_U64_getValue", _wrap_Parameter_U64_getValue, 0x0001, ((void *)0)},
	 { "Parameter_U64_setValue", _wrap_Parameter_U64_setValue, 0x0001, ((void *)0)},
	 { "Parameter_U8_List_create", _wrap_Parameter_U8_List_create, 0x0001, ((void *)0)},
	 { "Parameter_U8_List_getSize", _wrap_Parameter_U8_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_U8_List_getValue", _wrap_Parameter_U8_List_getValue, 0x0001, ((void *)0)},
	 { "Parameter_U8_List_setValue", _wrap_Parameter_U8_List_setValue, 0x0001, ((void *)0)},
	 { "Parameter_U8_create", _wrap_Parameter_U8_create, 0x0001, ((void *)0)},
	 { "Parameter_U8_getValue", _wrap_Parameter_U8_getValue, 0x0001, ((void *)0)},
	 { "Parameter_U8_setValue", _wrap_Parameter_U8_setValue, 0x0001, ((void *)0)},
	 { "Parameter_UString_List_create", _wrap_Parameter_UString_List_create, 0x0001, ((void *)0)},
	 { "Parameter_UString_List_getSize", _wrap_Parameter_UString_List_getSize, 0x0001, ((void *)0)},
	 { "Parameter_UString_List_getValue", _wrap_Parameter_UString_List_getValue, 0x0008, ((void *)0)},
	 { "Parameter_UString_List_setValue", _wrap_Parameter_UString_List_setValue, 0x0001, ((void *)0)},
	 { "Parameter_UString_create", _wrap_Parameter_UString_create, 0x0001, ((void *)0)},
	 { "Parameter_UString_getValue", _wrap_Parameter_UString_getValue, 0x0001, ((void *)0)},
	 { "Parameter_UString_setValue", _wrap_Parameter_UString_setValue, 0x0001, ((void *)0)},
	 { "Parameter_UdpPort_List_create", _wrap_Parameter_UdpPort_List_create, 0x0001, ((void *)0)},
	 { "Parameter_UdpPort_create", _wrap_Parameter_UdpPort_create, 0x0001, ((void *)0)},
	 { "Parameter_delete", _wrap_Parameter_delete, 0x0008, ((void *)0)},
	 { "Parameter_getDescription", _wrap_Parameter_getDescription, 0x0001, ((void *)0)},
	 { "Parameter_getFormat", _wrap_Parameter_getFormat, 0x0001, ((void *)0)},
	 { "Parameter_getInvalidReason", _wrap_Parameter_getInvalidReason, 0x0001, ((void *)0)},
	 { "Parameter_getMarshalledDefault", _wrap_Parameter_getMarshalledDefault, 0x0001, ((void *)0)},
	 { "Parameter_getMarshalledValue", _wrap_Parameter_getMarshalledValue, 0x0001, ((void *)0)},
	 { "Parameter_getName", _wrap_Parameter_getName, 0x0001, ((void *)0)},
	 { "Parameter_getType", _wrap_Parameter_getType, 0x0001, ((void *)0)},
	 { "Parameter_hasValidValue", _wrap_Parameter_hasValidValue, 0x0004, ((void *)0)},
	 { "Parameter_hasValue", _wrap_Parameter_hasValue, 0x0008, ((void *)0)},
	 { "Parameter_hide", _wrap_Parameter_hide, 0x0008, ((void *)0)},
	 { "Parameter_isHidden", _wrap_Parameter_isHidden, 0x0008, ((void *)0)},
	 { "Parameter_isRequired", _wrap_Parameter_isRequired, 0x0008, ((void *)0)},
	 { "Parameter_isValid", _wrap_Parameter_isValid, 0x0001, ((void *)0)},
	 { "Parameter_markInvalid", _wrap_Parameter_markInvalid, 0x0008, ((void *)0)},
	 { "Parameter_markInvalidWithReason", _wrap_Parameter_markInvalidWithReason, 0x0001, ((void *)0)},
	 { "Parameter_matchFormat", _wrap_Parameter_matchFormat, 0x0001, ((void *)0)},
	 { "Parameter_matchFormatAndType", _wrap_Parameter_matchFormatAndType, 0x0001, ((void *)0)},
	 { "Parameter_matchName", _wrap_Parameter_matchName, 0x0001, ((void *)0)},
	 { "Parameter_matchType", _wrap_Parameter_matchType, 0x0001, ((void *)0)},
	 { "Parameter_resetValue", _wrap_Parameter_resetValue, 0x0008, ((void *)0)},
	 { "Parameter_setMarshalledValue", _wrap_Parameter_setMarshalledValue, 0x0001, ((void *)0)},
	 { "Paramgroup_addParamchoice", _wrap_Paramgroup_addParamchoice, 0x0001, ((void *)0)},
	 { "Paramgroup_addParameter", _wrap_Paramgroup_addParameter, 0x0001, ((void *)0)},
	 { "Paramgroup_create", _wrap_Paramgroup_create, 0x0001, ((void *)0)},
	 { "Paramgroup_delete", _wrap_Paramgroup_delete, 0x0008, ((void *)0)},
	 { "Paramgroup_getDescription", _wrap_Paramgroup_getDescription, 0x0001, ((void *)0)},
	 { "Paramgroup_getName", _wrap_Paramgroup_getName, 0x0001, ((void *)0)},
	 { "Paramgroup_getNumParamchoices", _wrap_Paramgroup_getNumParamchoices, 0x0008, ((void *)0)},
	 { "Paramgroup_getNumParameters", _wrap_Paramgroup_getNumParameters, 0x0008, ((void *)0)},
	 { "Paramgroup_getParamchoice", _wrap_Paramgroup_getParamchoice, 0x0001, ((void *)0)},
	 { "Paramgroup_getParameter", _wrap_Paramgroup_getParameter, 0x0001, ((void *)0)},
	 { "Paramgroup_isValid", _wrap_Paramgroup_isValid, 0x0008, ((void *)0)},
	 { "Paramgroup_matchName", _wrap_Paramgroup_matchName, 0x0001, ((void *)0)},
	 { "Paramgroup_removeParameter", _wrap_Paramgroup_removeParameter, 0x0001, ((void *)0)},
	 { "Params_addParamchoice", _wrap_Params_addParamchoice, 0x0001, ((void *)0)},
	 { "Params_addParameter", _wrap_Params_addParameter, 0x0001, ((void *)0)},
	 { "Params_create", _wrap_Params_create, 0x0001, ((void *)0)},
	 { "Params_delete", _wrap_Params_delete, 0x0008, ((void *)0)},
	 { "Params_duplicate", _wrap_Params_duplicate, 0x0008, ((void *)0)},
	 { "Params_findParamchoice", _wrap_Params_findParamchoice, 0x0001, ((void *)0)},
	 { "Params_findParameter", _wrap_Params_findParameter, 0x0001, ((void *)0)},
	 { "Params_getCallbackIPv4Values", _wrap_Params_getCallbackIPv4Values, 0x0001, ((void *)0)},
	 { "Params_getCallbackIPv6Values", _wrap_Params_getCallbackIPv6Values, 0x0001, ((void *)0)},
	 { "Params_getCallbackPortValues", _wrap_Params_getCallbackPortValues, 0x0001, ((void *)0)},
	 { "Params_getName", _wrap_Params_getName, 0x0008, ((void *)0)},
	 { "Params_getNumParamchoices", _wrap_Params_getNumParamchoices, 0x0008, ((void *)0)},
	 { "Params_getNumParameters", _wrap_Params_getNumParameters, 0x0008, ((void *)0)},
	 { "Params_getParamchoice", _wrap_Params_getParamchoice, 0x0001, ((void *)0)},
	 { "Params_getParameter", _wrap_Params_getParameter, 0x0001, ((void *)0)},
	 { "Params_isValid", _wrap_Params_isValid, 0x0008, ((void *)0)},
	 { "Params_parseCommandLine", _wrap_Params_parseCommandLine, 0x0001, ((void *)0)},
	 { "Params_printInvalid", _wrap_Params_printInvalid, 0x0001, ((void *)0)},
	 { "Params_removeParameter", _wrap_Params_removeParameter, 0x0001, ((void *)0)},
	 { "Params_validateCallbackPorts", _wrap_Params_validateCallbackPorts, 0x0001, ((void *)0)},
	 { "Port_List_marshal", _wrap_Port_List_marshal, 0x0008, ((void *)0)},
	 { "Port_marshal", _wrap_Port_marshal, 0x0008, ((void *)0)},
	 { "S16_List_marshal", _wrap_S16_List_marshal, 0x0008, ((void *)0)},
	 { "S16_marshal", _wrap_S16_marshal, 0x0008, ((void *)0)},
	 { "S16_type", _wrap_S16_type, 0x0004, ((void *)0)},
	 { "S32_List_marshal", _wrap_S32_List_marshal, 0x0008, ((void *)0)},
	 { "S32_marshal", _wrap_S32_marshal, 0x0008, ((void *)0)},
	 { "S32_type", _wrap_S32_type, 0x0004, ((void *)0)},
	 { "S64_List_marshal", _wrap_S64_List_marshal, 0x0008, ((void *)0)},
	 { "S64_marshal", _wrap_S64_marshal, 0x0008, ((void *)0)},
	 { "S64_type", _wrap_S64_type, 0x0004, ((void *)0)},
	 { "S8_List_marshal", _wrap_S8_List_marshal, 0x0008, ((void *)0)},
	 { "S8_marshal", _wrap_S8_marshal, 0x0008, ((void *)0)},
	 { "S8_type", _wrap_S8_type, 0x0004, ((void *)0)},
	 { "Scalar_format", _wrap_Scalar_format, 0x0004, ((void *)0)},
	 { "Socket_List_marshal", _wrap_Socket_List_marshal, 0x0008, ((void *)0)},
	 { "Socket_marshal", _wrap_Socket_marshal, 0x0008, ((void *)0)},
	 { "Socket_type", _wrap_Socket_type, 0x0004, ((void *)0)},
	 { "String_List_marshal", _wrap_String_List_marshal, 0x0008, ((void *)0)},
	 { "String_marshal", _wrap_String_marshal, 0x0008, ((void *)0)},
	 { "String_type", _wrap_String_type, 0x0004, ((void *)0)},
	 { "TcpPort_type", _wrap_TcpPort_type, 0x0004, ((void *)0)},
	 { "U16_List_marshal", _wrap_U16_List_marshal, 0x0008, ((void *)0)},
	 { "U16_marshal", _wrap_U16_marshal, 0x0008, ((void *)0)},
	 { "U16_type", _wrap_U16_type, 0x0004, ((void *)0)},
	 { "U32_List_marshal", _wrap_U32_List_marshal, 0x0008, ((void *)0)},
	 { "U32_marshal", _wrap_U32_marshal, 0x0008, ((void *)0)},
	 { "U32_type", _wrap_U32_type, 0x0004, ((void *)0)},
	 { "U64_List_marshal", _wrap_U64_List_marshal, 0x0008, ((void *)0)},
	 { "U64_marshal", _wrap_U64_marshal, 0x0008, ((void *)0)},
	 { "U64_type", _wrap_U64_type, 0x0004, ((void *)0)},
	 { "U8_List_marshal", _wrap_U8_List_marshal, 0x0008, ((void *)0)},
	 { "U8_marshal", _wrap_U8_marshal, 0x0008, ((void *)0)},
	 { "U8_type", _wrap_U8_type, 0x0004, ((void *)0)},
	 { "UString_List_marshal", _wrap_UString_List_marshal, 0x0008, ((void *)0)},
	 { "UString_marshal", _wrap_UString_marshal, 0x0008, ((void *)0)},
	 { "UString_type", _wrap_UString_type, 0x0004, ((void *)0)},
	 { "UdpPort_type", _wrap_UdpPort_type, 0x0004, ((void *)0)},
	 { "freeMarshalledValue", _wrap_freeMarshalledValue, 0x0008, ((void *)0)},
	 { "fuck1", _wrap_fuck1, 0x0004, ((void *)0)},
	 { "fuck2", _wrap_fuck2, 0x0004, ((void *)0)},
	 { "fuck3", _wrap_fuck3, 0x0004, ((void *)0)},
	 { "fuck4", _wrap_fuck4, 0x0004, ((void *)0)},
	 { "fuck5", _wrap_fuck5, 0x0004, ((void *)0)},
	 { "fuck6", _wrap_fuck6, 0x0004, ((void *)0)},
	 { "fuck7", _wrap_fuck7, 0x0004, ((void *)0)},
	 { "fuck8", _wrap_fuck8, 0x0004, ((void *)0)},
	 { ((void *)0), ((void *)0), 0, ((void *)0) }
};

static PyMethodDef SwigMethods_proxydocs[] = {
	 { ((void *)0), ((void *)0), 0, ((void *)0) }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Config_struct = {"_p_Config_struct", "struct Config_struct *|Config", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Paramchoice_struct = {"_p_Paramchoice_struct", "Paramchoice|struct Paramchoice_struct *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Parameter_struct = {"_p_Parameter_struct", "Parameter|struct Parameter_struct *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Paramgroup_struct = {"_p_Paramgroup_struct", "Paramgroup|struct Paramgroup_struct *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Params_struct = {"_p_Params_struct", "struct Params_struct *|Params", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TcLogger = {"_p_TcLogger", "TcLogger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p___int64 = {"_p___int64", "__int64 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long_long = {"_p_long_long", "posh_i64_t *|long long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_Params_struct = {"_p_p_Params_struct", "Params *|struct Params_struct **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_unsigned_char = {"_p_p_unsigned_char", "unsigned char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_signed___int64 = {"_p_signed___int64", "signed __int64 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_uint16_t = {"_p_uint16_t", "_WORD *|uint16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_uint32_t = {"_p_uint32_t", "uint32_t *|_DWORD *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_uint64_t = {"_p_uint64_t", "uint64_t *|_QWORD *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_uint8_t = {"_p_uint8_t", "_BYTE *|_BOOL8 *|uint8_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned___int16 = {"_p_unsigned___int16", "unsigned __int16 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned___int64 = {"_p_unsigned___int64", "unsigned __int64 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "SOCKET *|unsigned int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "posh_u64_t *|unsigned long long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Config_struct,
  &_swigt__p_Paramchoice_struct,
  &_swigt__p_Parameter_struct,
  &_swigt__p_Paramgroup_struct,
  &_swigt__p_Params_struct,
  &_swigt__p_TcLogger,
  &_swigt__p___int64,
  &_swigt__p_char,
  &_swigt__p_int,
  &_swigt__p_long_long,
  &_swigt__p_p_Params_struct,
  &_swigt__p_p_char,
  &_swigt__p_p_unsigned_char,
  &_swigt__p_short,
  &_swigt__p_signed___int64,
  &_swigt__p_size_t,
  &_swigt__p_uint16_t,
  &_swigt__p_uint32_t,
  &_swigt__p_uint64_t,
  &_swigt__p_uint8_t,
  &_swigt__p_unsigned___int16,
  &_swigt__p_unsigned___int64,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long_long,
  &_swigt__p_unsigned_short,
};

static swig_cast_info _swigc__p_Config_struct[] = {  {&_swigt__p_Config_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Paramchoice_struct[] = {  {&_swigt__p_Paramchoice_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Parameter_struct[] = {  {&_swigt__p_Parameter_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Paramgroup_struct[] = {  {&_swigt__p_Paramgroup_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Params_struct[] = {  {&_swigt__p_Params_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TcLogger[] = {  {&_swigt__p_TcLogger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p___int64[] = {  {&_swigt__p___int64, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_Params_struct[] = {  {&_swigt__p_p_Params_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_unsigned_char[] = {  {&_swigt__p_p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_signed___int64[] = {  {&_swigt__p_signed___int64, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uint16_t[] = {  {&_swigt__p_uint16_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uint32_t[] = {  {&_swigt__p_uint32_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uint64_t[] = {  {&_swigt__p_uint64_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uint8_t[] = {  {&_swigt__p_uint8_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned___int16[] = {  {&_swigt__p_unsigned___int16, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned___int64[] = {  {&_swigt__p_unsigned___int64, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long_long[] = {  {&_swigt__p_unsigned_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Config_struct,
  _swigc__p_Paramchoice_struct,
  _swigc__p_Parameter_struct,
  _swigc__p_Paramgroup_struct,
  _swigc__p_Params_struct,
  _swigc__p_TcLogger,
  _swigc__p___int64,
  _swigc__p_char,
  _swigc__p_int,
  _swigc__p_long_long,
  _swigc__p_p_Params_struct,
  _swigc__p_p_char,
  _swigc__p_p_unsigned_char,
  _swigc__p_short,
  _swigc__p_signed___int64,
  _swigc__p_size_t,
  _swigc__p_uint16_t,
  _swigc__p_uint32_t,
  _swigc__p_uint64_t,
  _swigc__p_uint8_t,
  _swigc__p_unsigned___int16,
  _swigc__p_unsigned___int64,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long_long,
  _swigc__p_unsigned_short,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};




/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */













static  void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_Python_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_Python_SetModule(&swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */



  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    



    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */



      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;



      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;



      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);



      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {



          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);



          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {



        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  















}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
static  void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}














  
  /* Python-specific SWIG API */



  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject ob_base;
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  static  PyObject *
  swig_varlink_repr(swig_varlinkobject *v ) {

    return PyUnicode_InternFromString("<Swig global variables>");



  }
  
  static  PyObject *
  swig_varlink_str(swig_varlinkobject *v) {

    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;









    return str;
  }
  
  static  void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  static  PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = ((void *)0);
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == ((void *)0) && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  static  int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  static  PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {

        { {  1, ((void *)0) }, 0 },




        "swigvarlink",                      /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        0,                                  /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
        0,                                  /* tp_del */
        0,                                  /* tp_version_tag */

        0,                                  /* tp_finalize */








      };
      varlink_type = tmp;
      type_init = 1;
      if (PyType_Ready(&varlink_type) < 0)
      return ((void *)0);
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  static  PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = ( (swig_varlinkobject *) PyObject_Init( (PyObject *) PyObject_Malloc( ( (swig_varlink_type())->tp_basicsize ) ), (swig_varlink_type())) );
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  static  void 
  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        memcpy(gv->name, name, size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  static  PyObject *
  SWIG_globals(void) {
    static PyObject *globals = 0;
    if (!globals) {
      globals = SWIG_Python_newvarlink();
    }
    return globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  static  void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case 4:
        obj = SWIG_Python_NewPointerObj(((void *)0), constants[i].pvalue, *(constants[i]).ptype, 0);
        break;
      case 5:
        obj = SWIG_Python_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        do { PyObject *_py_decref_tmp = (PyObject *)(obj); if (  --(_py_decref_tmp)->ob_refcnt != 0) ; else (   (*(((PyObject*)(_py_decref_tmp))->ob_type)->tp_dealloc)((PyObject *)(_py_decref_tmp))); } while (0);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  static  void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == 4) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              memcpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              memcpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
  /* -----------------------------------------------------------------------------
   * Method creation and docstring support functions
   * ----------------------------------------------------------------------------- */
  
  /* -----------------------------------------------------------------------------
   * Function to find the method definition with the correct docstring for the
   * proxy module as opposed to the low-level API
   * ----------------------------------------------------------------------------- */
  
  static  PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
    /* Find the function in the modified method table */
    size_t offset = 0;
    int found = 0;
    while (SwigMethods_proxydocs[offset].ml_meth != ((void *)0)) {
      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
        found = 1;
        break;
      }
      offset++;
    }
    /* Use the copy with the modified docstring if available */
    return found ? &SwigMethods_proxydocs[offset] : ((void *)0);
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyInstanceMethod_New() used in Python 3
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  static  PyObject *SWIG_PyInstanceMethod_New(PyObject *self , PyObject *func) {
    if (((((PyObject*)(func))->ob_type) == &PyCFunction_Type)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }

    return PyInstanceMethod_New(func);



  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyStaticMethod_New()
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  static  PyObject *SWIG_PyStaticMethod_New(PyObject *self , PyObject *func) {
    if (((((PyObject*)(func))->ob_type) == &PyCFunction_Type)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
    return PyStaticMethod_New(func);
  }
  




/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/





__declspec(dllexport) 

PyObject*



PyInit__pytrch(void) {
  PyObject *m, *d, *md, *globals;
  

  static struct PyModuleDef SWIG_module = {
    { {  1, ((void *)0) }, ((void *)0), 0, ((void *)0), },
    "_pytrch",
    ((void *)0),
    -1,
    SwigMethods,
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0)
  };

  







































  
  (void)globals;
  
  /* Create singletons now to avoid potential deadlocks with multi-threaded usage after module initialization */
  SWIG_This();
  SWIG_Python_TypeCache();
  SwigPyPacked_type();

  SwigPyObject_type();

  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  

  m = PyModule_Create2(&SWIG_module, 1013);



  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  





































  
  SWIG_Python_InstallConstants(d, swig_const_table);
  
  
  TrchError = PyErr_NewException("_pytrch.TrchError", ((void *)0), ((void *)0));
  (   ((PyObject *)(TrchError))->ob_refcnt++);
  PyModule_AddObject(m, "TrchError", TrchError);
  

  return m;



}

